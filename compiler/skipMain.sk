/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

module SkipMain;
/*****************************************************************************/
/* All the phases of the front-end. */
/*****************************************************************************/

fun type_program(
  context: mutable SKFS.Context,
  embeddedMode: Bool,
  files: List<String>,
): SKFS.EHandle<SkipTyping.DefFile> {
  fileDir = context.mkdir(
    SKFS.StringFile::fromFile,
    FileCache.fileDirName,
    false,
    Array[],
  );

  for (x in files) FileCache.addFile(context, x);

  parsed_program = fileDir.mapKV(
    SkipParse.DefsFile::fromFile,
    context,
    SkipParse.astDirName,
    (key, source) ~> {
      fileName = key match {
      | SKFS.SID(x) -> x
      | _ -> invariant_violation("Unexpected key type")
      };
      SkipParse.parseFile(fileName, source.value)
    },
  );

  (defsDir, childDir) = SkipExpand.program(context, parsed_program);
  inhDir = SkipInherit.populateClassesDir(context);
  SkipNaming.populateClasses(context, defsDir, inhDir, childDir);
  SkipNaming.populateFuns(context, defsDir);

  SkipTyping.program(context, embeddedMode, defsDir)
}

/*****************************************************************************/
/* Main entry point */
/*****************************************************************************/

fun compile(
  context: mutable SKFS.Context,
  files: List<String>,
  emeddedMode: Bool = false,
): SkipTypedAst.Program {
  defsProj = type_program(context, emeddedMode, files).contextWriterKeyValues(
    SkipTyping.DefFile::fromFile,
    context,
    SKFS.DirName::create("/tastProgram/"),
    (_context, writer, _, value) ~> {
      writer.writeArray(SKFS.IID(0), value)
    },
  );
  defs = defsProj.getArray(context, SKFS.IID(0));
  class_defs = UMap[];
  fun_defs = UMap[];
  const_defs = UMap[];
  for (def in defs) {
    def.value match {
    | SkipTypedAst.DClass(x) -> !class_defs[x.name] = x
    | SkipTypedAst.DFun(x) -> !fun_defs[x.name] = x
    | SkipTypedAst.DConst(x) -> !const_defs[x.name] = x
    }
  };
  SkipTypedAst.Program{class_defs, fun_defs, const_defs}
  /*
    vtry(
      () ->
        (Success() : Result<
          SkipTypedAst.Program,
          Vector<SkipError.Error>,
        >),
      exn ->
        exn match {
        // TODO: We shouldn't need the unique() here. Fix this with T21967329.
        | SkipError.SkipErrorException{errors} ->
          (Failure(errors.unique()) : Result<
            SkipTypedAst.Program,
            Vector<SkipError.Error>,
          >)
        | _ -> throw exn
        }
      ,
    )
  */
}
