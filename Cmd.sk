module SKFS;

fun countSlash(str: String): Int {
  n = 0;
  for (elt in str) {
    if (elt == '/') !n = n + 1;
  };
  n
}

fun cutAfter(level: Int, str: String): String {
  n = 0;
  i = 0;
  for (elt in str) {
    !i = i + 1;
    if (elt == '/') !n = n + 1;
    if (n == level + 1) return str.take(i);
  };
  str
}

fun listSubDirs(
  prefix: String,
  dmap: DMap<DirName, Dir>,
): Array<(FileName, Dir)> {
  dmap.visit(node -> {
    keyStr = node.key.toString();
    keyStrLen = keyStr.length();
    prefixLen = prefix.length();
    dir = if (keyStrLen < prefixLen) {
      if (prefix < keyStr) Left() else Right()
    } else {
      sub = keyStr.take(prefixLen);
      if (sub < prefix) {
        Right()
      } else if (sub > prefix) {
        Left()
      } else {
        Both()
      }
    };
    dir
  });
}

fun listDirs(
  prefix: String,
  dmap: DMap<DirName, Dir>,
): Array<(DirName, String)> {
  visited = listSubDirs(prefix, dmap);
  level = countSlash(prefix);
  visitedNames = visited
    .map(x -> cutAfter(level, x.i0.toString()))
    .map(x -> (DirName::create(x), x.stripPrefix(prefix)));
  names = Vector::mcreateFromItems(visitedNames);
  names.sort();
  names.toArray()
}

fun makeLexer(str: String): () -> (String, Int) {
  chars = str.chars();
  i = 0;
  () -> {
    tok = mutable Vector[];
    while (i < chars.size() && (chars[i] == ' ' || chars[i] == '\t')) {
      !i = i + 1;
    };
    while (i < chars.size() && chars[i] != ' ' && chars[i] != '\t') {
      tok.push(chars[i]);
      !i = i + 1;
    };
    (String::fromChars(tok.toArray()), i)
  }
}

mutable class CmdEnv{
  context: mutable Context,
  mutable pwd: String,
  evaluator: mutable SKSQL.Evaluator,
}

fun backwardsSlash(pwd: String): String {
  chars = pwd.chars();
  last = chars.size();
  nbrSlash = 0;
  while (last >= 0 && nbrSlash < 2) {
    !last = last - 1;
    if (chars[last] == '/') !nbrSlash = nbrSlash + 1;
  };
  pwd.sub(pwd.getIter(), last + 1)
}

fun absolutePath(pwd: String, cmd: String): String {
  if (cmd.startsWith("..")) {
    !cmd = cmd.stripPrefix("..");
    !pwd = backwardsSlash(pwd);
    return pwd + cmd;
  };
  if (cmd.startsWith(".")) {
    !cmd = cmd.stripPrefix(".");
    return pwd + cmd;
  };
  if (cmd.startsWith("/")) {
    return cmd;
  };
  pwd + cmd
}

fun writeCmd(env: mutable CmdEnv, pathStr: String, cmd: String): void {
  if (cmd != "") {
    !cmd = cmd.stripPrefix(cmd.take(1));
  };
  path = Path::fromString(pathStr);
  env.context.maybeGetDir(path.dirName) match {
  | None() -> print_error("Could not find input directory: " + path.dirName)
  | Some(dir) if (!dir.isInput) ->
    print_error("Not an input Dir: " + path.dirName)
  | Some(dir) ->
    if (cmd == "") {
      dir.writeArray(env.context, path.baseName, Array[]);
    } else {
      dir.writeArray(env.context, path.baseName, Array[StringFile(cmd)]);
    }
  };
  env.context.update();
}

fun eval(env: mutable CmdEnv, cmd: String): void {
  nextToken = makeLexer(cmd);
  token = nextToken();
  token.i0 match {
  | "ls" ->
    result = mutable Set[];
    subDirs = listDirs(env.pwd, env.context.dirs.state);
    for (kv in subDirs) {
      (_, relDirName) = kv;
      if (relDirName != "") result.insert(relDirName);
    };
    (path, _) = nextToken();
    dirName = if (path == "") env.pwd else absolutePath(env.pwd, path);
    if (!DirName::isValidDirName(dirName)) {
      print_error("Invalid dir name: " + dirName);
      return void;
    };
    if (dirName != "/") {
      env.context.maybeGetDir(DirName::create(dirName)) match {
      | None() -> print_error("Dir not found: " + dirName)
      | Some(dir) ->
        files = dir.files();
        for (file in files) {
          if (dir.getArrayRaw(file).size() > 0) {
            result.insert(file.toString());
          }
        }
      }
    };
    result.each(x -> print_string(x))
  | "cd" ->
    tok = nextToken().i0;
    dirName = if (tok == "") "/" else absolutePath(env.pwd, tok);
    if (!dirName.endsWith("/")) {
      !dirName = dirName + "/";
    };
    if (dirName == "") {
      print_error("Error: expected directory name\n");
      return void;
    };
    if (dirName == "/") env.!pwd = dirName else {
      env.context.maybeGetDir(DirName::create(dirName)) match {
      | None() -> print_error("Dir not found: " + dirName)
      | Some _ -> env.!pwd = dirName
      }
    }
  | "cat" ->
    files = mutable Vector[];
    tok = nextToken().i0;
    while (tok != "") {
      files.push(tok);
      !tok = nextToken().i0;
    };
    if (files.size() == 0) {
      print_error("Error: expected file name\n");
      return void;
    };
    files.each(entry -> {
      pathStr = absolutePath(env.pwd, entry);
      path = Path::fromString(pathStr);
      env.context.maybeGetDir(path.dirName) match {
      | None() -> print_string(`<EMPTY:${path}>`)
      | Some(dir) ->
        arr = dir.getArrayRaw(path.baseName);
        if (arr.size() == 0) {
          print_string(`<EMPTY:${path}>`)
        } else if (arr.size() == 1) {
          arr[0] match {
          | StringFile(x) -> print_string(x)
          | y -> debug(y)
          }
        } else {
          debug(arr);
        }
      };
    })
  | "write" ->
    (pathStr, idx) = nextToken();
    !pathStr = absolutePath(env.pwd, pathStr);
    !cmd = cmd.stripPrefix(cmd.take(idx));
    writeCmd(env, pathStr, cmd)
  | "rm" ->
    (pathStr, idx) = nextToken();
    !pathStr = absolutePath(env.pwd, pathStr);
    !cmd = cmd.stripPrefix(cmd.take(idx));
    writeCmd(env, pathStr, "")
  | _ -> print_string("Unknown command")
  }
}

fun isSQL(str: String): Bool {
  chars = str.chars().toArray();
  lex = SKSQL.Lexer(0, chars);
  if (SKSQL.isEOF(lex, 0)) return false;
  lex.word(0).uppercase() match {
  | "CREATE" | "INSERT" | "UPDATE" | "DROP" | "DELETE" | "REPLACE" | "SELECT" ->
    true
  | _ -> false
  }
}

fun parseSQLStmt(idRoot: Int, cmd: String): ?SKSQL.Stmt {
  chars = cmd.chars().toArray();
  lex = SKSQL.Lexer(idRoot, chars);
  (_, stmtAst) = SKSQL.parseStmt(lex, 0);
  Some(stmtAst)
}

untracked fun toplevel(topContext: mutable Context): void {
  runWithGc(topContext.clone(), savedContext ~> {
    context = Context::fromSaved(savedContext);
    evaluator = context.getGlobal("SQLEvaluator") match {
    | Some(x @ SKSQL.EvaluatorSaved _) -> SKSQL.Evaluator::fromSaved(context, x)
    | _ ->
      evaluator = SKSQL.Evaluator::create(context);
      context.setGlobal("Evaluator", evaluator.save());
      evaluator
    };
    env = mutable CmdEnv{context, pwd => context.pwd, evaluator};
    prompt = env.pwd + "$ ";
    print_raw(prompt);
    cmd = vtry(() -> read_line(), _exn -> "");
    if (cmd == "") return None();
    if (isSQL(cmd)) {
      vtry(
        () -> {
          sqlOpt = parseSQLStmt(evaluator.idRoot, cmd);
          sqlOpt match {
          | None() -> void
          | Some(sql) ->
            env.evaluator.stmt(sql);
            evaluator.!idRoot = evaluator.idRoot + 1;
            sql match {
            | select @ SKSQL.Select _ -> SKSQL.showSelect(context, select)
            | _ -> void
            }
          }
        },
        exn ->
          exn match {
          | SKSQL.Error(_, msg) -> print_error(msg)
          | _ -> print_error("Unknown error")
          }
        ,
      );
    } else {
      eval(env, cmd);
    };
    context.setGlobal("SQLEvaluator", evaluator.save());
    context.!pwd = env.pwd;
    Some(context.clone())
  })
}
