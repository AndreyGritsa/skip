module SKFS;

base class File uses Hashable, Orderable, Show {}

type MapFun<Value, Value2> = (mutable Context, BaseName, Array<Value>) ~> Array<
  (BaseName, Array<Value2>),
>;

class FileNotFound(path: Path) extends SKFS.Exception {
  fun toString(): String {
    `File not found: ${this.path}`
  }
}
class DuplicateValues(path: Path) extends SKFS.Exception {
  fun toString(): String {
    `Duplicate values found for path: ${this.path}`
  }
}

value class FixedRow<T: Hashable & Orderable>(
  key: BaseName,
  value: T,
) uses Hashable, Orderable

value class RowMapped<T: File>(
  key: BaseName,
  reads: Vector<Path>,
  values: Array<FixedRow<T>>,
  error: ?String,
)

value class GroupedRows<T: File>(
  rows: Array<FixedRow<T>>,
  maps: Array<FixedRow<Path>>,
  errors: Table<MapError>,
)

class FixedData<T>{dirName: DirName, data: Array<FixedRow<T>> = Array[]} {
  fun getPos(key: BaseName, i: Int, j: Int): Int {
    if (i > j) {
      return i;
    };
    pivot = (i + j) / 2;
    key.compare(this.data[pivot].key) match {
    | LT()
    | EQ() ->
      this.getPos(key, i, pivot - 1)
    | GT() -> this.getPos(key, pivot + 1, j)
    }
  }

  fun getArray(key: BaseName): Array<T> {
    pos = this.getPos(key, 0, this.data.size() - 1);
    result = mutable Vector[];
    while (pos < this.data.size() && this.data[pos].key == key) {
      result.push(this.data[pos].value);
      !pos = pos + 1;
    };
    result.toArray();
  }

  fun maybeGet(key: BaseName): ?T {
    arr = this.getArray(key);
    if (arr.size() > 2) {
      path = Path::create(this.dirName, key);
      throw (DuplicateValues(path))
    };
    if (arr.size() == 0) {
      return None();
    };
    Some(arr[0])
  }

  fun get(key: BaseName): T {
    this.maybeGet(key) match {
    | None() ->
      path = Path::create(this.dirName, key);
      throw (FileNotFound(path))
    | Some(x) -> x
    }
  }
}

class MapError(msg: String) extends File {
  fun toString(): String {
    "Error: " + this.msg
  }
}

class Dir<Value: File>{
  time: Int,
  dirName: DirName,
  fixedData: FixedData<Value>,
  fixedMap: FixedData<Path>,
  data: Table<File> = Table::create(),
  errors: Table<MapError> = Table::create(),
  map: SortedMap<BaseName, Array<Path>> = SortedMap[],
  childDirs: List<DirName> = List[],
  fixedReaders: SortedMap<DirName, FixedData<BaseName>> = SortedMap[],
  readers: SortedMap<BaseName, Source> = SortedMap[],
  dirty: SortedSet<BaseName> = SortedSet[],
} {
  fun getDirName(): DirName {
    this.dirName
  }

  fun getThis(context: mutable Context): this {
    !this = if (context.state.dirs.state.containsKey(this.dirName)) {
      context.state.dirs[DirRef<Value>(this.dirName)];
    } else {
      this
    };
    this
  }

  fun getMap(key: BaseName): Array<Path> {
    if (this.map.containsKey(key)) {
      this.map[key]
    } else {
      this.fixedMap.getArray(key)
    }
  }

  private fun getArrayRaw(key: BaseName): Array<Value> {
    if (this.data.containsKey(key)) {
      this.data[key].map(x -> unsafeFromFile(x));
    } else {
      this.fixedData.getArray(key);
    }
  }

  fun getArray(context: mutable Context, key: BaseName): Array<Value> {
    !this = this.getThis(context);
    path = Path::create(this.dirName, key);
    context.addDep(path);
    this.getArrayRaw(key)
  }

  fun mapRow<Value2: File>(
    state: State,
    key: BaseName,
    f: MapFun<Value, Value2>,
  ): RowMapped<Value2> {
    localContext = mutable Context{state, reads => mutable Vector[]};
    values = this.getArrayRaw(key);
    (kvArray, error) = try {
      (f(localContext, key, values), None())
    } catch {
    | e -> (Array[], Some(e.getMessage()))
    };
    rows = kvArray
      .map(kv2 -> {
        (k2, v2) = kv2;
        v2.map(x -> FixedRow(k2, x))
      })
      .flatten();
    RowMapped(key, freeze(localContext.reads), rows, error)
  }

  fun regroupMap<Value2: File>(
    dirName: DirName,
    mapped: Array<RowMapped<Value2>>,
  ): GroupedRows<Value2> {
    rowVec = mutable Vector[];
    mapVec = mutable Vector[];
    errors = Table::create();
    for (rowMapped in mapped) {
      key = rowMapped.key;
      rows = rowMapped.values;
      for (row in rows) {
        mapVec.push(FixedRow(key, Path::create(dirName, row.key)));
        rowVec.push(row);
      };
      rowMapped.error match {
      | None() -> void
      | Some(error) ->
        source = Source(Path::create(this.dirName, key), dirName);
        !errors = errors.set(source, key, Array[MapError(error)])
      }
    };
    rowVec.sort();
    mapVec.sort();
    GroupedRows(rowVec.toArray(), mapVec.toArray(), errors)
  }

  fun updateFixedReaders<Value2>(
    context: mutable Context,
    dirName: DirName,
    mapped: Array<RowMapped<Value2>>,
  ): void {
    readDirs = mutable Map[];
    for (row in mapped) {
      for (read in row.reads) {
        if (!readDirs.containsKey(read.dirName)) {
          readDirs![read.dirName] = mutable Vector[];
        };
        readDirs[read.dirName].push(FixedRow(read.baseName, row.key));
      }
    };
    for (readDirName => reads in readDirs) {
      reads.sort();
      uniqReads = reads.unique();
      readDir = context.state.dirs.get(DirRef<File>(readDirName));
      !readDir.fixedReaders[dirName] = FixedData{
        dirName,
        data => uniqReads.toArray(),
      };
      context.setDir(DirRef<File>(readDirName), readDir);
    }
  }

  fun multiMap<Value2: File>(
    context: mutable Context,
    dirNameStr: String,
    f: MapFun<Value, Value2>,
  ): Dir<Value2> {
    dirName = DirName::create(dirNameStr);
    state = context.state;
    invariant(context.reads.isEmpty());
    invariant(this.data.isEmpty());
    mapped = this.fixedData.data.map(row ~> this.mapRow(state, row.key, f));
    grouped = this.regroupMap(dirName, mapped);
    this.updateFixedReaders(context, dirName, mapped);
    time = context.timeStamp();
    fixedData = FixedData{dirName, data => grouped.rows};
    fixedMap = FixedData{dirName, data => Array[]};
    parentFixedMap = FixedData{dirName, data => grouped.maps};
    errors = grouped.errors;
    dir = Dir{time, dirName, fixedData, fixedMap, errors};
    parent = this with {fixedMap => parentFixedMap};
    !parent.childDirs = List.Cons(dirName, parent.childDirs);
    context.setDir(DirRef<Value>(parent.dirName), parent);
    context.setDir(DirRef<Value2>(dirName), dir);
    context.setFun(FunRef<File, Value2>(dirName), (context, key, values) ~>
      f(context, key, values.map(unsafeFromFile))
    );
    dir
  }

  fun update(context: mutable Context): void {
    invariant(context.toUpdate.containsKey(this.time));

    // Remove ourselves from the list of directories to process.
    context.!toUpdate = context.toUpdate.remove(this.time);

    // We have been removed from the set of directories.
    // This can happen when an old dependency changed.
    // Because of the change, the directory gets added
    // to the list of directories to update. But in the mean time
    // the source no longer creates this directory.
    if (!context.state.dirs.state.containsKey(this.dirName)) {
      return void;
    };

    // We need to get the most up to date version of ourselves.
    // So "this" might be outdated ...
    !this = context.state.dirs.get(DirRef<Value>(this.dirName));

    // The oldMap contains a map of the keys that were produced
    // the last time around. This is going to be useful to determine
    // which keys need to be removed.
    oldMap = mutable Map[];
    for (key in this.dirty) {
      for (path in this.getMap(key)) {
        if (!oldMap.containsKey(path.dirName)) {
          oldMap![path.dirName] = mutable Set[];
        };
        oldMap[path.dirName].insert(path.baseName);
      }
    };

    for (key in this.dirty) {
      for (childName in this.childDirs) {
        child = context.state.dirs.get(DirRef<File>(childName));
        values = this.getArray(context, key);
        source = Source(Path::create(this.dirName, key), child.dirName);
        oldKeys = oldMap[childName];
        !child = child.updateChildForKey(context, oldKeys, source, key, values);
        context.setDir(DirRef<File>(child.dirName), child);
      };
    };
  }

  private fun updateChildForKey<T: File>(
    context: mutable Context,
    oldKeys: mutable Set<BaseName>,
    source: Source,
    key: BaseName,
    values: Array<T>,
  ): this {
    mapFun = context.state.funs.get(FunRef<T, Value>(this.dirName));
    mapped = mapFun(context, key, values);
    for (kv in mapped) {
      (k, rvalues) = kv;
      if (oldKeys.contains(k)) {
        oldKeys.remove(k);
      };
      !this = this.writeEntry(context, source, k, rvalues);
    };
    // Let's remove the keys that no longer exist.
    for (k in oldKeys) {
      !this = this.writeEntry(context, source, k, Array[]);
    };
    this
  }

  fun writeEntry(
    context: mutable Context,
    source: Source,
    k: BaseName,
    rvalues: Array<Value>,
  ): this {
    // The object is still in fixedData
    if (!this.data.containsKey(k)) {
      array = this.fixedData.getArray(k);
      !this.data = this.data.set(source, k, array);
    };
    irvalues = rvalues.map(x -> unsafeToFile(intern(x)));
    (data, wasUpdated) = this.data.setWithStatus(source, k, irvalues);
    if (wasUpdated) {
      dirty = this.dirty.set(k);
      !this = this with {data, dirty};
      newThis = this;
      updateFun = context ~> newThis.update(context);
      context.!toUpdate = context.toUpdate.set(newThis.time, updateFun);
    };
    this
  }

  fun writeArray(
    context: mutable Context,
    key: BaseName,
    values: Array<Value>,
  ): void {
    !this = context.state.dirs.get(DirRef<Value>(this.dirName));
    source = Source(Path::create(this.dirName, key), this.dirName);
    !this = this.writeEntry(context, source, key, values);
    context.setDir(DirRef<Value>(this.dirName), this);
  }
}

module end;
