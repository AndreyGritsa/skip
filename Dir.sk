module SKFS;

@cpp_extern("SKIP_unsafe")
private native fun unsafeFromFile<T>(File): T;

@cpp_extern("SKIP_unsafe")
private native fun unsafeToFile<T>(T): File;

value class Source(
  origKey: Path,
  targetDir: DirName,
) uses Hashable, Orderable, Show {
  fun toString(): String {
    "Source(" + this.origKey + ", " + this.targetDir + ")"
  }
}

base class File uses Hashable, Orderable, Show {}

type MapFun<Value, Value2> = (mutable Context, BaseName, Array<Value>) ~> Array<
  (BaseName, Array<Value2>),
>;

class FileNotFound(path: Path) extends SKFS.Exception {
  fun toString(): String {
    `File not found: ${this.path}`
  }
}
class DuplicateValues(path: Path) extends SKFS.Exception {
  fun toString(): String {
    `Duplicate values found for path: ${this.path}`
  }
}

value class FixedRow<T: Hashable & Orderable>(
  key: BaseName,
  value: T,
) uses Hashable, Orderable

value class RowMapped<T: File>(
  key: BaseName,
  reads: Vector<Path>,
  values: Array<FixedRow<T>>,
  error: ?String,
)

value class GroupedRows<T: File>(
  rows: Array<FixedRow<T>>,
  old: Array<FixedRow<BaseName>>,
  errors: SortedMap<BaseName, Array<MapError>>,
)

class FixedData<T>{dirName: DirName, data: Array<FixedRow<T>> = Array[]} {
  fun getPos(key: BaseName, i: Int, j: Int): Int {
    if (i > j) {
      return i;
    };
    pivot = (i + j) / 2;
    key.compare(this.data[pivot].key) match {
    | LT()
    | EQ() ->
      this.getPos(key, i, pivot - 1)
    | GT() -> this.getPos(key, pivot + 1, j)
    }
  }

  fun getArray(key: BaseName): Array<T> {
    pos = this.getPos(key, 0, this.data.size() - 1);
    result = mutable Vector[];
    while (pos < this.data.size() && this.data[pos].key == key) {
      result.push(this.data[pos].value);
      !pos = pos + 1;
    };
    result.toArray();
  }

  fun maybeGet(key: BaseName): ?T {
    arr = this.getArray(key);
    if (arr.size() > 2) {
      path = Path::create(this.dirName, key);
      throw (DuplicateValues(path))
    };
    if (arr.size() == 0) {
      return None();
    };
    Some(arr[0])
  }

  fun get(key: BaseName): T {
    this.maybeGet(key) match {
    | None() ->
      path = Path::create(this.dirName, key);
      throw (FileNotFound(path))
    | Some(x) -> x
    }
  }
}

class MapError(msg: String) extends File {
  fun toString(): String {
    "Error: " + this.msg
  }
}

class Dir<Value: File>{
  time: Int,
  dirName: DirName,
  fixedData: FixedData<Value>,
  fixedOld: SortedMap<DirName, FixedData<BaseName>> = SortedMap[],
  data: SortedMap<BaseName, Array<File>> = SortedMap[],
  errors: SortedMap<BaseName, Array<MapError>> = SortedMap[],
  old: SortedMap<DirName, SortedMap<BaseName, Array<BaseName>>> = SortedMap[],
  childDirs: List<DirName> = List[],
  fixedReaders: SortedMap<DirName, FixedData<BaseName>> = SortedMap[],
  readers: SortedMap<BaseName, Source> = SortedMap[],
  dirty: SortedSet<BaseName> = SortedSet[],
} {
  fun getDirName(): DirName {
    this.dirName
  }

  fun getThis(context: mutable Context): this {
    !this = if (context.state.dirs.state.containsKey(this.dirName)) {
      context.state.dirs[DirRef<Value>(this.dirName)];
    } else {
      this
    };
    this
  }

  fun getOld(dirName: DirName, key: BaseName): Array<BaseName> {
    if (this.old.containsKey(dirName) && this.old[dirName].containsKey(key)) {
      this.old[dirName][key]
    } else {
      this.fixedOld[dirName].getArray(key)
    }
  }

  private fun getArrayRaw(key: BaseName): Array<Value> {
    if (this.data.containsKey(key)) {
      this.data[key].map(x -> unsafeFromFile(x));
    } else {
      this.fixedData.getArray(key);
    }
  }

  fun getArray(context: mutable Context, key: BaseName): Array<Value> {
    !this = this.getThis(context);
    path = Path::create(this.dirName, key);
    context.addDep(path);
    this.getArrayRaw(key)
  }

  fun mapRow<Value2: File>(
    state: State,
    key: BaseName,
    f: MapFun<Value, Value2>,
  ): RowMapped<Value2> {
    localContext = mutable Context{state, reads => mutable Vector[]};
    values = this.getArrayRaw(key);
    (kvArray, error) = try {
      (f(localContext, key, values), None())
    } catch {
    | e -> (Array[], Some(e.getMessage()))
    };
    rows = kvArray
      .map(kv2 -> {
        (k2, v2) = kv2;
        v2.map(x -> FixedRow(k2, x))
      })
      .flatten();
    RowMapped(key, freeze(localContext.reads), rows, error)
  }

  fun regroupMap<Value2: File>(
    mapped: Array<RowMapped<Value2>>,
  ): GroupedRows<Value2> {
    rowVec = mutable Vector[];
    oldVec = mutable Vector[];
    errors = SortedMap[];
    for (rowMapped in mapped) {
      key = rowMapped.key;
      rows = rowMapped.values;
      for (row in rows) {
        oldVec.push(FixedRow(key, row.key));
        rowVec.push(row);
      };
      rowMapped.error match {
      | None() -> void
      | Some(error) -> !errors = errors.set(key, Array[MapError(error)])
      }
    };
    rowVec.sort();
    oldVec.sort();
    GroupedRows(rowVec.toArray(), oldVec.toArray(), errors)
  }

  fun updateFixedReaders<Value2>(
    context: mutable Context,
    dirName: DirName,
    mapped: Array<RowMapped<Value2>>,
  ): void {
    readDirs = mutable Map[];
    for (row in mapped) {
      for (read in row.reads) {
        if (!readDirs.containsKey(read.dirName)) {
          readDirs![read.dirName] = mutable Vector[];
        };
        readDirs[read.dirName].push(FixedRow(read.baseName, row.key));
      }
    };
    for (readDirName => reads in readDirs) {
      reads.sort();
      uniqReads = reads.unique();
      readDir = context.state.dirs.get(DirRef<File>(readDirName));
      !readDir.fixedReaders[dirName] = FixedData{
        dirName,
        data => uniqReads.toArray(),
      };
      context.setDir(DirRef<File>(readDirName), readDir);
    }
  }

  fun multiMap<Value2: File>(
    context: mutable Context,
    dirNameStr: String,
    f: MapFun<Value, Value2>,
  ): Dir<Value2> {
    dirName = DirName::create(dirNameStr);
    state = context.state;
    invariant(context.reads.isEmpty());
    invariant(this.data.isEmpty());
    mapped = this.fixedData.data.map(row ~> this.mapRow(state, row.key, f));
    grouped = this.regroupMap(mapped);
    this.updateFixedReaders(context, dirName, mapped);
    time = context.timeStamp();
    fixedData = FixedData{dirName, data => grouped.rows};
    errors = grouped.errors;
    dir = Dir{time, dirName, fixedData, errors};
    parent = this;
    !parent.fixedOld[dirName] = FixedData{dirName, data => grouped.old};
    !parent.childDirs = List.Cons(dirName, parent.childDirs);
    context.setDir(DirRef<Value>(parent.dirName), parent);
    context.setDir(DirRef<Value2>(dirName), dir);
    context.setFun(FunRef<File, Value2>(dirName), (context, key, values) ~>
      f(context, key, values.map(unsafeFromFile))
    );
    dir
  }

  fun update(context: mutable Context): void {
    invariant(context.toUpdate.containsKey(this.time));

    // Remove ourselves from the list of directories to process.
    context.!toUpdate = context.toUpdate.remove(this.time);

    // We have been removed from the set of directories.
    // This can happen when an old dependency changed.
    // Because of the change, the directory gets added
    // to the list of directories to update. But in the mean time
    // the source no longer creates this directory.
    if (!context.state.dirs.state.containsKey(this.dirName)) {
      return void;
    };

    // We need to get the most up to date version of ourselves.
    // So "this" might be outdated ...
    !this = context.state.dirs.get(DirRef<Value>(this.dirName));

    for (key in this.dirty) {
      for (childName in this.childDirs) {
        child = context.state.dirs.get(DirRef<File>(childName));
        values = this.getArray(context, key);
        source = Source(Path::create(this.dirName, key), child.dirName);
        oldKeys = Set::mcreateFromItems(this.getOld(childName, key));
        (!child, newKeys) = child.updateChildForKey(
          context,
          oldKeys,
          source,
          key,
          values,
        );
        // We need to remember what keys we produced for the next
        // time around.
        reads = this.old.maybeGet(source.targetDir) match {
        | None() -> SortedMap[]
        | Some(x) -> x
        };
        !reads[key] = newKeys;
        !this.old[source.targetDir] = reads;
        context.setDir(DirRef<File>(child.dirName), child);
      };
    };
  }

  private fun updateChildForKey<T: File>(
    context: mutable Context,
    oldKeys: mutable Set<BaseName>,
    source: Source,
    key: BaseName,
    values: Array<T>,
  ): (this, Array<BaseName>) {
    mapFun = context.state.funs.get(FunRef<T, Value>(this.dirName));
    mapped = mapFun(context, key, values);
    keys = mutable Vector[];

    for (kv in mapped) {
      (k, rvalues) = kv;

      keys.push(k);
      if (oldKeys.contains(k)) {
        oldKeys.remove(k);
      };
      !this = this.writeEntry(context, source, k, rvalues);
    };
    // Let's remove the keys that no longer exist.
    for (k in oldKeys) {
      !this = this.writeEntry(context, source, k, Array[]);
    };

    (this, keys.toArray())
  }

  fun writeEntry(
    context: mutable Context,
    _source: Source,
    k: BaseName,
    rvalues: Array<Value>,
  ): this {
    // The object is still in fixedData
    if (!this.data.containsKey(k)) {
      array = this.fixedData.getArray(k);
      !this.data = this.data.set(k, array);
    };
    irvalues = rvalues.map(x -> unsafeToFile(x));
    data = this.data.set(k, irvalues);
    dirty = this.dirty.set(k);
    !this = this with {data, dirty};
    newThis = this;
    updateFun = context ~> newThis.update(context);
    context.!toUpdate = context.toUpdate.set(newThis.time, updateFun);
    this
  }

  fun writeArray(
    context: mutable Context,
    baseName: String,
    values: Array<Value>,
  ): void {
    key = BaseName::create(baseName);
    !this = context.state.dirs.get(DirRef<Value>(this.dirName));
    source = Source(Path::create(this.dirName, key), this.dirName);
    !this = this.writeEntry(context, source, key, values);
    context.setDir(DirRef<Value>(this.dirName), this);
  }

  fun write(context: mutable Context, baseName: String, value: Value): void {
    this.writeArray(context, baseName, Array[value]);
  }

  fun remove(context: mutable Context, baseName: String): void {
    this.writeArray(context, baseName, Array[]);
  }
}

module end;
