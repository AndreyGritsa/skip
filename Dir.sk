module SKFS;

fun reduceCapacity<T>(capacity: Int, prevList: List<T>): List<T> {
  if (capacity == 0) return List.Nil();
  prevList match {
  | nil @ List.Nil() -> nil
  | List.Cons(x, rl) -> List.Cons(x, reduceCapacity(capacity - 1, rl))
  }
}

type MapFun = (mutable Context, mutable Writer, BaseName, Array<File>) ~> void;

class FileNotFound(path: Path) extends SKFS.Exception {
  fun toString(): String {
    `File not found: ${this.path}`
  }
}
class DuplicateFiles(path: Path) extends SKFS.Exception {
  fun toString(): String {
    `Duplicate values found for path: ${this.path}`
  }
}

value class FixedRow<T>(
  key: BaseName,
  value: (Path, T),
) uses Hashable, Orderable {
  fun toKeyPath(): (BaseName, Path) {
    (this.key, this.value.i0);
  }

  fun compare(row: FixedRow<T>): Order {
    this.toKeyPath().compare(row.toKeyPath())
  }

  fun hash(): Int {
    this.toKeyPath().hash()
  }
}

value class RowMapped<T>(
  key: BaseName,
  reads: Vector<Path>,
  values: Array<FixedRow<T>>,
  newDirs: SortedSet<DirName>,
)

value class GroupedRows<T>(
  rows: Array<FixedRow<T>>,
  old: Array<FixedRow<BaseName>>,
  newDirs: SortedMap<BaseName, SortedSet<DirName>>,
)

class FixedData<T>{dirName: DirName, data: Array<FixedRow<T>> = Array[]} {
  static fun empty(dirName: DirName): this {
    FixedData{dirName, data => Array[]}
  }

  fun getPos(key: BaseName, i: Int, j: Int): Int {
    if (i > j) {
      return i;
    };
    pivot = (i + j) / 2;
    key.compare(this.data[pivot].key) match {
    | LT()
    | EQ() ->
      this.getPos(key, i, pivot - 1)
    | GT() -> this.getPos(key, pivot + 1, j)
    }
  }

  fun getArray(key: BaseName): Array<(Path, T)> {
    pos = this.getPos(key, 0, this.data.size() - 1);
    result = mutable Vector[];
    while (pos < this.data.size() && this.data[pos].key == key) {
      result.push(this.data[pos].value);
      !pos = pos + 1;
    };
    result.toArray();
  }

  fun maybeGet(key: BaseName): ?(Path, T) {
    arr = this.getArray(key);
    if (arr.size() > 2) {
      path = Path(this.dirName, key);
      throw (DuplicateFiles(path))
    };
    if (arr.size() == 0) {
      return None();
    };
    Some(arr[0])
  }

  fun get(key: BaseName): (Path, T) {
    this.maybeGet(key) match {
    | None() ->
      path = Path(this.dirName, key);
      throw (FileNotFound(path))
    | Some(x) -> x
    }
  }
}

base class PlaceHolder {
  children =
  | PHEmpty()
  | PHProcessing()
  | PHDone(File)
}

class Dir{
  creationTime: Int,
  time: Int,
  tick: Int,
  dirName: DirName,
  isInput: Bool,
  fixedData: FixedData<Array<File>>,
  parent: ?(Int, DirName) = None(),
  fixedOld: SortedMap<DirName, FixedData<BaseName>> = SortedMap[],
  data: DMap<BaseName, SortedMap<Path, Array<File>>> = Nil(),
  old: SortedMap<DirName, SortedMap<BaseName, Array<BaseName>>> = SortedMap[],
  newDirs: SortedMap<BaseName, SortedSet<DirName>> = SortedMap[],
  childDirs: SortedMap<Int, DirName> = SortedMap[],
  dirty: SortedSet<BaseName> = SortedSet[],
  dirtyReaders: SortedMap<DirName, SortedSet<BaseName>> = SortedMap[],
  mapFun: ?MapFun = None(),
  lazyFun: ?((mutable Context, DirName, BaseName) ~> File) = None(),
} extends File {
  fun files(): Set<BaseName> {
    fixedData = this.fixedData.data;
    current = 0;
    keys = mutable Set[];
    for (newKey => newValues in this.data) {
      while (current < fixedData.size() && fixedData[current].key < newKey) {
        row = fixedData[current];
        if (row.value.i1.size() > 0) {
          keys.insert(row.key);
        };
        !current = current + 1;
      };
      if (newValues.size() > 0) {
        keys.insert(newKey);
      };
      !current = current + 1;
    };
    while (current < fixedData.size()) {
      row = fixedData[current];
      if (row.value.i1.size() > 0) {
        keys.insert(row.key);
      };
      !current = current + 1;
    };
    keys.chill()
  }

  static fun lazy(
    context: mutable Context,
    dirName: DirName,
    f: (mutable Context, DirName, BaseName) ~> File,
  ): Dir {
    time = context.timeStamp();
    updateReaders = (
      dirName: DirName,
      context: mutable Context,
      key: BaseName,
    ) ~> {
      reads = context.getReads();

      for (read in reads) {
        readSet = context.newDeps.maybeGet(read) match {
        | None() -> SortedSet[]
        | Some(x) -> x
        };
        !readSet = readSet.set((dirName, dirName, key));
        context.!newDeps[read] = readSet;
      };
    };
    lazyFun = (context: mutable Context, dirName: DirName, key: BaseName) ~> {
      reads = context.reads;
      context.!reads = mutable Vector[];

      context.!newDirs = SortedSet[];
      result = vtry<File>(
        () -> {
          f(context, dirName, key)
        },
        e ->
          ErrorFile(
            List[
              ErrorTrace(dirName.toString(), key.toString(), e.getMessage()),
            ],
          )
        ,
      );
      dir = context.getDir(dirName);
      results = Array[result];
      map = SortedMap[Path(dirName, key) => results];
      !dir.data = dir.data.set(context.tick, key, map);
      updateReaders(dirName, context, key);
      context.setDir(dirName, dir);
      if (context.debugMode) {
        name = "" + dir.dirName + key;
        print_string(`WRITTEN LAZY:  ${name} => ${inspect(result)}`);
      };
      context.!reads = reads;
      result
    };
    context.!newDirs = context.newDirs.add(dirName);
    newDir = Dir{
      creationTime => time,
      time,
      tick => context.tick,
      dirName,
      isInput => false,
      fixedData => FixedData{dirName, data => Array[]},
      lazyFun => Some(lazyFun),
    };
    context.setDir(dirName, newDir);
    newDir
  }

  fun getDirName(): DirName {
    this.dirName
  }

  fun getOld(dirName: DirName, key: BaseName): Array<BaseName> {
    if (this.old.containsKey(dirName) && this.old[dirName].containsKey(key)) {
      this.old[dirName][key]
    } else {
      this.fixedOld[dirName].getArray(key).map(x -> x.i1)
    }
  }

  fun getArrayRaw(key: BaseName): Array<File> {
    fixed = this.fixedData.getArray(key);
    this.data.maybeGet(key) match {
    | None() -> fixed.map(x -> x.i1).flatten()
    | Some(modified) ->
      result = mutable Vector<(Path, Array<File>)>[];
      current = 0;
      for (path => values in modified) {
        while (current < fixed.size() && fixed[current].i0 < path) {
          result.push(fixed[current]);
          !current = current + 1;
        };
        while (current < fixed.size() && fixed[current].i0 == path) {
          !current = current + 1;
        };
        result.push((path, values));
      };
      while (current < fixed.size()) {
        result.push(fixed[current]);
        !current = current + 1;
      };
      result.map(x -> x.i1).flatten().toArray()
    }
  }

  fun callLazy(
    context: mutable Context,
    f: (mutable Context, DirName, BaseName) ~> File,
    key: BaseName,
  ): Array<File> {
    newDirsCopy = context.newDirs;
    context.!newDirs = SortedSet[];
    value = f(context, this.dirName, key);
    newDirs = context.newDirs;
    context.!newDirs = newDirsCopy.union(newDirs);
    !this = context.getDir(this.dirName);
    !this = this.updateNewDirs(context, key, newDirs);
    context.setDir(this.dirName, this);
    Array[value]
  }

  fun getArray(context: mutable Context, key: BaseName): Array<File> {
    path = Path(this.dirName, key);
    context.addDep(path);
    values = this.getArrayRaw(key);
    if (values.size() != 0) return values;
    this.lazyFun match {
    | None() -> values
    | Some(f) -> this.callLazy(context, f, key)
    }
  }

  fun mapRow(
    context: mutable Context,
    key: BaseName,
    values: Array<File>,
    f: MapFun,
  ): RowMapped<Array<File>> {
    if (values.size() == 0) {
      return RowMapped(key, Vector[], Array[], SortedSet[]);
    };
    writer = mutable Writer{};
    newDirsCopy = context.newDirs;
    context.!newDirs = SortedSet[];
    f(context, writer, key, values);
    newDirs = context.newDirs;
    context.!newDirs = newDirsCopy;
    kvArray = writer.getWrites();
    reads = context.getReads();
    rows = kvArray.map(kv2 -> {
      (k2, v2) = kv2;
      path = Path(this.dirName, key);
      FixedRow(k2, (path, v2))
    });
    RowMapped(key, reads, rows, newDirs)
  }

  fun regroupMap<File2>(mapped: Vector<RowMapped<File2>>): GroupedRows<File2> {
    rowVec = mutable Vector[];
    oldVec = mutable Vector[];
    newDirs = SortedMap[];
    for (rowMapped in mapped) {
      key = rowMapped.key;
      rows = rowMapped.values;
      for (row in rows) {
        oldVec.push(FixedRow(key, (Path(this.dirName, key), row.key)));
        rowVec.push(row);
      };
      !newDirs = newDirs.set(key, rowMapped.newDirs);
    };
    rowVec.sort();
    oldVec.sort();
    GroupedRows(rowVec.toArray(), oldVec.toArray(), newDirs)
  }

  fun updateReaders(
    context: mutable Context,
    dirName: DirName,
    mapped: readonly Vector<RowMapped<Array<File>>>,
  ): void {
    readDirs = mutable Map[];
    deps = mutable Vector[];
    for (row in mapped) {
      for (read in row.reads) {
        if (!readDirs.containsKey(read.dirName)) {
          readDirs![read.dirName] = mutable Vector[];
        };
        readDirs[read.dirName].push((read.baseName, row.key));
      }
    };
    for (readDirName => reads in readDirs) {
      reads.sort();
      uniqReads = reads.unique();
      for (row in uniqReads) {
        readerKey = row.i0;
        readKey = row.i1;
        readerPath = Path(readDirName, readerKey);
        deps.push((readerPath, this.dirName, dirName, readKey));
      };
    };
    context.!deps = List.Cons(deps.toArray(), context.deps);
  }

  fun mapData<File2: File>(
    context: mutable Context,
    f: MapFun,
  ): Vector<RowMapped<Array<File>>> {
    current = 0;
    mapped = mutable Vector[];
    addFixed = () -> {
      key = this.fixedData.data[current].key;
      valueAcc = mutable Vector<(Path, Array<File>)>[];
      while (
        current < this.fixedData.data.size() &&
        this.fixedData.data[current].key == key
      ) {
        valueAcc.push(this.fixedData.data[current].value);
        !current = current + 1;
      };
      fixedFiles = valueAcc.map(x -> x.i1).flatten().toArray();
      mapped.push(this.mapRow(context, key, fixedFiles, f));
    };
    for (key => _ in this.data) {
      while (
        current < this.fixedData.data.size() &&
        this.fixedData.data[current].key < key
      ) {
        addFixed();
      };
      while (
        current < this.fixedData.data.size() &&
        this.fixedData.data[current].key == key
      ) {
        !current = current + 1;
      };
      mapped.push(this.mapRow(context, key, this.getArrayRaw(key), f));
    };
    while (current < this.fixedData.data.size()) {
      addFixed();
    };
    mapped.chill()
  }

  fun apply(context: mutable Context, dirName: DirName, f: MapFun): void {
    if (this.lazyFun is Some _) {
      error(`Cannot apply over a lazy directory ${this.dirName}`);
    };
    context.maybeGetDir(dirName) match {
    | Some(dir) if (dir.tick == context.tick) ->
      error(
        `Error: directory ${dirName.toString()} already exists (parent: ${
          this.dirName
        })`,
      )
    | Some(dir) ->
      if (
        dir.parent is Some _ &&
        dir.parent.fromSome() == (this.creationTime, this.dirName) &&
        inspect(dir.mapFun.fromSome()) == inspect(f)
      ) {
        if (context.debugMode) {
          print_string(`REUSING: ${dir.dirName}`);
        };
        context.!newDirs = context.newDirs.add(dir.dirName);
        !dir.time = context.timeStamp();
        this.update(context, dir.dirName);
        return void;
      }
    | _ -> void
    };
    time = context.timeStamp();
    context.!newDirs = context.newDirs.add(dirName);
    mapped = this.mapData(context, f);
    grouped = this.regroupMap(mapped);
    this.updateReaders(context, dirName, mapped);
    fixedData = FixedData{dirName, data => grouped.rows};
    dir = Dir{
      creationTime => time,
      time,
      tick => context.tick,
      dirName,
      isInput => false,
      parent => Some((this.creationTime, this.dirName)),
      fixedData,
      mapFun => Some(f),
      newDirs => grouped.newDirs,
    };
    context.setDir(dirName, dir);
    parent = context.getDir(this.dirName);
    !parent.fixedOld[dirName] = FixedData{dirName, data => grouped.old};
    !parent.childDirs = parent.childDirs.add(time, dirName);
    context.setDir(parent.dirName, parent);
    if (context.debugMode) {
      print_string(
        `CREATED:  ${dirName.toString()} (time: ${time}, parent: ${
          this.dirName
        })`,
      );
    };
  }

  fun updateLazy(context: mutable Context): void {
    if (!context.dirs.state.containsKey(this.dirName)) {
      return void;
    };

    if (this.dirty.isEmpty() && this.dirtyReaders.isEmpty()) return void;

    thisDirtyReaders = SortedSet[];
    for (dirtyReaderDirName => dirtyReaderBaseNames in this.dirtyReaders) {
      for (dirtyReaderBaseName in dirtyReaderBaseNames) {
        !thisDirtyReaders = thisDirtyReaders.add(
          Path(dirtyReaderDirName, dirtyReaderBaseName),
        );
      }
    };
    dirtyReaders = fixPoint(
      thisDirtyReaders.union(this.dirty.map(x -> Path(this.dirName, x))),
      key -> {
        context
          .getDeps(key)
          .filter(x -> x.i1 == this.dirName)
          .map(x -> Path(x.i1, x.i2))
          .collect(Set);
      },
    );
    for (path in dirtyReaders) {
      key = path.baseName;
      map = SortedMap[path => Array[]];
      !this.data = this.data.set(context.tick, key, map);
    };
    context.setDir(this.dirName, this);
    !this = context.getDir(this.dirName);
    for (path in dirtyReaders) {
      this.updateDirtyReaders(context, path);
    }
  }

  fun update(context: mutable Context, childName: DirName): void {
    // We have been removed from the set of directories.
    // This can happen when an old dependency changed.
    // Because of the change, the directory gets added
    // to the list of directories to update. But in the mean time
    // the source no longer creates this directory.
    if (!context.dirs.state.containsKey(this.dirName)) {
      return void;
    };

    if (this.dirty.isEmpty() && this.dirtyReaders.isEmpty()) return void;

    child = context.dirs.get(childName);
    dirty = mutable Set[];
    if (this.dirtyReaders.containsKey(childName)) {
      for (elt in this.dirtyReaders[childName]) {
        dirty.add(elt)
      }
    };
    for (key in this.dirty) {
      dirty.insert(key);
    };
    for (key in dirty) {
      values = this.getArrayRaw(key);
      source = Path(this.dirName, key);
      oldKeys = Set::mcreateFromItems(this.getOld(childName, key));
      mapFun = child.mapFun match {
      | None() -> continue
      | Some(f) -> f
      };
      (!child, newKeys) = child.updateChildForKey(
        mapFun,
        context,
        oldKeys,
        source,
        key,
        values,
      );
      // We need to remember what keys we produced for the next
      // time around.
      oldKeysMap = this.old.maybeGet(child.dirName) match {
      | None() -> SortedMap[]
      | Some(x) -> x
      };
      !oldKeysMap[key] = newKeys;
      !this.old[child.dirName] = oldKeysMap;
    };
    context.setDir(child.dirName, child);
    context.setDir(
      this.dirName,
      context.getDir(this.dirName) with {old => this.old},
    );
  }

  private fun updateNewDirs(
    context: mutable Context,
    key: BaseName,
    newDirs: SortedSet<DirName>,
  ): this {
    this.newDirs.maybeGet(key) match {
    | None() -> if (newDirs.isEmpty()) return this
    | Some(lastRoundDirs) ->
      for (dirName in lastRoundDirs) {
        if (newDirs.contains(dirName)) continue;
        context.removeDir(dirName);
      }
    };
    !this.newDirs = this.newDirs.set(key, newDirs);
    this
  }

  private fun updateChildForKey<T: File>(
    mapFun: MapFun,
    context: mutable Context,
    oldKeys: mutable Set<BaseName>,
    source: Path,
    key: BaseName,
    values: Array<T>,
  ): (this, Array<BaseName>) {
    writer = mutable Writer{};
    newDirsCopy = context.newDirs;
    context.!newDirs = SortedSet[];

    if (values.size() != 0) {
      mapFun(context, writer, key, values);
    };

    newDirs = context.newDirs;
    context.!newDirs = newDirsCopy;

    !this = this.updateNewDirs(context, key, newDirs);

    mapped = writer.getWrites();
    reads = context.getReads();

    for (read in reads) {
      readSet = context.newDeps.maybeGet(read) match {
      | None() -> SortedSet[]
      | Some(x) -> x
      };
      !readSet = readSet.set((source.dirName, this.dirName, key));
      context.!newDeps[read] = readSet;
    };

    keys = mutable Vector[];

    for (kv in mapped) {
      (k, rvalues) = kv;

      keys.push(k);
      if (oldKeys.contains(k)) {
        oldKeys.remove(k);
      };
      !this = this.writeEntry(context, source, k, rvalues);
    };

    // Let's remove the keys that no longer exist.
    for (k in oldKeys) {
      !this = this.writeEntry(context, source, k, Array[]);
    };

    (this, keys.toArray())
  }

  fun updateDirtyReaders(context: mutable Context, path: Path): void {
    invariant(path.dirName == this.dirName);
    readers = context.getDeps(path);

    for (reader in readers) {
      (dirName, childName, baseName) = reader;
      dir = context.getDir(dirName);
      child = context.getDir(childName);

      if (child.time <= this.time) {
        if (context.debugMode) {
          print_string(`SKIPPING: ${path} ${child.dirName}`);
        };
        continue;
      };
      if (!dir.dirtyReaders.containsKey(childName)) {
        !dir.dirtyReaders[childName] = SortedSet[];
      };
      !dir.dirtyReaders[childName] = dir.dirtyReaders[childName].set(baseName);
      if (
        dir.lazyFun is Some _ &&
        childName == dir.dirName &&
        childName != this.dirName
      ) {
        !dir.data = dir.data.set(
          context.tick,
          baseName,
          SortedMap[(Path(childName, baseName), Array[])],
        );
      };
      context.setDir(dirName, dir);
      context.!toUpdate = context.toUpdate.set(child.time, childName);
    };
  }

  fun writeEntry(
    context: mutable Context,
    source: Path,
    k: BaseName,
    rvalues: Array<File>,
  ): this {
    map = this.data.maybeGet(k) match {
    | None() -> SortedMap[]
    | Some(x) -> x
    };
    irvalues = rvalues.map(x -> x);
    !map = map.set(source, irvalues);
    data = this.data.set(context.tick, k, map);
    dirty = this.dirty.set(k);
    path = Path(this.dirName, k);
    !this = this with {data, dirty};
    context.setDir(this.dirName, this);

    this.updateDirtyReaders(context, path);

    for (childName in this.childDirs) {
      child = context.getDir(childName);
      context.!toUpdate = context.toUpdate.set(child.time, childName);
    };
    if (context.debugMode) {
      name = "" + this.dirName + k;
      print_string(`WRITTEN:  ${name} => ${inspect(rvalues)} (${source})`);
    };

    context.getDir(this.dirName);
  }

  fun writeArray(
    context: mutable Context,
    baseName: String,
    values: Array<File>,
  ): void {
    key = BaseName::create(baseName);
    source = Path(this.dirName, key);
    !this = this.writeEntry(context, source, key, values);
    context.!toReset = context.toReset.set(this.dirName);
    context.setDir(this.dirName, this);
  }

  fun write(context: mutable Context, baseName: String, value: File): void {
    this.writeArray(context, baseName, Array[value]);
  }

  fun remove(context: mutable Context, baseName: String): void {
    this.writeArray(context, baseName, Array[]);
  }

  fun isEmpty(): Bool {
    this.data is Nil _ && this.fixedData.data.size() == 0
  }
}

module end;
