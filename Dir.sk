module SKFS;

@cpp_extern("SKIP_unsafe")
private native fun unsafeFromFile<T>(File): T;

@cpp_extern("SKIP_unsafe")
private native fun unsafeToFile<T>(T): File;

value class Source(
  origKey: Path,
  targetDir: DirName,
) uses Hashable, Orderable, Show {
  fun toString(): String {
    "Source(" + this.origKey + ", " + this.targetDir + ")"
  }
}

type MapFun<Value, Value2> = (
  mutable Handle<Value2>,
  BaseName,
  Array<Value>,
) ~> void;

class FileNotFound(path: Path) extends SKFS.Exception {
  fun toString(): String {
    `File not found: ${this.path}`
  }
}
class DuplicateValues(path: Path) extends SKFS.Exception {
  fun toString(): String {
    `Duplicate values found for path: ${this.path}`
  }
}

value class FixedRow<T: Hashable & Orderable>(
  key: BaseName,
  value: T,
) uses Hashable, Orderable

value class RowMapped<T>(
  key: BaseName,
  reads: Vector<Path>,
  values: Array<FixedRow<T>>,
  error: ?String,
)

value class GroupedRows<T>(
  rows: Array<FixedRow<T>>,
  old: Array<FixedRow<BaseName>>,
  errors: SortedMap<BaseName, Array<MapError>>,
)

class FixedData<T>{dirName: DirName, data: Array<FixedRow<T>> = Array[]} {
  fun getPos(key: BaseName, i: Int, j: Int): Int {
    if (i > j) {
      return i;
    };
    pivot = (i + j) / 2;
    key.compare(this.data[pivot].key) match {
    | LT()
    | EQ() ->
      this.getPos(key, i, pivot - 1)
    | GT() -> this.getPos(key, pivot + 1, j)
    }
  }

  fun getArray(key: BaseName): Array<T> {
    pos = this.getPos(key, 0, this.data.size() - 1);
    result = mutable Vector[];
    while (pos < this.data.size() && this.data[pos].key == key) {
      result.push(this.data[pos].value);
      !pos = pos + 1;
    };
    result.toArray();
  }

  fun maybeGet(key: BaseName): ?T {
    arr = this.getArray(key);
    if (arr.size() > 2) {
      path = Path(this.dirName, key);
      throw (DuplicateValues(path))
    };
    if (arr.size() == 0) {
      return None();
    };
    Some(arr[0])
  }

  fun get(key: BaseName): T {
    this.maybeGet(key) match {
    | None() ->
      path = Path(this.dirName, key);
      throw (FileNotFound(path))
    | Some(x) -> x
    }
  }
}

class MapError{msg: String} extends File {
  fun toString(): String {
    "Error: " + this.msg
  }
}

trait HasKey {
  fun getKey(): BaseName;
}

class Partition<Value>{
  baseDirName: String,
  dirs: SortedMap<DirName, Dir<Value>>,
  getKey: Value ~> BaseName,
} {
  static fun dirName(baseDirName: String, key: BaseName): DirName {
    DirName::create(baseDirName + key.toString() + "/");
  }
}

class Dir<Value: File>{
  time: Int,
  dirName: DirName,
  fixedData: FixedData<(Path, Array<Value>)>,
  fixedOld: SortedMap<DirName, FixedData<BaseName>> = SortedMap[],
  data: SortedMap<BaseName, SortedMap<Path, Array<File>>> = SortedMap[],
  errors: SortedMap<BaseName, Array<MapError>> = SortedMap[],
  old: SortedMap<DirName, SortedMap<BaseName, Array<BaseName>>> = SortedMap[],
  childDirs: List<DirName> = List[],
  dirty: SortedSet<BaseName> = SortedSet[],
  dirtyReaders: SortedSet<(DirName, BaseName)> = SortedSet[],
  partitionOpt: ?Partition<Value> = None(),
} {
  private fun compactData(): FixedData<(Path, Array<Value>)> {
    fixedData = this.fixedData.data;
    current = 0;
    newData = mutable Vector[];
    for (newKey => values in this.data) {
      while (current < fixedData.size() && fixedData[current].key < newKey) {
        newData.push(fixedData[current]);
      };
      for (path => array in values) {
        valueArray = array.map(x -> unsafeFromFile(x));
        newData.push(FixedRow(fixedData[current].key, (path, valueArray)));
      };
      !current = current + 1;
    };
    while (current < fixedData.size()) {
      newData.push(fixedData[current]);
      !current = current + 1;
    };
    this.fixedData with {data => newData.toArray()}
  }

  private fun compactOld(): SortedMap<DirName, FixedData<BaseName>> {
    fixedOld = this.fixedOld;
    !fixedOld = fixedOld.map((dirName, fixed) -> {
      if (!this.old.containsKey(dirName)) {
        return fixed;
      };
      fixedData = fixed.data;
      old = this.old[dirName];
      current = 0;
      newOld = mutable Vector[];
      for (newKey => values in old) {
        while (current < fixedData.size() && fixedData[current].key < newKey) {
          newOld.push(fixedData[current]);
        };
        for (value in values) {
          newOld.push(FixedRow(fixedData[current].key, value));
        };
        !current = current + 1;
      };
      while (current < fixedData.size()) {
        newOld.push(fixedData[current]);
        !current = current + 1;
      };
      fixed with {data => newOld.toArray()}
    });
    for (dirName => map in this.old) {
      if (fixedOld.containsKey(dirName)) {
        continue;
      };
      newOld = mutable Vector[];
      for (baseName => values in map) {
        for (value in values) {
          newOld.push(FixedRow(baseName, value));
        }
      };
      !fixedOld = fixedOld.add(
        dirName,
        FixedData{dirName, data => newOld.toArray()},
      );
    };
    fixedOld
  }

  fun compact(): this {
    invariant(this.dirty.isEmpty());
    invariant(this.dirtyReaders.isEmpty());
    fixedOld = this.compactOld();
    fixedData = this.compactData();
    this with {fixedOld, fixedData, old => SortedMap[], data => SortedMap[]}
  }

  fun getDirName(): DirName {
    this.dirName
  }

  fun getThis(state: State): this {
    !this = if (state.dirs.state.containsKey(this.dirName)) {
      state.dirs[DirRef<Value>(this.dirName)];
    } else {
      this
    };
    this
  }

  fun getOld(dirName: DirName, key: BaseName): Array<BaseName> {
    if (this.old.containsKey(dirName) && this.old[dirName].containsKey(key)) {
      this.old[dirName][key]
    } else {
      this.fixedOld[dirName].getArray(key)
    }
  }

  fun getArrayRaw(key: BaseName): Array<Value> {
    fixed = this.fixedData.getArray(key);
    this.data.maybeGet(key) match {
    | None() -> fixed.map(x -> x.i1).flatten()
    | Some(modified) ->
      result = mutable Vector<(Path, Array<Value>)>[];
      current = 0;
      for (path => values in modified) {
        while (current < fixed.size() && fixed[current].i0 < path) {
          result.push(fixed[current]);
          !current = current + 1;
        };
        while (current < fixed.size() && fixed[current].i0 == path) {
          !current = current + 1;
        };
        result.push((path, values.map(x -> unsafeFromFile(x))));
      };
      while (current < fixed.size()) {
        result.push(fixed[current]);
        !current = current + 1;
      };
      result.map(x -> x.i1).flatten().toArray()
    }
  }

  fun getArray<T>(handle: mutable Handle<T>, key: BaseName): Array<Value> {
    !this = this.getThis(handle.state);
    path = Path(this.dirName, key);
    handle.addDep(path);
    this.getArrayRaw(key)
  }

  fun mapRow<Value2: File>(
    key: BaseName,
    values: Array<Value>,
    f: MapFun<Value, Value2>,
  ): RowMapped<(Path, Array<Value2>)> {
    handle = mutable Handle{};
    error = try {
      f(handle, key, values);
      None()
    } catch {
    | e -> Some(e.getMessage())
    };
    (kvArray, reads) = freeze(handle).getModifs();
    rows = kvArray.map(kv2 -> {
      (k2, v2) = kv2;
      path = Path(this.dirName, key);
      FixedRow(k2, (path, v2))
    });
    RowMapped(key, reads, rows, error)
  }

  fun regroupMap<Value2>(
    mapped: Vector<RowMapped<Value2>>,
  ): GroupedRows<Value2> {
    rowVec = mutable Vector[];
    oldVec = mutable Vector[];
    errors = SortedMap[];
    for (rowMapped in mapped) {
      key = rowMapped.key;
      rows = rowMapped.values;
      for (row in rows) {
        oldVec.push(FixedRow(key, row.key));
        rowVec.push(row);
      };
      rowMapped.error match {
      | None() -> void
      | Some(msg) -> !errors = errors.set(key, Array[MapError{msg}])
      }
    };
    rowVec.sort();
    oldVec.sort();
    GroupedRows(rowVec.toArray(), oldVec.toArray(), errors)
  }

  fun updateReaders<Value2>(
    context: mutable Context,
    dirName: DirName,
    mapped: readonly Vector<RowMapped<Value2>>,
  ): void {
    readDirs = mutable Map[];
    deps = mutable Vector[];
    for (row in mapped) {
      for (read in row.reads) {
        if (!readDirs.containsKey(read.dirName)) {
          readDirs![read.dirName] = mutable Vector[];
        };
        readDirs[read.dirName].push(FixedRow(read.baseName, row.key));
      }
    };
    for (readDirName => reads in readDirs) {
      reads.sort();
      uniqReads = reads.unique();
      for (row in uniqReads) {
        readerKey = row.key;
        readKey = row.value;
        readerPath = Path(readDirName, readerKey);
        deps.push((readerPath, this.dirName, dirName, readKey));
      };
    };
    context.!deps = List.Cons(freeze(deps), context.deps);
  }

  fun mapData<Value2: File>(
    context: mutable Context,
    f: MapFun<Value, Value2>,
  ): Vector<RowMapped<(SKFS.Path, Array<Value2>)>> {
    !this = this.getThis(context.state);
    current = 0;
    mapped = mutable Vector[];
    addFixed = (fixedRow: FixedRow<(SKFS.Path, Array<Value>)>) -> {
      key = fixedRow.key;
      valueAcc = mutable Vector<(Path, Array<Value>)>[];
      while (
        current < this.fixedData.data.size() &&
        this.fixedData.data[current].key == key
      ) {
        valueAcc.push(fixedRow.value);
        !current = current + 1;
      };
      fixedValues = valueAcc.map(x -> x.i1).flatten().toArray();
      mapped.push(this.mapRow(key, fixedValues, f));
    };
    for (key => _ in this.data) {
      while (
        current < this.fixedData.data.size() &&
        this.fixedData.data[current].key < key
      ) {
        addFixed(this.fixedData.data[current]);
      };
      while (
        current < this.fixedData.data.size() &&
        this.fixedData.data[current].key == key
      ) {
        !current = current + 1;
      };
      mapped.push(this.mapRow(key, this.getArrayRaw(key), f));
    };
    while (current < this.fixedData.data.size()) {
      addFixed(this.fixedData.data[current]);
    };
    freeze(mapped)
  }

  fun multiMap<Value2: File>(
    context: mutable Context,
    dirNameStr: String,
    f: MapFun<Value, Value2>,
    extraDirs: Array<Dir<Value>> = Array[],
  ): Dir<Value2> {
    dirName = DirName::create(dirNameStr);
    dirs = mutable Vector[this];
    mappedAcc = mutable Vector[this.mapData(context, f)];
    extraDirs.each(dir -> {
      dirs.push(dir);
      mappedAcc.push(dir.mapData(context, f))
    });
    mapped = mappedAcc.flatten();
    grouped = this.regroupMap(mapped);
    this.updateReaders(context, dirName, mapped);
    time = context.timeStamp();
    fixedData = FixedData{dirName, data => grouped.rows};
    errors = grouped.errors;
    dir = Dir{time, dirName, fixedData, errors};
    context.setDir(DirRef<Value2>(dirName), dir);
    context.setFun(FunRef<File, Value2>(dirName), (context, key, values) ~>
      f(context, key, values.map(unsafeFromFile))
    );
    for (parent in dirs) {
      !parent.fixedOld[dirName] = FixedData{dirName, data => grouped.old};
      !parent.childDirs = List.Cons(dirName, parent.childDirs);
      context.setDir(DirRef<Value>(parent.dirName), parent);
    };
    dir
  }

  fun update(context: mutable Context): void {
    if (context.debugMode) {
      print_string(`Updating Directory: ${this.dirName} at time ${this.time}`);
    };
    invariant(context.toUpdate.containsKey(this.time));

    // Remove ourselves from the list of directories to process.
    context.!toUpdate = context.toUpdate.remove(this.time);

    // We have been removed from the set of directories.
    // This can happen when an old dependency changed.
    // Because of the change, the directory gets added
    // to the list of directories to update. But in the mean time
    // the source no longer creates this directory.
    if (!context.state.dirs.state.containsKey(this.dirName)) {
      return void;
    };

    // We need to get the most up to date version of ourselves.
    // So "this" might be outdated ...
    !this = context.state.dirs.get(DirRef<Value>(this.dirName));

    // Update the partition
    this.partitionOpt match {
    | None() -> void
    | Some(partition) ->
      for (key in this.dirty) {
        dirName = Partition::dirName(partition.baseDirName, key);
        source = Path(this.dirName, key);
        values = this.getArrayRaw(key);
        mdata = mutable Map[];
        for (value in values) {
          subKey = partition.getKey(value);
          if (!mdata.containsKey(subKey)) {
            mdata![subKey] = mutable Vector[];
          };
          mdata[subKey].push(value);
        };
        for (subKey => valueVec in mdata) {
          dir = context.maybeGetDir(DirRef<Value>(dirName)) match {
          | None() ->
            time = context.timeStamp();
            fixedData = FixedData{dirName, data => Array[]};
            errors = SortedMap[];
            Dir{time, dirName, fixedData, errors}
          | Some(x) -> x
          };
          !dir = dir.writeEntry(context, source, subKey, valueVec.toArray());
          context.setDir(DirRef<Value>(dirName), dir);
        }
      }
    };

    dirtyDeps = mutable Map[];
    for (reader in this.dirtyReaders) {
      (dirName, baseName) = reader;
      if (!dirtyDeps.containsKey(dirName)) {
        dirtyDeps![dirName] = mutable Set[];
      };
      dirtyDeps[dirName].insert(baseName);
    };

    for (childName in this.childDirs) {
      child = context.state.dirs.get(DirRef<File>(childName));
      dirty = if (dirtyDeps.containsKey(childName)) {
        dirtyDeps[childName]
      } else {
        mutable Set[]
      };
      for (key in this.dirty) {
        dirty.insert(key);
      };
      for (key in dirty) {
        values = this.getArrayRaw(key);
        source = Source(Path(this.dirName, key), child.dirName);
        oldKeys = Set::mcreateFromItems(this.getOld(childName, key));
        (!child, newKeys) = child.updateChildForKey(
          context,
          oldKeys,
          source.origKey,
          key,
          values,
        );
        // We need to remember what keys we produced for the next
        // time around.
        oldKeysMap = this.old.maybeGet(source.targetDir) match {
        | None() -> SortedMap[]
        | Some(x) -> x
        };
        !oldKeysMap[key] = newKeys;
        !this.old[source.targetDir] = oldKeysMap;
      };
      context.setDir(DirRef<File>(child.dirName), child);
    };
    !this.dirty = SortedSet[];
    !this.dirtyReaders = SortedSet[];
    context.setDir(DirRef<Value>(this.dirName), this);
  }

  fun union(
    context: mutable Context,
    name: String,
    dirs: Array<Dir<Value>>,
  ): Dir<Value> {
    this.multiMap(context, name, (h, x, y) ~> h.writeArray(x, y), dirs)
  }

  fun partition[Value: HasKey](
    context: mutable Context,
    baseDirName: String,
  ): SortedMap<DirName, Dir<Value>> {
    this.partitionOpt match {
    | Some(partition) -> return partition.dirs
    | _ -> void
    };
    !this = this.getThis(context.state);
    current = 0;
    dirs = SortedMap[];
    getFixedValues = (fixedRow: FixedRow<(SKFS.Path, Array<Value>)>) -> {
      key = fixedRow.key;
      rows = mutable Vector<FixedRow<(Path, Array<Value>)>>[];
      while (
        current < this.fixedData.data.size() &&
        this.fixedData.data[current].key == key
      ) {
        (_path, values) = fixedRow.value;
        path = Path(this.dirName, key);
        for (value in values) {
          rows.push(FixedRow(value.getKey(), (path, Array[value])));
        };
        !current = current + 1;
      };
      rows.sort();
      rows.toArray()
    };
    addDir = (
      key: BaseName,
      rows: Array<FixedRow<(SKFS.Path, Array<Value>)>>,
    ) -> {
      time = context.timeStamp();
      dirName = Partition::dirName(baseDirName, key);
      fixedData = FixedData{dirName, data => rows};
      errors = SortedMap[];
      dir = Dir{time, dirName, fixedData, errors};
      context.setDir(DirRef<Value>(dirName), dir);
      !dirs = dirs.add(dirName, dir);
    };
    for (key => values in this.data) {
      while (
        current < this.fixedData.data.size() &&
        this.fixedData.data[current].key < key
      ) {
        fixedRow = this.fixedData.data[current];
        fixedValues = getFixedValues(fixedRow);
        addDir(fixedRow.key, fixedValues);
      };
      while (
        current < this.fixedData.data.size() &&
        this.fixedData.data[current].key == key
      ) {
        !current = current + 1;
      };
      {
        rows = mutable Vector[];
        for (path => value in values) {
          rows.push(FixedRow(key, (path, value.map(x -> unsafeFromFile(x)))));
        };
        addDir(key, rows.toArray())
      }
    };
    while (current < this.fixedData.data.size()) {
      fixedRow = this.fixedData.data[current];
      fixedValues = getFixedValues(fixedRow);
      addDir(fixedRow.key, fixedValues);
    };
    getKey = (x: Value) ~> x.getKey();
    partition = Partition{baseDirName, dirs, getKey};
    !this.partitionOpt = Some(partition);
    context.setDir(DirRef<Value>(this.dirName), this);
    dirs
  }

  private fun updateChildForKey<T: File>(
    context: mutable Context,
    oldKeys: mutable Set<BaseName>,
    source: Path,
    key: BaseName,
    values: Array<T>,
  ): (this, Array<BaseName>) {
    mapFun = context.state.funs.get(FunRef<T, Value>(this.dirName));
    handle = mutable Handle{};
    mapFun(handle, key, values);
    (mapped, reads) = freeze(handle).getModifs();

    for (read in reads) {
      readSet = context.newDeps.maybeGet(read) match {
      | None() -> SortedSet[]
      | Some(x) -> x
      };
      !readSet = readSet.set((source.dirName, this.dirName, key));
      context.!newDeps[read] = readSet;
    };

    keys = mutable Vector[];

    for (kv in mapped) {
      (k, rvalues) = kv;

      keys.push(k);
      if (oldKeys.contains(k)) {
        oldKeys.remove(k);
      };
      !this = this.writeEntry(context, source, k, rvalues);
    };

    // Let's remove the keys that no longer exist.
    for (k in oldKeys) {
      !this = this.writeEntry(context, source, k, Array[]);
    };

    (this, keys.toArray())
  }

  fun writeEntry(
    context: mutable Context,
    source: Path,
    k: BaseName,
    rvalues: Array<Value>,
  ): this {
    map = this.data.maybeGet(k) match {
    | None() -> SortedMap[]
    | Some(x) -> x
    };
    irvalues = rvalues.map(x -> unsafeToFile(x));
    !map = map.set(source, irvalues);
    this.data.maybeGet(k) match {
    | Some(x) if (x == map) ->
      if (context.debugMode) {
        name = "" + this.dirName + k;
        print_string(`Attempted to write file ${name} but was unchanged`);
      };
      return this
    | _ -> void
    };
    if (context.debugMode) {
      name = "" + this.dirName + k;
      values = map.values().collect(Array).flatten();
      print_string(`Written file ${name} value was:\n${values}`);
    };
    data = this.data.set(k, map);
    dirty = this.dirty.set(k);
    path = Path(this.dirName, k);
    readers = context.getDeps(path);
    for (reader in readers) {
      (dirName, childName, baseName) = reader;
      dir = context.getDir(DirRef<Value>(dirName));
      !dir.dirtyReaders = dir.dirtyReaders.set((childName, baseName));
      newDir = dir;
      context.setDir(DirRef<Value>(dirName), newDir);
      updateFun = context ~> newDir.update(context);
      context.!toUpdate = context.toUpdate.set(dir.time, updateFun);
    };
    !this = this with {data, dirty};
    newThis = this;
    updateFun = context ~> newThis.update(context);
    context.!toUpdate = context.toUpdate.set(newThis.time, updateFun);
    this
  }

  fun writeArray(
    context: mutable Context,
    baseName: String,
    values: Array<Value>,
  ): void {
    key = SID::create(baseName);
    !this = context.state.dirs.get(DirRef<Value>(this.dirName));
    source = Path(this.dirName, key);
    !this = this.writeEntry(context, source, key, values);
    context.setDir(DirRef<Value>(this.dirName), this);
  }

  fun write(context: mutable Context, baseName: String, value: Value): void {
    this.writeArray(context, baseName, Array[value]);
  }

  fun remove(context: mutable Context, baseName: String): void {
    this.writeArray(context, baseName, Array[]);
  }
}

module end;
