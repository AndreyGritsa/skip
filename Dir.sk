module SKFS;

fun reduceCapacity<T>(capacity: Int, prevList: List<T>): List<T> {
  if (capacity == 0) return List.Nil();
  prevList match {
  | nil @ List.Nil() -> nil
  | List.Cons(x, rl) -> List.Cons(x, reduceCapacity(capacity - 1, rl))
  }
}

type MapFun = (mutable Context, mutable Writer, BaseName, Array<File>) ~> void;

class FileNotFound(path: Path) extends SKFS.Exception {
  fun toString(): String {
    `File not found: ${this.path}`
  }
}
class DuplicateFiles(path: Path) extends SKFS.Exception {
  fun toString(): String {
    `Duplicate values found for path: ${this.path}`
  }
}

value class FixedRow<T>(
  key: BaseName,
  value: (Path, T),
) uses Hashable, Orderable {
  fun toKeyPath(): (BaseName, Path) {
    (this.key, this.value.i0);
  }

  fun compare(row: FixedRow<T>): Order {
    this.toKeyPath().compare(row.toKeyPath())
  }

  fun hash(): Int {
    this.toKeyPath().hash()
  }

  fun changeSource(source: Path): this {
    !this.value.i0 = source;
    this
  }
}

value class RowMapped<T>(
  key: BaseName,
  reads: Vector<Path>,
  values: Array<FixedRow<T>>,
  newDirs: SortedSet<DirName>,
)

value class GroupedRows<T>(
  rows: Array<FixedRow<T>>,
  old: Array<FixedRow<BaseName>>,
  newDirs: SortedMap<BaseName, SortedSet<DirName>>,
)

class ProductRow(
  key1: BaseName,
  key2: BaseName,
  values: Array<File>,
) extends File

class FixedData<T>{dirName: DirName, data: Array<FixedRow<T>> = Array[]} {
  static fun empty(dirName: DirName): this {
    FixedData{dirName, data => Array[]}
  }

  fun getPos(key: BaseName, i: Int, j: Int): Int {
    if (i > j) {
      return i;
    };
    pivot = (i + j) / 2;
    key.compare(this.data[pivot].key) match {
    | LT()
    | EQ() ->
      this.getPos(key, i, pivot - 1)
    | GT() -> this.getPos(key, pivot + 1, j)
    }
  }

  fun getArray(key: BaseName): Array<(Path, T)> {
    pos = this.getPos(key, 0, this.data.size() - 1);
    result = mutable Vector[];
    while (pos < this.data.size() && this.data[pos].key == key) {
      result.push(this.data[pos].value);
      !pos = pos + 1;
    };
    result.toArray();
  }

  fun maybeGet(key: BaseName): ?(Path, T) {
    arr = this.getArray(key);
    if (arr.size() > 2) {
      path = Path(this.dirName, key);
      throw (DuplicateFiles(path))
    };
    if (arr.size() == 0) {
      return None();
    };
    Some(arr[0])
  }

  fun get(key: BaseName): (Path, T) {
    this.maybeGet(key) match {
    | None() ->
      path = Path(this.dirName, key);
      throw (FileNotFound(path))
    | Some(x) -> x
    }
  }
}

base class Dir extends File {
  fun isDeleted(): Bool;
  fun isInput(): Bool;
  fun getChildren(): Array<DirName>;
  fun getArray(context: mutable Context, key: BaseName): Array<File>;
  fun getArrayRaw(key: BaseName): Array<File>;
  fun files(): Set<BaseName>;
  fun getDirName(): DirName;
  fun getTime(): Int;
  static fun updateDirtyReaders(context: mutable Context, path: Path): void;
  fun addDirtyReader(mutable Context, DirName, BaseName): void;
}

module end;
