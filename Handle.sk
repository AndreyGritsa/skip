module SKFS;

mutable class Writer{
  private writes: mutable Map<BaseName, Array<File>> = mutable Map[],
} {
  mutable fun writeArray(key: BaseName, values: Array<File>): void {
    this.writes![key] = values;
  }

  mutable fun write(key: BaseName, value: File): void {
    this.writes![key] = Array[value];
  }

  mutable fun remove(key: BaseName): void {
    this.writes![key] = Array[];
  }

  fun getWrites(): Array<(BaseName, Array<File>)> {
    result = mutable Vector[];
    for (key => values in this.writes) {
      result.push((key, values));
    };
    result.toArray()
  }
}

class Handle<T: frozen>(conv: File ~> T, dir: Dir) {
  fun split(
    context: mutable Context,
    dirNameStr: String,
    f: T ~> BaseName,
  ): Handle<Handle<T>> {
    dir = this.dir.partition(context, dirNameStr, value ~> f(this.conv(value)));
    conv = (file: File) ~>
      file match {
      | subDir @ Dir _ -> Handle(this.conv, subDir)
      | _ -> invariant_violation("Expected a directory")
      };
    Handle(conv, dir)
  }

  fun union(
    context: mutable Context,
    dirNameStr: String,
    others: Array<Handle<T>>,
  ): Handle<T> {
    Handle(
      this.conv,
      this.dir.union(context, dirNameStr, others.map(x -> x.dir)),
    )
  }

  private fun genericMap<T2: File>(
    conv: File ~> T2,
    context: mutable Context,
    dirNameStr: String,
    f: (mutable Context, mutable Writer, BaseName, Array<T>) ~> void,
  ): Handle<T2> {
    dir = this.dir.apply(context, dirNameStr, (context, writer, key, files) ~> {
      try {
        if (files.size() == 0) return void;
        f(context, writer, key, files.map(this.conv));
      } catch {
      | ErrorFile(trace) ->
        traceElt = ErrorTrace(
          this.dir.dirName.toString(),
          key.toString(),
          "propagated",
        );
        !trace = List.Cons(traceElt, trace);
        writer.write(key, ErrorFile(trace))
      | exn ->
        traceElt = ErrorTrace(
          this.dir.dirName.toString(),
          key.toString(),
          exn.getMessage(),
        );
        trace = List.Cons(traceElt, List.Nil());
        writer.write(key, ErrorFile(trace))
      }
    });
    Handle(conv, dir)
  }

  fun duplicateError(key: BaseName, files: Array<T>): ErrorFile {
    traceElt = ErrorTrace(
      this.dir.dirName.toString(),
      key.toString(),
      "duplicate keys: " + inspect(files).toString(),
    );
    trace = List.Cons(traceElt, List.Nil());
    ErrorFile(trace)
  }

  fun map<T2: File>(
    conv: File ~> T2,
    context: mutable Context,
    dirNameStr: String,
    f: (T) ~> T2,
  ): Handle<T2> {
    this.genericMap(conv, context, dirNameStr, (_, writer, key, files) ~> {
      if (files.size() >= 2) {
        errFile = this.duplicateError(key, files);
        writer.write(key, errFile);
        return void;
      };
      result = f(files[0]);
      writer.write(key, result);
    })
  }

  fun contextMap<T2: File>(
    conv: File ~> T2,
    context: mutable Context,
    dirNameStr: String,
    f: (mutable Context, T) ~> T2,
  ): Handle<T2> {
    this.genericMap(conv, context, dirNameStr, (context, writer, key, files) ~> {
      if (files.size() >= 2) {
        errFile = this.duplicateError(key, files);
        writer.write(key, errFile);
        return void;
      };
      result = f(context, files[0]);
      writer.write(key, result);
    })
  }

  fun contextWriterMap<T2: File>(
    conv: File ~> T2,
    context: mutable Context,
    dirNameStr: String,
    f: (mutable Context, mutable Writer, T) ~> void,
  ): Handle<T2> {
    this.genericMap(conv, context, dirNameStr, (context, writer, key, files) ~> {
      if (files.size() >= 2) {
        errFile = this.duplicateError(key, files);
        writer.write(key, errFile);
        return void;
      };
      f(context, writer, files[0]);
    })
  }

  fun getArray(context: mutable Context, key: BaseName): Array<T> {
    this.dir.getArray(context, key).map(this.conv)
  }

  fun get(context: mutable Context, key: BaseName): T {
    values = this.getArray(context, key);
    if (values.size() >= 2) {
      errFile = this.duplicateError(key, values);
      throw (errFile);
    };
    values[0]
  }

  fun containsKey(context: mutable Context, key: BaseName): Bool {
    this.getArray(context, key).size() > 0
  }

  fun maybeGet(context: mutable Context, key: BaseName): ?T {
    values = this.getArray(context, key);
    if (values.size() == 0) return None();
    Some(values[0])
  }
}

module end;
