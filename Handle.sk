/*****************************************************************************/
/* Module exposing a typed interface to the file system.
 *
 * The code implementing the file system is not statically typed. A first
 * version attempted to do that, but it became clear very quickly that it
 * would require to bend the type-system in ways that were counter-productive.
 *
 * Moreover, remote-directories, because of their nature break the static
 * type-checking.
 *
 * Hence the idea of an implementation where every file in the system has the
 * same type "File" and every key the type "BaseName".
 *
 * However, type-checking is nice! So how do we get the best of both worlds?
 * By exposing a typed API!
 *
 * This is what the Handle module is for. The idea is to add a layer of type-
 * checking and expose that to the user.
 *
 * Concretely, let's say we want to manipulate a directory where the files are
 * all of type IntFile. The type Handle<IntFile> is there to the rescue! Every
 * operation will be type-checked (statically) against the type IntFile.
 *
 * So if I try to write a SringFile instead of an IntFile I get a static error.
 * The other important part is that all the higher order operations are also
 * typed. So applying a map to a Handle also produces a handle.
 *
 * What's nice about that is that it becomes relatively straightforward to
 * write a program that is fully type-checked. The dynamic nature of the file-
 * system becomes an implementation detail. All you need to do is to stick with
 * Handles. Never try to manipulate "Dir" directly and you will be safe!
 */
/*****************************************************************************/

module SKFS;

/*****************************************************************************/
/* The class handed over to the closures mapping over a directory. */
/*****************************************************************************/

mutable class Writer{
  private writes: mutable Map<BaseName, Array<File>> = mutable Map[],
} {
  mutable fun writeArray(key: BaseName, values: Array<File>): void {
    this.writes![key] = values;
  }

  mutable fun write(key: BaseName, value: File): void {
    this.writes![key] = Array[value];
  }

  mutable fun remove(key: BaseName): void {
    this.writes![key] = Array[];
  }

  readonly fun getWrites(): Array<(BaseName, Array<File>)> {
    result = mutable Vector[];
    for (key => values in this.writes) {
      result.push((key, values));
    };
    result.toArray()
  }
}

/*****************************************************************************/
/* The preferred way of accessing the file-system. */
/*****************************************************************************/

base class Handle<+T: frozen> {
  macro fun getDirName(): DirName {
    this.dirName
  }

  macro fun getConv(): SKFS.File ~> T {
    this.conv
  }

  fun getArray(context: mutable Context, key: BaseName): Array<T> {
    dir = context.unsafeGetDir(this.getDirName());
    results = dir.getArray(context, key).map(this.getConv());
    results
  }

  fun get(context: mutable Context, key: BaseName): T {
    values = this.getArray(context, key);
    if (values.size() >= 2) {
      errFile = this.duplicateError(key, values);
      throw (errFile);
    };
    if (values.size() == 0) {
      errFile = this.noValueError(key);
      throw (errFile);
    };
    values[0]
  }

  fun containsKey(context: mutable Context, key: BaseName): Bool {
    this.getArray(context, key).size() > 0
  }

  fun maybeGet(context: mutable Context, key: BaseName): ?T {
    values = this.getArray(context, key);
    if (values.size() == 0) return None();
    Some(values[0])
  }

  fun duplicateError(key: BaseName, files: Array<_>): ErrorFile {
    traceElt = ErrorTrace(
      this.getDirName().toString(),
      key.toString(),
      "duplicate keys: " + inspect(files).toString(),
    );
    trace = List.Cons(traceElt, List.Nil());
    ErrorFile(trace)
  }

  fun noValueError(key: BaseName): ErrorFile {
    traceElt = ErrorTrace(
      this.getDirName().toString(),
      key.toString(),
      "no value",
    );
    trace = List.Cons(traceElt, List.Nil());
    ErrorFile(trace)
  }
}

/*****************************************************************************/
/* A lazy handle is updated "lazily", in other words, an entry is computed
 * only when someone tries to access it.
 */
/*****************************************************************************/

class LHandle<+T: frozen>(conv: File ~> T, dirName: DirName) extends Handle<T> {
  static fun create<T: File>(
    conv: File ~> T,
    context: mutable Context,
    dirName: DirName,
    f: (mutable Context, EHandle<T>, BaseName) ~> Array<T>,
  ): LHandle<T> {
    dir = LazyDir::create(context, dirName, (context, dirName, key) ~> {
      Some(f(context, EHandle(conv, dirName), key));
    });
    LHandle(conv, dir.getDirName())
  }

  static fun createAsync<T: File>(
    conv: File ~> T,
    context: mutable Context,
    dirName: DirName,
    f: (mutable Context, EHandle<T>, BaseName) ~> ?Array<T>,
  ): LHandle<T> {
    dir = LazyDir::create(context, dirName, (context, dirName, key) ~> {
      f(context, EHandle(conv, dirName), key);
    });
    LHandle(conv, dir.getDirName())
  }

  fun getArrayAsync(context: mutable Context, key: BaseName): Array<T> {
    dir = context.unsafeGetLazyDir(this.getDirName());
    results = dir.getArrayAsync(context, key).map(this.getConv());
    results
  }
}

/*****************************************************************************/
/* Eager handles. */
/*****************************************************************************/

class EHandle<+T: frozen>(conv: File ~> T, dirName: DirName) extends Handle<T> {
  /*
    fun union<U>[T: U](
      context: mutable Context,
      dirName: DirName,
      dirs: Array<EHandle<U>>,
    ): EHandle<T> {
      thisDir = context.unsafeGetEagerDir(this.dirName);
      thisDir.apply(
        context,
        dirName,
        (_context, writer, key, files) ~> {
          if (files.size() == 0) return void;
          writer.writeArray(key, files);
        },
        dirs.map(x -> context.getEagerDir(x.dirName)),
      );
      EHandle(this.conv, dirName)
    }
  */

  fun product<T2: File, T3: File>(
    conv: File ~> T3,
    context: mutable Context,
    dirName: DirName,
    dir2: EHandle<T2>,
    f: (mutable Context, BaseName, Array<T>, BaseName, Array<T2>) ~> Array<T3>,
  ): EHandle<T3> {
    thisDir = context.unsafeGetEagerDir(this.dirName);
    thisDir.product(
      context,
      dirName,
      context.getEagerDir(dir2.dirName),
      (context, key1, files1, key2, files2) ~> {
        f(context, key1, files1.map(this.conv), key2, files2.map(dir2.conv))
      },
    );
    EHandle(conv, dirName)
  }

  private fun genericMap<T2: File>(
    conv: File ~> T2,
    context: mutable Context,
    dirName: DirName,
    f: (mutable Context, mutable Writer, BaseName, Array<T>) ~> void,
  ): EHandle<T2> {
    EagerDir::apply(
      context,
      this.dirName,
      dirName,
      (context, writer, key, files) ~> {
        context.vtry(
          () -> {
            if (files.size() == 0) return void;
            f(context, writer, key, files.map(x -> this.conv(x)));
          },
          e ->
            e match {
            | ErrorFile(trace) ->
              traceElt = ErrorTrace(
                this.dirName.toString(),
                key.toString(),
                "propagated",
              );
              !trace = List.Cons(traceElt, trace);
              writer.write(key, ErrorFile(trace))
            | exn ->
              traceElt = ErrorTrace(
                this.dirName.toString(),
                key.toString(),
                exn.getMessage(),
              );
              trace = List.Cons(traceElt, List.Nil());
              writer.write(key, ErrorFile(trace))
            }
          ,
        )
      },
    );
    EHandle(conv, dirName)
  }

  fun map<T2: File>(
    conv: File ~> T2,
    context: mutable Context,
    dirName: DirName,
    f: (T) ~> T2,
  ): EHandle<T2> {
    this.genericMap(conv, context, dirName, (_, writer, key, files) ~> {
      if (files.size() >= 2) {
        errFile = this.duplicateError(key, files);
        writer.write(key, errFile);
        return void;
      };
      result = f(files[0]);
      writer.write(key, result);
    })
  }

  fun contextMap<T2: File>(
    conv: File ~> T2,
    context: mutable Context,
    dirName: DirName,
    f: (mutable Context, T) ~> T2,
  ): EHandle<T2> {
    this.genericMap(conv, context, dirName, (context, writer, key, files) ~> {
      if (files.size() >= 2) {
        errFile = this.duplicateError(key, files);
        writer.write(key, errFile);
        return void;
      };
      result = f(context, files[0]);
      writer.write(key, result);
    })
  }

  fun contextWriterMap<T2: File>(
    conv: File ~> T2,
    context: mutable Context,
    dirName: DirName,
    f: (mutable Context, mutable Writer, T) ~> void,
  ): EHandle<T2> {
    this.genericMap(conv, context, dirName, (context, writer, key, files) ~> {
      if (files.size() >= 2) {
        errFile = this.duplicateError(key, files);
        writer.write(key, errFile);
        return void;
      };
      f(context, writer, files[0]);
    })
  }

  fun contextWriterKeyMap<T2: File>(
    conv: File ~> T2,
    context: mutable Context,
    dirName: DirName,
    f: (mutable Context, mutable Writer, BaseName, T) ~> void,
  ): EHandle<T2> {
    this.genericMap(conv, context, dirName, (context, writer, key, files) ~> {
      if (files.size() >= 2) {
        errFile = this.duplicateError(key, files);
        writer.write(key, errFile);
        return void;
      };
      f(context, writer, key, files[0]);
    })
  }

  fun contextWriterKeyValues<T2: File>(
    conv: File ~> T2,
    context: mutable Context,
    dirName: DirName,
    f: (mutable Context, mutable Writer, BaseName, Array<T>) ~> void,
  ): EHandle<T2> {
    this.genericMap(conv, context, dirName, (context, writer, key, files) ~> {
      f(context, writer, key, files);
    })
  }

  fun pre(context: mutable Context): ?EHandle<T> {
    if (!context.hasPre.contains(this.dirName)) {
      context.!hasPre = context.hasPre.add(this.dirName);
    };
    context.maybeGetDir(this.dirName.pre()) match {
    | None() -> None()
    | Some(dir) -> Some(EHandle(this.conv, dir.getDirName()))
    }
  }

  fun next(context: mutable Context): EHandle<T> {
    dirName = this.dirName.next();
    if (!context.hasNext.contains(this.dirName)) {
      fixedData = FixedData{data => Array[]};
      time = context.timeStamp();
      dir = EagerDir{time, input => true, dirName, fixedData};
      context.setDir(dirName, dir);
      return EHandle(this.conv, dirName)
    };
    EHandle(this.conv, dirName)
  }
}

module end;
