module SKFS;

mutable class Writer{
  private writes: mutable Map<BaseName, Array<File>> = mutable Map[],
} {
  mutable fun writeArray(key: BaseName, values: Array<File>): void {
    this.writes![key] = values;
  }

  mutable fun write(key: BaseName, value: File): void {
    this.writes![key] = Array[value];
  }

  mutable fun remove(key: BaseName): void {
    this.writes![key] = Array[];
  }

  readonly fun getWrites(): Array<(BaseName, Array<File>)> {
    result = mutable Vector[];
    for (key => values in this.writes) {
      result.push((key, values));
    };
    result.toArray()
  }
}

class Handle<T: frozen>(conv: File ~> T, dirName: DirName) {
  static fun lazy<T: File>(
    conv: File ~> T,
    context: mutable Context,
    dirName: DirName,
    f: (mutable Context, Handle<T>, BaseName) ~> T,
  ): Handle<T> {
    dir = Dir::lazy(context, dirName, (context, dirName, key) ~> {
      if (context.lazyVisitedSet.contains(Path(dirName, key))) {
        msg = "Error: cyclic lazy data " + " ".join(context.lazyVisitedList);
        return ErrorFile(
          List[ErrorTrace(dirName.toString(), key.toString(), msg)],
        )
      };
      oldLazyVisitedList = context.lazyVisitedList;
      oldLazyVisitedSet = context.lazyVisitedSet;
      onExit = () -> {
        context.!lazyVisitedList = oldLazyVisitedList;
        context.!lazyVisitedSet = oldLazyVisitedSet;
      };
      context.!lazyVisitedList = List.Cons(
        Path(dirName, key),
        oldLazyVisitedList,
      );
      context.!lazyVisitedSet = context.lazyVisitedSet.add(Path(dirName, key));
      context.vtry<File>(
        () -> {
          result = f(context, Handle(conv, dirName), key);
          onExit();
          result
        },
        exn -> {
          onExit();
          msg = exn.getMessage();
          trace = ErrorTrace(dirName.toString(), key.toString(), msg);
          ErrorFile(List[trace])
        },
      )
    });
    Handle(conv, dir.dirName)
  }

  fun union(
    context: mutable Context,
    dirName: DirName,
    dirs: Array<Handle<T>>,
  ): Handle<T> {
    thisDir = context.getDir(this.dirName);
    thisDir.apply(
      context,
      dirName,
      (_context, writer, key, files) ~> {
        if (files.size() == 0) return void;
        writer.writeArray(key, files);
      },
      dirs.map(x -> context.getDir(x.dirName)),
    );
    Handle(this.conv, dirName)
  }

  fun product<T2: File, T3: File>(
    conv: File ~> T3,
    context: mutable Context,
    dirName: DirName,
    dir2: Handle<T2>,
    f: (mutable Context, BaseName, Array<T>, BaseName, Array<T2>) ~> Array<T3>,
  ): Handle<T3> {
    thisDir = context.getDir(this.dirName);
    thisDir.product(
      context,
      dirName,
      context.getDir(dir2.dirName),
      (context, key1, files1, key2, files2) ~> {
        f(context, key1, files1.map(this.conv), key2, files2.map(dir2.conv))
      },
    );
    Handle(conv, dirName)
  }

  private fun genericMap<T2: File>(
    conv: File ~> T2,
    context: mutable Context,
    dirName: DirName,
    f: (mutable Context, mutable Writer, BaseName, Array<T>) ~> void,
  ): Handle<T2> {
    thisDir = context.getDir(this.dirName);
    thisDirName = this.dirName.toString();
    thisDir.apply(context, dirName, (context, writer, key, files) ~> {
      context.vtry(
        () -> {
          if (files.size() == 0) return void;
          f(context, writer, key, files.map(x -> this.conv(x)));
        },
        e ->
          e match {
          | ErrorFile(trace) ->
            traceElt = ErrorTrace(thisDirName, key.toString(), "propagated");
            !trace = List.Cons(traceElt, trace);
            writer.write(key, ErrorFile(trace))
          | exn ->
            traceElt = ErrorTrace(
              thisDirName,
              key.toString(),
              exn.getMessage(),
            );
            trace = List.Cons(traceElt, List.Nil());
            writer.write(key, ErrorFile(trace))
          }
        ,
      )
    });
    Handle(conv, dirName)
  }

  fun duplicateError(key: BaseName, files: Array<T>): ErrorFile {
    traceElt = ErrorTrace(
      this.dirName.toString(),
      key.toString(),
      "duplicate keys: " + inspect(files).toString(),
    );
    trace = List.Cons(traceElt, List.Nil());
    ErrorFile(trace)
  }

  fun noValueError(key: BaseName): ErrorFile {
    traceElt = ErrorTrace(this.dirName.toString(), key.toString(), "no value");
    trace = List.Cons(traceElt, List.Nil());
    ErrorFile(trace)
  }

  fun map<T2: File>(
    conv: File ~> T2,
    context: mutable Context,
    dirName: DirName,
    f: (T) ~> T2,
  ): Handle<T2> {
    this.genericMap(conv, context, dirName, (_, writer, key, files) ~> {
      if (files.size() >= 2) {
        errFile = this.duplicateError(key, files);
        writer.write(key, errFile);
        return void;
      };
      result = f(files[0]);
      writer.write(key, result);
    })
  }

  fun contextMap<T2: File>(
    conv: File ~> T2,
    context: mutable Context,
    dirName: DirName,
    f: (mutable Context, T) ~> T2,
  ): Handle<T2> {
    this.genericMap(conv, context, dirName, (context, writer, key, files) ~> {
      if (files.size() >= 2) {
        errFile = this.duplicateError(key, files);
        writer.write(key, errFile);
        return void;
      };
      result = f(context, files[0]);
      writer.write(key, result);
    })
  }

  fun contextWriterMap<T2: File>(
    conv: File ~> T2,
    context: mutable Context,
    dirName: DirName,
    f: (mutable Context, mutable Writer, T) ~> void,
  ): Handle<T2> {
    this.genericMap(conv, context, dirName, (context, writer, key, files) ~> {
      if (files.size() >= 2) {
        errFile = this.duplicateError(key, files);
        writer.write(key, errFile);
        return void;
      };
      f(context, writer, files[0]);
    })
  }

  fun contextWriterKeyMap<T2: File>(
    conv: File ~> T2,
    context: mutable Context,
    dirName: DirName,
    f: (mutable Context, mutable Writer, BaseName, T) ~> void,
  ): Handle<T2> {
    this.genericMap(conv, context, dirName, (context, writer, key, files) ~> {
      if (files.size() >= 2) {
        errFile = this.duplicateError(key, files);
        writer.write(key, errFile);
        return void;
      };
      f(context, writer, key, files[0]);
    })
  }

  fun contextWriterKeyValues<T2: File>(
    conv: File ~> T2,
    context: mutable Context,
    dirName: DirName,
    f: (mutable Context, mutable Writer, BaseName, Array<T>) ~> void,
  ): Handle<T2> {
    this.genericMap(conv, context, dirName, (context, writer, key, files) ~> {
      f(context, writer, key, files);
    })
  }

  fun getArray(context: mutable Context, key: BaseName): Array<T> {
    dir = context.getDir(this.dirName);
    results = dir.getArray(context, key).map(this.conv);
    results
  }

  fun get(context: mutable Context, key: BaseName): T {
    values = this.getArray(context, key);
    if (values.size() >= 2) {
      errFile = this.duplicateError(key, values);
      throw (errFile);
    };
    if (values.size() == 0) {
      errFile = this.noValueError(key);
      throw (errFile);
    };
    values[0]
  }

  fun containsKey(context: mutable Context, key: BaseName): Bool {
    this.getArray(context, key).size() > 0
  }

  fun maybeGet(context: mutable Context, key: BaseName): ?T {
    values = this.getArray(context, key);
    if (values.size() == 0) return None();
    Some(values[0])
  }

  fun pre(): (mutable Context ~> ?Handle<T>) {
    context ~> {
      if (!context.hasPre.contains(this.dirName)) {
        context.!hasPre = context.hasPre.add(this.dirName);
        return None();
      };
      context.maybeGetDir(this.dirName.pre()) match {
      | None() -> None()
      | Some(dir) -> Some(Handle(this.conv, dir.dirName))
      }
    }
  }

  fun next(context: mutable Context): Handle<T> {
    dirName = this.dirName.next();
    if (!context.hasNext.contains(this.dirName)) {
      fixedData = FixedData{dirName, data => Array[]};
      time = context.timeStamp();
      dir = Dir{time, isInput => true, dirName, fixedData};
      context.setDir(dirName, dir);
      return Handle(this.conv, dirName)
    };
    Handle(this.conv, dirName)
  }
}

module end;
