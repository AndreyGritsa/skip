/*****************************************************************************/
/* Lazy directories. */
/*****************************************************************************/
module SKFS;

base class LazyResult {
  children =
  | LDefined(Array<File>)
  | LError(ErrorFile)
  | LAbsent()
  | LDelayed()
}

class LazyDir{
  time: Int,
  dirName: DirName,
  data: SortedMap<BaseName, LazyResult> = SortedMap[],
  lazyFun: ((mutable Context, BaseName) ~> LazyResult),
} extends Dir {
  fun isInput(): Bool {
    false
  }

  fun getTime(): Int {
    this.time
  }

  fun reset(context: mutable Context): void {
    context.setDir(this.dirName, this);
  }

  fun files(): Set<BaseName> {
    keys = mutable Set[];
    for (newKey => value in this.data) {
      if (value is LDefined _) {
        keys.insert(newKey);
      };
    };
    keys.chill()
  }

  fun getDirName(): DirName {
    this.dirName
  }

  fun isDeleted(): Bool {
    false
  }

  static fun create(
    context: mutable Context,
    dirName: DirName,
    f: (mutable Context, DirName, BaseName) ~> ?Array<File>,
  ): Dir {
    time = context.timeStamp();
    updateReaders = (
      dirName: DirName,
      context: mutable Context,
      key: BaseName,
    ) ~> {
      reads = context.getReads();

      for (read in reads) {
        readSet = context.newDeps.maybeGet(read) match {
        | None() -> SortedSet[]
        | Some(x) -> x
        };
        !readSet = readSet.set(ArrowKey(dirName, dirName, key));
        context.!newDeps[read] = readSet;
      };
    };
    lazyFun = (context: mutable Context, key: BaseName) ~> {
      readsCopy = context.reads;
      context.!reads = mutable Vector[];
      result = context.vtry<LazyResult>(
        () -> {
          f(context, dirName, key) match {
          | None() -> LAbsent()
          | Some(x) -> LDefined(x)
          }
        },
        e ->
          LError(
            ErrorFile(
              List[
                ErrorTrace(dirName.toString(), key.toString(), e.getMessage()),
              ],
            ),
          )
        ,
      );
      dir = context.unsafeGetLazyDir(dirName);
      !dir.data[key] = result;
      updateReaders(dirName, context, key);
      context.setDir(dirName, dir);
      if (context.debugMode) {
        name = "" + dir.dirName + key;
        print_string(`WRITTEN LAZY:  ${name} => ${inspect(result)}`);
      };
      context.!reads = readsCopy;
      result
    };
    newDir = LazyDir{time, dirName, lazyFun};
    updateDirtyReaders(context, Path::create(dirName.tag(), DIR_TAG));
    context.setDir(dirName, newDir);
    newDir
  }

  fun getArrayRaw(key: BaseName): Array<File> {
    this.data.maybeGet(key) match {
    | Some(LDefined(arr)) -> arr
    | Some(LError(err)) -> Array[err]
    | _ -> Array[]
    }
  }

  fun update(context: mutable Context): void {
    thisDirtyReaders = SortedSet[];
    firstDirtyReaders = context.dirtyReaders.maybeGet(this.dirName) match {
    | None() -> mutable Map[]
    | Some(m) -> m
    };

    for (dirtyReaderDirName => dirtyReaderBaseNames in firstDirtyReaders) {
      for (dirtyReaderBaseName in dirtyReaderBaseNames) {
        !thisDirtyReaders = thisDirtyReaders.add(
          Path::create(dirtyReaderDirName, dirtyReaderBaseName),
        );
      }
    };
    dirtyReaders = fixPoint(thisDirtyReaders, key -> {
      context
        .getDeps(key)
        .filter(x -> x.childName == this.dirName)
        .map(x -> Path::create(x.childName, x.key))
        .collect(Set);
    });
    for (path in dirtyReaders) {
      key = path.baseName;
      oldData = this.data[key];
      newData = this.lazyFun(context, key);
      if (native_eq(oldData, newData) == 0) {
        if (context.debugMode) {
          print_string("LAZY REUSING KEY: " + key);
        };
        continue;
      };
      !this.data[key] = newData;
      updateDirtyReaders(context, path);
    };
    context.setDir(this.dirName, this);
  }

  fun unsafeGetArray(
    context: mutable Context,
    key: BaseName,
    isAsync: Bool = false,
  ): Array<File> {
    lazyResult = this.data.maybeGet(key) match {
    | None()
    | Some(LAbsent()) ->
      if (isAsync) {
        context.pushAsync(Path::create(this.dirName, key));
        LDelayed()
      } else {
        this.lazyFun(context, key)
      }
    | Some(LDelayed()) if (!isAsync) -> this.lazyFun(context, key)
    | Some(x) -> x
    };
    lazyResult match {
    | LDefined(arr) -> arr
    | LError(err) -> Array[err]
    | _ -> Array[]
    }
  }

  fun getArray(context: mutable Context, key: BaseName): Array<File> {
    path = Path::create(this.dirName, key);
    context.addDep(path);
    this.unsafeGetArray(context, key, false)
  }

  fun getArrayAsync(context: mutable Context, key: BaseName): Array<File> {
    path = Path::create(this.dirName, key);
    context.addDep(path);
    this.unsafeGetArray(context, key, true)
  }
}
