module SKFS;

class KeySet(value: Set<BaseName>) extends File

class BigInt(data: Array<UInt32>) extends BaseName {
  fun toString(): String {
    inspect(this).toString()
  }

  static fun create(ints: Array<Int>): this {
    mdata = Array::mfill(ints.size() * 2, UInt32::truncate(0));
    for (j in Range(0, ints.size())) {
      i = ints.size() - j - 1;
      n = ints[i];
      signed = n < 0;
      lBits = n.and(1.shl(32) - 1);
      hBits = n.shr(32);
      mdata![2 * i] = UInt32::truncate(
        if (signed) 1.shl(31) + hBits else hBits,
      );
      mdata![2 * i + 1] = UInt32::truncate(lBits);
    };
    first = 0;
    while (first < mdata.size() && mdata[first] == 0) !first = first + 1;
    data = mdata.slice(first, mdata.size());

    BigInt(data, hash(data))
  }

  fun toInt(): Int {
    if (this.data.size() > 2) {
      invariant_violation("BigInt too big to be represented as an integer")
    };
    this.data[0].toInt().shl(32) + this.data[1].toInt()
  }

  fun shr(n: Int): this {
    mdata = Array::mfill(this.data.size(), UInt32::truncate(0));
    for (j in Range(0, this.data.size())) {
      i = this.data.size() - j - 1;

      up = if (i - 1 - n / 32 < 0) 0 else {
        this.data[i - 1 - n / 32].and(1.shl(n % 32) - 1)
      };

      if (i - n / 32 < 0) break void;

      mdata![i] = UInt32::truncate(
        this.data[i - n / 32].shr(n % 32).or(up.shl(32 - n % 32)),
      );
    };

    first = 0;
    while (first < mdata.size() && mdata[first] == 0) !first = first + 1;

    data = mdata.slice(first, mdata.size());

    BigInt(data, hash(data))
  }

  fun shl(n: Int): this {
    size = this.data.size();
    mdataSize = size + 1 + n / 32;
    mdata = Array::mfillBy(mdataSize, i ~>
      if (i - 1 - n / 32 < 0) UInt32::truncate(0) else this.data[i - 1 - n / 32]
    );

    for (i in Range(0, mdataSize)) {
      current = if (i + n / 32 >= mdataSize) 0 else {
        mdata[i + n / 32].shl(n % 32)
      };
      down = if (i + 1 + n / 32 >= mdataSize) 0 else {
        mdata[i + 1 + n / 32].shr(32 - n % 32)
      };
      mdata![i] = UInt32::truncate(current.or(down));
    };

    BigInt(mdata.chill(), hash(mdata))
  }

  fun isZero(): Bool {
    for (elt in this.data) {
      if (elt != 0) return false;
    };
    true
  }

  fun incr(): this {
    mdata = Array::mfillBy(this.data.size() + 1, i ~>
      if (i - 1 < 0) UInt32::truncate(0) else this.data[i - 1]
    );

    for (j in Range(0, mdata.size())) {
      i = mdata.size() - 1 - j;
      if (mdata[i] == 0) {
        mdata![i] = UInt32::truncate(1);
        break void;
      };
      n = UInt32::truncate(mdata[i] + 1);
      mdata![i] = n;
      if (n != 0) break void;
    };

    first = 0;
    while (first < mdata.size() && mdata[first] == 0) !first = first + 1;

    data = mdata.slice(first, mdata.size());

    BigInt(data, hash(data))
  }
}

class RangeIndex{bitSize: Int, intSize: Int, data: Array<EHandle<BaseName>>} {
  static fun create<T: File>{
    context: mutable Context,
    name: String,
    bitSize: Int,
    intSize: Int,
    input: EHandle<T>,
    proj: T ~> BigInt,
  }: RangeIndex {
    dirs = mutable Vector[];
    for (round in Range(0, intSize / bitSize)) {
      subName = DirName::create(name + "rindex" + round + "/");
      dirs.push(
        input.contextWriterKeyMap(
          BigInt::fromFile,
          context,
          subName,
          (_context, writer, key, file) ~> {
            value = proj(file);
            if (round == 0) {
              writer.write(value, key);
            } else {
              !value = value.shr(round * bitSize);
              if (!value.isZero()) {
                writer.write(value, key);
              }
            }
          },
        ),
      );
    };
    RangeIndex{bitSize, intSize, data => dirs.toArray()}
  }

  private fun lquery(
    context: mutable Context,
    acc: mutable Set<BaseName>,
    level: Int,
    start: SKFS.BigInt,
    end: SKFS.BigInt,
  ): void {
    if (start > end) return void;
    shStart = start.shr(this.bitSize).incr();
    shEnd = end.shr(this.bitSize);
    nextStart = shStart.shl(this.bitSize);
    nextEnd = shEnd.shl(this.bitSize);
    if (nextStart >= end) {
      i = start;
      while (i < end) {
        for (elt in this.data[level].getArray(context, i)) {
          acc.insert(elt);
        };
        !i = i.incr();
      };
      return void;
    };
    while (start < nextStart) {
      for (elt in this.data[level].getArray(context, start)) {
        acc.insert(elt);
      };
      !start = start.incr();
    };
    if (!shStart.isZero() && shStart < shEnd) {
      this.lquery(context, acc, level + 1, shStart, shEnd);
    };
    while (nextEnd < end) {
      for (elt in this.data[level].getArray(context, nextEnd)) {
        acc.insert(elt);
      };
      !nextEnd = nextEnd.incr();
    }
  }

  fun query(
    context: mutable Context,
    start: BigInt,
    end: BigInt,
  ): Set<BaseName> {
    acc = mutable Set[];
    this.lquery(context, acc, 0, start, end);
    acc.chill()
  }
}

module end;

module SKFSTest;

fun parseRange(str: String): (Int, Int) {
  chars = str.chars().filter(c -> c != ' ' && c != '[' && c != ']');
  toks = String::fromChars(chars.toArray()).split(",");
  n1 = toks[0].toInt();
  n2 = toks[1].toInt();
  (n1, n2)
}

fun testIndex(): mutable SKFS.Context {
  SKFS.run(context ~> {
    ints = mutable Vector[];
    /*    for (i in Range(0, 256)) {
          ints.push((IID(i), StringFile(i.toString())));
        };
    */
    sinput = context.mkdir(
      SKFS.StringFile::fromFile,
      SKFS.DirName::create("/sinput/"),
      ints.toArray(),
    );
    input = sinput.map(
      SKFS.IntFile::fromFile,
      context,
      SKFS.DirName::create("/input/"),
      (x ~> SKFS.IntFile(x.value.toInt())),
    );
    queryData = mutable Vector[];
    for (i in Range(0, 32)) {
      for (j in Range(i, 32)) {
        queryData.push(
          (
            SKFS.SID::create("s" + i + "_" + j),
            SKFS.StringFile(`[${i}, ${j}]`),
          ),
        );
      }
    };

    queries = context.mkdir(
      SKFS.StringFile::fromFile,
      SKFS.DirName::create("/queries/"),
      queryData.toArray(),
    );
    rindex = SKFS.RangeIndex::create{
      context,
      name => "/results/",
      intSize => 16,
      bitSize => 5,
      input,
      proj => x ~> SKFS.BigInt::create(Array[x.value]),
    };
    _queryResults = queries.contextMap(
      SKFS.KeySet::fromFile,
      context,
      SKFS.DirName::create("/qresults/"),
      (context, queryStr) ~> {
        (start, end) = parseRange(queryStr.value);
        SKFS.KeySet(
          rindex.query(
            context,
            SKFS.BigInt::create(Array[start]),
            SKFS.BigInt::create(Array[end + 1]),
          ),
        );
      },
    );
    /*
        _ = queryResults.contextWriterKeyMap(
          IntFile::fromFile,
          context,
          "/dumbCheck/",
          (context, _writer, qid, immSet) ~> {
            set = Set::mcreateFromItems(immSet.value);
            (start, end) = parseRange(queries.get(context, qid).value);
            for (i in Range(start, end + 1)) {
              key = IID(i);
              if (!set.contains(key)) {
                print_error("Missing: " + i + " from " + qid + "\n")
              };
              set.remove(key);
            };
            if (!set.isEmpty()) {
              print_error("Set too big for " + qid + " " + set + "\n");
            }
          },
        );
    */
  })
}
