module SKFS;

class KeySet(value: Set<BaseName>) extends File

fun baseNameFromFile(file: File): BaseName {
  file match {
  | SID(_) -> SID::fromFile(file)
  | IID(_) -> IID::fromFile(file)
  | _ -> invariant_violation("Was expecting a baseName")
  }
}

class RangeIndex{bitSize: Int, intSize: Int, data: Array<Handle<BaseName>>} {
  static fun create{
    context: mutable Context,
    bitSize: Int,
    intSize: Int,
    input: Handle<IntFile>,
  }: RangeIndex {
    dirs = mutable Vector[];
    for (round in Range(0, intSize / bitSize)) {
      subName = DirName::create(
        input.dirName.toString() + "rindex" + round + "/",
      );
      dirs.push(
        input.contextWriterKeyMap(
          baseNameFromFile,
          context,
          subName,
          (_context, writer, key, file) ~> {
            value = file.value;
            if (round == 0) {
              writer.write(IID(value), key);
            } else {
              !value = value.shr(round * bitSize);
              if (value != 0) {
                writer.write(IID(value), key);
              }
            }
          },
        ),
      );
    };
    RangeIndex{bitSize, intSize, data => dirs.toArray()}
  }

  private fun lquery(
    context: mutable Context,
    acc: mutable Set<BaseName>,
    level: Int,
    start: Int,
    end: Int,
  ): void {
    if (start > end) return void;
    shStart = start.shr(this.bitSize) + 1;
    shEnd = end.shr(this.bitSize);
    nextStart = shStart.shl(this.bitSize);
    nextEnd = shEnd.shl(this.bitSize);
    if (nextStart >= end) {
      for (i in Range(start, end)) {
        for (elt in this.data[level].getArray(context, IID(i))) {
          acc.insert(elt);
        };
      };
      return void;
    };
    while (start < nextStart) {
      for (elt in this.data[level].getArray(context, IID(start))) {
        acc.insert(elt);
      };
      !start = start + 1;
    };
    if (shStart != 0 && shStart != -1 && shStart < shEnd) {
      this.lquery(context, acc, level + 1, shStart, shEnd);
    };
    while (nextEnd < end) {
      for (elt in this.data[level].getArray(context, IID(nextEnd))) {
        acc.insert(elt);
      };
      !nextEnd = nextEnd + 1;
    }
  }

  fun query(context: mutable Context, start: Int, end: Int): Set<BaseName> {
    if (start < 0 || end < 0) {
      error("Negative number not supported in RangeQueries");
    };
    acc = mutable Set[];
    this.lquery(context, acc, 0, start, end);
    acc.chill()
  }
}

module end;

module SKFSTest;

fun parseRange(str: String): (Int, Int) {
  chars = str.chars().filter(c -> c != ' ' && c != '[' && c != ']');
  toks = String::fromChars(chars.toArray()).split(",");
  n1 = toks[0].toInt();
  n2 = toks[1].toInt();
  (n1, n2)
}

fun testIndex(): mutable SKFS.Context {
  SKFS.run(context ~> {
    ints = mutable Vector[];
    /*    for (i in Range(0, 256)) {
          ints.push((IID(i), StringFile(i.toString())));
        };
    */
    sinput = context.mkdir(
      SKFS.StringFile::fromFile,
      SKFS.DirName::create("/sinput/"),
      ints.toArray(),
    );
    input = sinput.map(
      SKFS.IntFile::fromFile,
      context,
      SKFS.DirName::create("/input/"),
      (x ~> SKFS.IntFile(x.value.toInt())),
    );
    queryData = mutable Vector[];
    for (i in Range(0, 32)) {
      for (j in Range(i, 32)) {
        queryData.push(
          (SKFS.SID("s" + i + "_" + j), SKFS.StringFile(`[${i}, ${j}]`)),
        );
      }
    };

    queries = context.mkdir(
      SKFS.StringFile::fromFile,
      SKFS.DirName::create("/queries/"),
      queryData.toArray(),
    );
    rindex = SKFS.RangeIndex::create{
      context,
      intSize => 16,
      bitSize => 5,
      input,
    };
    _queryResults = queries.contextMap(
      SKFS.KeySet::fromFile,
      context,
      SKFS.DirName::create("/qresults/"),
      (context, queryStr) ~> {
        (start, end) = parseRange(queryStr.value);
        SKFS.KeySet(rindex.query(context, start, end + 1));
      },
    );
    /*
        _ = queryResults.contextWriterKeyMap(
          IntFile::fromFile,
          context,
          "/dumbCheck/",
          (context, _writer, qid, immSet) ~> {
            set = Set::mcreateFromItems(immSet.value);
            (start, end) = parseRange(queries.get(context, qid).value);
            for (i in Range(start, end + 1)) {
              key = IID(i);
              if (!set.contains(key)) {
                print_error("Missing: " + i + " from " + qid + "\n")
              };
              set.remove(key);
            };
            if (!set.isEmpty()) {
              print_error("Set too big for " + qid + " " + set + "\n");
            }
          },
        );
    */
  })
}
