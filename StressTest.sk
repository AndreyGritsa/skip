/*****************************************************************************/
/* Module generating tests for the filesystem. */
/*****************************************************************************/

module SKFSTest;

base class RNbr {
  children =
  | RFixed(Int)
  | RRange(Int, Int)
  | RProb(Int)
}

class Config{
  nbrInputs: RNbr = RRange(1, 5),
  inputSize: RNbr = RRange(1, 5),
  missingKey: RNbr = RProb(40),
  valueWidth: RNbr = RRange(1, 5),
  valueRange: RNbr = RRange(0, 5),
  nbrDirs: RNbr = RRange(1, 5),
  funBodySize: RNbr = RRange(1, 5),
  mergeSize: RNbr = RRange(1, 4),
  probKeyChange: RNbr = RProb(50),
  probLazyDir: RNbr = RProb(50),
  probKeyChangeRemoved: RNbr = RProb(10),
  nbrRounds: Int = 1000,
}

/*
class Config{
  nbrInputs: RNbr = RRange(1, 2),
  inputSize: RNbr = RRange(1, 2),
  missingKey: RNbr = RProb(30),
  valueWidth: RNbr = RRange(1, 2),
  valueRange: RNbr = RRange(0, 2),
  nbrDirs: RNbr = RRange(1, 2),
  funBodySize: RNbr = RRange(1, 2),
  mergeSize: RNbr = RRange(1, 2),
  probKeyChange: RNbr = RProb(50),
  probLazyDir: RNbr = RProb(0),
  probKeyChangeRemoved: RNbr = RProb(0),
  nbrRounds: Int = 1000,
}
*/

const VALUE_SIZE: Int = 10;

class Program(
  inputs: List<Input>,
  diffs: Map<String, Map<Int, List<SKFS.IntFile>>>,
  mDirs: List<DirValue>,
)

class Input{name: String, data: Map<Int, List<SKFS.IntFile>>}
base class DirValue{name: String} {
  children =
  | MDir{input: String, readDirs: List<String>}
  | LDir{readDirs: List<String>}
}

/*****************************************************************************/
/* Interpreter using SKFS. */
/*****************************************************************************/

fun merge(l1: List<SKFS.IntFile>, l2: List<SKFS.IntFile>): List<SKFS.IntFile> {
  (l1, l2) match {
  | (List.Nil(), l)
  | (l, List.Nil()) ->
    l
  | (List.Cons(x1, rl1), List.Cons(x2, rl2)) ->
    List.Cons(SKFS.IntFile((x1.value + x2.value) % VALUE_SIZE), merge(rl1, rl2))
  }
}

fun eval(
  context: mutable SKFS.Context,
  prog: Program,
  debug: Bool = false,
): void {
  makeEnv(context, prog.inputs);
  evalDirs(context, prog.mDirs);
  if (!debug) return void;
  for (kv in context.dirs.state.items()) {
    (dirName, dir) = kv;
    print_string("Dir: " + dirName);
    for (key in dir.files()) {
      print_string(
        "  " +
          key +
          " => " +
          dir.getArrayRaw(key).map(x ->
            SKFS.IntFile::fromFile(x).value.toString()
          ),
      );
    }
  }
}

fun makeEnv(context: mutable SKFS.Context, inputs: List<Input>): void {
  for (input in inputs) {
    data = mutable Vector[];
    for (key => values in input.data) {
      for (value in values) {
        data.push((SKFS.IID(key), value));
      }
    };
    _ = context.mkdir(
      SKFS.IntFile::fromFile,
      SKFS.DirName::create(input.name),
      data.toArray(),
    );
  }
}

fun evalDirs(context: mutable SKFS.Context, dirs: List<DirValue>): void {
  for (dir in dirs) {
    dir match {
    | mDir @ MDir _ -> evalMDir(context, mDir)
    | lDir @ LDir _ -> evalLDir(context, lDir)
    }
  }
}

fun evalMDir(context: mutable SKFS.Context, dir: MDir): void {
  name = dir.name;
  input = dir.input;
  readDirs = dir.readDirs;
  inputDir = context.getDir(SKFS.DirName::create(input));
  _ = inputDir.apply(
    context,
    SKFS.DirName::create(name),
    (context, writer, key, values) ~> {
      if (values.size() == 0) return void;
      evalFun(context, writer, name.toString(), readDirs, key, values)
    },
  )
}

fun evalLDir(context: mutable SKFS.Context, dir: LDir): void {
  _ = SKFS.Dir::lazy(
    context,
    SKFS.DirName::create(dir.name),
    (context, _self, key) ~> {
      evalLFun(context, dir.name, dir.readDirs, key)
    },
  )
}

fun evalSub(
  context: mutable SKFS.Context,
  thisDirName: String,
  readDirs: List<String>,
  currentKey: SKFS.BaseName,
  currentValues: Array<SKFS.File>,
): List<String> {
  sumAcc = 0;

  for (elt in currentValues) {
    !sumAcc = sumAcc + SKFS.IntFile::fromFile(elt).value;
  };

  sum = sumAcc;

  subDirs = List[];

  for (dirName in readDirs.sorted().unique()) {
    dir = context.getDir(SKFS.DirName::create(dirName));
    if (dir.lazyFun is Some _) continue;
    subDirNameStr = dirName + "sub" + currentKey + "_" + sum + thisDirName;
    subDirName = SKFS.DirName::create(subDirNameStr);
    !subDirs = List.Cons(subDirNameStr, subDirs);
    _ = dir.apply(context, subDirName, (context, writer, localKey, values) ~> {
      localSum = sum;
      for (readDirName in readDirs) {
        readDir = context.getDir(SKFS.DirName::create(readDirName));
        read = readDir.getArray(context, localKey).map(x ->
          SKFS.IntFile::fromFile(x)
        );
        for (value in read) {
          !localSum = localSum + value.value
        };
      };
      for (value in values) {
        !localSum = localSum + SKFS.IntFile::fromFile(value).value;
      };
      writer.write(localKey, SKFS.IntFile(localSum))
    })
  };

  subDirs
}

fun evalLFun(
  context: mutable SKFS.Context,
  thisDirName: String,
  readDirs: List<String>,
  key: SKFS.BaseName,
): SKFS.File {
  reads = List[];
  for (dirName in readDirs) {
    dir = context.getDir(SKFS.DirName::create(dirName));
    value = key match {
    | SKFS.IID(x) -> SKFS.IntFile(x)
    | _ -> error()
    };
    read = dir
      .getArray(context, SKFS.IID(SKFS.IntFile::fromFile(value).value))
      .map(x -> SKFS.IntFile::fromFile(x));
    !reads = List.Cons(read, reads);
  };

  result = 0;
  for (ilist in reads) {
    for (x in ilist) {
      !result = result + SKFS.IntFile::fromFile(x).value;
    }
  };
  keyValue = key match {
  | SKFS.IID(x) -> x
  | _ -> error()
  };
  if (keyValue > 10) {
    thisDir = context.getDir(SKFS.DirName::create(thisDirName));
    !result =
      result +
      SKFS.IntFile::fromFile(
        thisDir.getArray(context, SKFS.IID(keyValue / 2))[0],
      ).value;
  };
  SKFS.IntFile(result)
}

fun evalFun(
  context: mutable SKFS.Context,
  writer: mutable SKFS.Writer,
  thisDirName: String,
  readDirs: List<String>,
  currentKey: SKFS.BaseName,
  currentValues: Array<SKFS.File>,
): void {
  subDirs = evalSub(context, thisDirName, readDirs, currentKey, currentValues);

  reads = List[currentValues];
  for (dirName in readDirs.concat(subDirs)) {
    dir = context.getDir(SKFS.DirName::create(dirName));
    value = currentValues[0];
    read = dir
      .getArray(context, SKFS.IID(SKFS.IntFile::fromFile(value).value))
      .map(x -> SKFS.IntFile::fromFile(x));
    !reads = List.Cons(read, reads);
  };

  result = List[];
  for (ilist in reads) {
    !result = merge(
      result,
      List::createFromItems(ilist).map(x -> SKFS.IntFile::fromFile(x)),
    );
  };
  out = Array::createFromItems(result);

  allValues = mutable Map[];
  for (file in out) {
    key = SKFS.IID(SKFS.IntFile::fromFile(file).value);
    if (!allValues.containsKey(key)) allValues![key] = mutable Vector[];
    allValues[key].push(
      SKFS.IntFile(
        currentKey match {
        | SKFS.IID(x) -> x
        | _ -> error()
        },
      ),
    );
  };

  for (key => values in allValues) {
    writer.writeArray(key, values.toArray())
  }
}

/*****************************************************************************/
/* Compare outputs. */
/*****************************************************************************/

fun compareContext(
  context1: readonly SKFS.Context,
  context2: readonly SKFS.Context,
): Bool {
  hasError = false;
  for (kv in context1.dirs.state.items()) {
    (dirName, dir) = kv;
    dirFiles = dir.files();
    if (dirFiles.isEmpty()) continue;

    if (context2.unsafeMaybeGetDir(dirName) is None _) {
      if (dirName.toString().contains("LAZY")) continue;
      if (!dir.deleted) {
        print_error(`missing directory ${dirName}`);
        error();
      };
      continue;
    };
    dir2 = context2.unsafeGetDir(dirName);
    isLazy = dir2.dirName.toString().contains("LAZY");
    for (key in dirFiles) {
      values1 = dir.getArrayRaw(key).map(x -> SKFS.IntFile::fromFile(x));
      values2 = dir2.getArrayRaw(key).map(x -> SKFS.IntFile::fromFile(x));
      if (dir2.lazyFun is Some _) {
        if (values1 == Array[] || values2 == Array[]) continue;
      };
      if (values1 != values2) {
        if (isLazy && (values1.isEmpty() || values2.isEmpty())) {
          continue
        };
        debug((dir2.lazyFun, values1.isEmpty(), values2.isEmpty()));
        !hasError = true;
        print_string(`Error: values differ for ${dirName}${key}`);
        print_string(`       ${values1}`);
        for (fixed in dir.fixedData.getArray(key)) {
          (k, files) = fixed;
          intFiles = files.map(file -> SKFS.IntFile::fromFile(file));
          print_string(`FIXED  ${k} => ${intFiles}`)
        };
        dir.data.maybeGet(key) match {
        | None() -> print_string("EMPTY DATA")
        | Some(sources) ->
          for (k => files in sources) {
            intFiles = files.map(file -> SKFS.IntFile::fromFile(file));
            print_string(`       ${k} => ${intFiles}`)
          }
        };
        print_string("");
        print_string(`       ${values2}`);
        for (fixed in dir2.fixedData.getArray(key)) {
          (k, files) = fixed;
          intFiles = files.map(file -> SKFS.IntFile::fromFile(file));
          print_string(`FIXED  ${k} => ${intFiles}`)
        };
        print_string("");
      }
    };
  };
  hasError
}

/*****************************************************************************/
/* Program generator. */
/*****************************************************************************/

type GenDirs = mutable Vector<String>;

fun genValues(rand: RNbr -> Int, config: Config): List<SKFS.IntFile> {
  values = List[];
  for (_ in Range(0, rand(config.valueWidth))) {
    file = SKFS.IntFile(rand(config.valueRange));
    !values = List.Cons(file, values)
  };
  values
}

fun genInputData(
  rand: RNbr -> Int,
  config: Config,
): Map<Int, List<SKFS.IntFile>> {
  data = mutable Map[];
  for (i in Range(0, rand(config.inputSize))) {
    if (rand(config.missingKey) == 1) continue;
    data![i] = genValues(rand, config);
  };
  data.chill()
}

fun genInputs(rand: RNbr -> Int, config: Config): (List<Input>, GenDirs) {
  result = List<Input>[];
  dirs = mutable Vector[];
  for (i in Range(0, rand(config.nbrInputs))) {
    name = "/input" + i + "/";
    data = genInputData(rand, config);
    dir = Input{name, data};
    !result = List.Cons(dir, result);
    dirs.push(name);
  };
  (result, dirs)
}

fun genGet(rand: RNbr -> Int, dirs: GenDirs): String {
  dirNbr = rand(RRange(0, dirs.size()));
  dirName = dirs[dirNbr];
  dirName
}

fun genReadDirs(
  rand: RNbr -> Int,
  config: Config,
  dirs: GenDirs,
): List<String> {
  readDirs = List[];
  funBodySize = 1 + rand(config.funBodySize);
  for (_ in Range(1, funBodySize)) {
    !readDirs = List.Cons(genGet(rand, dirs), readDirs);
  };
  readDirs
}

fun genMDir(
  rand: RNbr -> Int,
  config: Config,
  dirs: GenDirs,
  mdirs: GenDirs,
  nbr: Int,
): MDir {
  name = "/dir" + nbr + "/";
  inputNbr = rand(RRange(0, mdirs.size()));
  input = mdirs[inputNbr];
  readDirs = genReadDirs(rand, config, dirs);
  dirs.push(name);
  mdirs.push(name);
  MDir{name, input, readDirs}
}

fun genLDir(rand: RNbr -> Int, config: Config, dirs: GenDirs, nbr: Int): LDir {
  name = "/dir" + nbr + "LAZY/";
  readDirs = genReadDirs(rand, config, dirs);
  dirs.push(name);
  ldir = LDir{name, readDirs};
  ldir
}

fun genDirs(rand: RNbr -> Int, config: Config, dirs: GenDirs): List<DirValue> {
  mdirs = Vector::mcreateFromItems(dirs);
  result = List[];
  size = dirs.size() + rand(config.nbrDirs);
  for (i in Range(dirs.size(), size)) {
    dir = if (i == size - 1 || rand(config.probLazyDir) == 0) {
      genMDir(rand, config, dirs, mdirs, i)
    } else {
      genLDir(rand, config, dirs, i)
    };
    !result = List.Cons(dir, result);
  };
  result.reversed()
}

fun genDiffs(
  rand: RNbr -> Int,
  config: Config,
  inputs: List<Input>,
): Map<String, Map<Int, List<SKFS.IntFile>>> {
  diffs = mutable Map[];
  for (input in inputs) {
    data = mutable Map[];
    for (key => _ in input.data) {
      if (rand(config.probKeyChange) == 1) {
        newValues = if (rand(config.probKeyChangeRemoved) == 1) List[] else {
          genValues(rand, config)
        };
        data![key] = newValues;
      }
    };
    diffs![input.name] = data.chill();
  };
  diffs.chill()
}

fun genProgram(config: Config, round: Int): Program {
  random = Random::mcreate(1 + round);
  rand = (rnbr: RNbr) ->
    rnbr match {
    | RFixed(fixed) -> fixed
    | RRange(rmin, rmax) -> random.random(rmin, rmax)
    | RProb(prob) -> if (random.random(0, 100) < prob) 1 else 0
    };
  (inputs, inputDirs) = genInputs(rand, config);
  dirs = genDirs(rand, config, inputDirs);
  diffs = genDiffs(rand, config, inputs);
  Program(inputs, diffs, dirs)
}

/*****************************************************************************/
/* Function that applies the diff. */
/*****************************************************************************/

fun updateProgram(context: mutable SKFS.Context, prog: Program): Program {
  !prog.inputs = prog.inputs.map(input -> {
    dirName = SKFS.DirName::create(input.name);
    diff = prog.diffs[input.name];
    data = mutable Map[];
    for (key => values in input.data) {
      if (diff.containsKey(key)) {
        newValues = diff[key];
        dir = context.getDir(dirName);
        valuesArr = Array::createFromItems(newValues);
        dir.writeArray(context, SKFS.IID(key), valuesArr);
        data![key] = diff[key];
      } else {
        data![key] = values;
      }
    };
    input with {data => data.chill()}
  });
  prog
}

/*****************************************************************************/
/* Test. */
/*****************************************************************************/

fun testInterpretor(round: ?Int): mutable SKFS.Context {
  config = Config{};
  SKFS.gContextInit(SKFS.Context{});
  for (i in Range(0, config.nbrRounds)) {
    !i = if (round is Some _) round.fromSome() else i;
    pos = SKFS.newObstack();
    print_string("Round: " + i);
    origProg = genProgram(config, i);
    context = SKFS.run(context ~> {
      eval(context, origProg);
    });
    if (context.debugMode) print_string("Initialization finished");
    newProg = updateProgram(context, origProg);
    context.update();
    SKFS.gContextSync(context.clone());
    if (context.debugMode) print_string("Running program from scratch");
    context2 = SKFS.run(context ~> {
      eval(context, newProg);
    });
    if (context.debugMode) {
      print_string("Compare contexts (Phase 1: updated/scratch)")
    };
    _ = compareContext(context, context2);
    if (context.debugMode) {
      print_string("Compare contexts (Phase 2: scratch/updated)")
    };
    _ = compareContext(context2, context);
    if (round is Some _) break void;
    SKFS.destroyObstack(pos);
  };
  SKFS.Context::fromSaved(SKFS.gContextGet())
}
