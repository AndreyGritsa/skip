/*****************************************************************************/
/* SQL expression evaluator. */
/*****************************************************************************/
module SKSQL;

class ExprEvaluator{
  pos: Int,
  env: Map<String, ?SValue>,
  //  cols: Map<String, Int>,
  //  dir: SKFS.EHandle<Row>,
} {
  fun binop(
    context: mutable SKFS.Context,
    op: String,
    e1: SKSQL.Expr,
    e2: SKSQL.Expr,
  ): SValue {
    op match {
    | "<" -> SVBool(this.evalExpr(context, e1) < this.evalExpr(context, e2))
    | "<=" -> SVBool(this.evalExpr(context, e1) <= this.evalExpr(context, e2))
    | ">" -> SVBool(this.evalExpr(context, e1) > this.evalExpr(context, e2))
    | ">=" -> SVBool(this.evalExpr(context, e1) >= this.evalExpr(context, e2))
    | "=" -> SVBool(this.evalExpr(context, e1) == this.evalExpr(context, e2))
    | "AND" ->
      SVBool(
        this.evalExpr(context, e1).isTrue() &&
          this.evalExpr(context, e2).isTrue(),
      )
    | "OR" ->
      SVBool(
        this.evalExpr(context, e1).isTrue() ||
          this.evalExpr(context, e2).isTrue(),
      )
    | "+" -> SVInt(this.int(context, e1) + this.int(context, e2))
    | "-" -> SVInt(this.int(context, e1) - this.int(context, e2))
    | "*" -> SVInt(this.int(context, e1) * this.int(context, e2))
    | "/" -> SVInt(this.int(context, e1) / this.int(context, e2))
    | _ ->
      debug(op);
      todo()
    }
  }

  fun int(context: mutable SKFS.Context, e: SKSQL.Expr): Int {
    this.evalExpr(context, e) match {
    | SVInt(n) -> n
    | _ -> error(this.pos, "Was expecting a numeric value")
    }
  }

  fun evalExpr(context: mutable SKFS.Context, e: SKSQL.Expr): SValue {
    e match {
    | Binop(".", Literal(str1), Literal(str2)) ->
      this.evalExpr(context, Literal(str1 + "." + str2))
    | Literal(str) ->
      str.getIter().next() match {
      | None() -> invariant_violation("Found empty literal")
      | Some(c) if (Chars.isDigit(c)) -> SVInt(str.toInt())
      | _ if (!this.env.containsKey(str)) ->
        error(this.pos, "Unbound name: " + str)
      | _ ->
        this.env[str] match {
        | None() -> error(this.pos, "Ambiguous name: " + str)
        | Some(v) -> v
        }
      }
    | Not(sub) ->
      this.evalExpr(context, sub) match {
      | SVBool(false) -> SVBool(true)
      | SVBool(true) -> SVBool(false)
      | x -> error(this.pos, "Invalid operation NOT on: " + x)
      }
    | Case(None(), cases, elseCaseOpt) ->
      for (case in cases) {
        (cond, action) = case;
        if (this.evalExpr(context, cond).isTrue()) {
          return this.evalExpr(context, action);
        }
      };
      elseCaseOpt match {
      | None() -> SVNull()
      | Some(elseCase) -> this.evalExpr(context, elseCase)
      }
    | Case(Some(cond), cases, elseCaseOpt) ->
      search = this.evalExpr(context, cond);
      for (case in cases) {
        (pat, action) = case;
        if (search == this.evalExpr(context, pat)) {
          return this.evalExpr(context, action);
        }
      };
      elseCaseOpt match {
      | None() -> SVNull()
      | Some(elseCase) -> this.evalExpr(context, elseCase)
      }
    | Binop(op, e1, e2) -> this.binop(context, op, e1, e2)
    | EQuery(q) -> this.evalQuery(context, q)
    /*    | Call(Literal(funName), None()) ->
          funName.uppercase() match {
          | "COUNT" -> SVInt(this.countAll(context))
          | _ ->
            debug(funName);
            error(this.pos, "Invalid function: " + funName)
          }
    */
    | Call(Literal(funName), Some(args)) ->
      funName.uppercase() match {
      | "AVG" -> todo()
      /*        (sum, size) = this.sum(context, args);
              if (sum == 0) SVInt(0) else SVInt(sum / size)
      */
      | "SUM" -> todo()
      /*
              (sum, _) = this.sum(context, args);
              SVInt(sum)
      */
      | "ABS" ->
        if (args.size() != 1) {
          error(this.pos, "Invalid number of arguments passed to ABS");
        };
        this.evalExpr(context, args[0]) match {
        | SVInt(n) if (n < 0) -> SVInt(n)
        | x -> x
        }
      | _ ->
        debug(funName);
        error(this.pos, "Invalid function: " + funName)
      }
    | Exists(q) -> SVBool(this.evalQuery(context, q) != SVNull())
    | _ ->
      debug("missing expr");
      debug(e);
      todo()
    /*
        | All(Expr)
        | Distinct(Expr)
        | In(Expr, Array<Expr>)
        | Between(Expr)
        | EQuery(Query)
        | Exists(Query)
        | UMinus(Expr)
        | UPlus(Expr)
        | Case(condOpt: ?Expr, whenCases: Array<(Expr, Expr)>, elseCase: ?Expr)
        | Call(Expr, ?Array<Expr>)
    */
    }
  }

  fun evalQuery(context: mutable SKFS.Context, query: Query): SValue {
    select = query match {
    | select @ Select _ -> select
    };
    selectName = evalSelect(context, select);
    dirName = SKFS.DirName::create("/" + select.id + "/files/");
    handle = SKFS.EHandle(Row::fromFile, selectName);
    files = makeDir(Row::fromFile, context, dirName, () ->
      handle.contextWriterMap(
        Row::fromFile,
        context,
        dirName,
        (_, writer, x) ~> writer.write(SKFS.IID(0), x),
      )
    );
    fileArray = files.getArray(context, SKFS.IID(0));
    if (fileArray.size() == 0) SVNull() else {
      values = fileArray[0].values;
      if (values.size() > 1) {
        error(select.pos, "Sub-select returns more than one column");
      };
      values[0]
    }
  }

  /*
    fun sum(context: mutable SKFS.Context, args: Array<Expr>): (Int, Int) {
      if (args.size() != 1) {
        error(this.pos, "Invalid number of arguments passed to 'avg'");
      };
      colName = args[0] match {
      | Literal(x) ->
        if (!this.env.containsKey(x)) {
          error(this.pos, "Column not found: " + x);
        };
        x
      | _ -> error(this.pos, "'AVG' expects a column name")
      };
      avgName = makeAvgName(this.dir.dirName, colName);
      zero = SKFS.IID(0);
      reducer = makeDir(Row::fromFile, context, avgName, () -> {
        this.dir.contextWriterMap(
          Row::fromFile,
          context,
          avgName,
          (_context, writer, row) ~> {
            this.env[colName] match {
            | None() -> void
            | Some(value) -> writer.write(zero, Row(Array[value]))
            }
          },
        )
      });
      elts = reducer.getArray(context, zero);
      if (elts.size() == 0) return (0, 0);
      acc = 0;
      for (elt in elts) {
        elt.values[0] match {
        | SVInt(n) -> !acc = acc + n
        | _ -> void
        }
      };
      (acc, elts.size())
    }
  */

  /*
    fun countAll(context: mutable SKFS.Context): Int {
      zero = SKFS.IID(0);
      countName = makeCountName(this.dir.dirName);
      reducer = makeDir(Row::fromFile, context, countName, () -> {
        this.dir.contextWriterMap(
          Row::fromFile,
          context,
          countName,
          (_context, writer, _row) ~> {
            writer.write(zero, Row(Array[]));
          },
        )
      });
      elts = reducer.getArray(context, zero);
      acc = 0;
      for (_elt in elts) {
        !acc = acc + 1;
      };
      acc
    }
  */

  fun getCol(row: Row, colNumber: Int): SValue {
    values = row.values;
    if (colNumber < 0) error(this.pos, "Expected positive column number");
    if (colNumber >= values.size()) {
      error(this.pos, "column number out of bound")
    };
    values[colNumber]
  }
}
