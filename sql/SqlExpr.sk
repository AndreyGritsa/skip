/*****************************************************************************/
/* SQL expression evaluator. */
/*****************************************************************************/
module SKSQL;

fun btoi(b: Bool): Int {
  if (b) 1 else 0
}

fun errorEval<T>(msg: String): T {
  throw Error(0, msg);
}

base class ComparisonKind {
  children =
  | Lt()
  | Gt()
  | Gte()
  | Lte()
  | Eq()
  | Diff()
}

class ExprEvaluator(
  entries: Array<Row>,
  tables: Array<DirDescr>,
  up: ?ExprEvaluator,
) extends SKFS.FileName {
  static fun create(
    entries: Array<Row>,
    tablesHash: Int,
    tables: Array<DirDescr>,
    up: ?ExprEvaluator,
  ): this {
    result = static(entries, tables, up, 0);
    h1 = entries.hash();
    h2 = tablesHash;
    h3 = up match {
    | None() -> 0
    | Some(x) -> x.hashTag
    };
    result with {hashTag => SKFS.hashCombine(h1, SKFS.hashCombine(h2, h3))}
  }

  fun toString(): String {
    inspect(this).toString()
  }

  private fun evalCFExpr(
    context: mutable SKFS.Context,
    expr: SKSQL.CExpr<Float>,
  ): ?Float {
    expr match {
    | CFICast(e) -> this.evalCIExpr(context, e).flatMap(n -> Some(n.toFloat()))
    | CDiv(e1, e2) ->
      this.evalCFExpr(context, e1).flatMap(n1 ->
        this.evalCFExpr(context, e2).flatMap(n2 -> Some(n1 / n2))
      )

    | CEQuery(select) ->
      this.evalQuery(context, select) match {
      | None() -> None()
      | Some(CFloat(f)) -> Some(f)
      | e ->
        debug(e);
        invariant_violation("Unexpected value in iexpr")
      }
    | _ ->
      debug(expr);
      invariant_violation("TODO: rest of evalCFExpr")
    }
  }

  private fun evalCSExpr(
    _context: mutable SKFS.Context,
    expr: SKSQL.CExpr<String>,
  ): ?String {
    expr match {
    | CSLiteral(str) -> Some(str)
    | CSGetFrom(tableNbr, n) -> this.entries[tableNbr].getString(n)
    | _ ->
      debug(expr);
      invariant_violation("TODO: rest of evalCSExpr")
    }
  }

  fun evalCIExpr(context: mutable SKFS.Context, expr: SKSQL.CExpr<Int>): ?Int {
    expr match {
    | CISize(tableNbr) ->
      Some(context.getEagerDir(this.tables[tableNbr].dirName).size(context))
    | CIGetParam(_) -> invariant_violation("TODO CIGetParam")
    | CIGetFrom(tableNbr, n) -> this.entries[tableNbr].getInt(n)
    | CILiteral(n) -> Some(n)

    | CUp(x) ->
      this.up match {
      | None() -> invariant_violation("Could not find up environment")
      | Some(evaluator) -> evaluator.evalCIExpr(context, x)
      }

    | CNot(e) ->
      this.evalCIExpr(context, e) match {
      | None() -> Some(1)
      | Some(n) -> if (n == 0) Some(1) else Some(0)
      }
    | CLte(e1, e2) -> this.bopCompare(context, Lte(), e1, e2)
    | CLt(e1, e2) -> this.bopCompare(context, Lt(), e1, e2)
    | CGte(e1, e2) -> this.bopCompare(context, Gte(), e1, e2)
    | CGt(e1, e2) -> this.bopCompare(context, Gt(), e1, e2)
    | CEq(e1, e2) -> this.bopCompare(context, Eq(), e1, e2)
    | CDiff(e1, e2) -> this.bopCompare(context, Diff(), e1, e2)

    | CAdd(e1, e2) ->
      this.evalCIExpr(context, e1).flatMap(n1 ->
        this.evalCIExpr(context, e2).flatMap(n2 -> {
          Some(n1 + n2)
        })
      )
    | CSub(e1, e2) ->
      this.evalCIExpr(context, e1).flatMap(n1 ->
        this.evalCIExpr(context, e2).flatMap(n2 -> {
          Some(n1 - n2)
        })
      )
    | CMul(e1, e2) ->
      this.evalCIExpr(context, e1).flatMap(n1 ->
        this.evalCIExpr(context, e2).flatMap(n2 -> {
          Some(n1 * n2)
        })
      )
    | CDiv(e1, e2) ->
      this.evalCIExpr(context, e1).flatMap(n1 ->
        this.evalCIExpr(context, e2).flatMap(n2 -> {
          Some(n1 / n2)
        })
      )

    | CIf(conde, e1, e2) ->
      cond = this.evalCIExpr(context, conde) match {
      | None() -> false
      | Some(n) -> n != 0
      };
      if (cond) {
        this.evalCIExpr(context, e1)
      } else {
        this.evalCIExpr(context, e2)
      }

    | COr(e1, e2) ->
      this.evalCIExpr(context, e1) match {
      | None()
      | Some(0) ->
        this.evalCIExpr(context, e2).flatMap(n2 -> Some(btoi(n2 != 0))) match {
        | None() -> Some(0)
        | x -> x
        }
      | x -> x
      }

    | CAnd(e1, e2) ->
      this.evalCIExpr(context, e1) match {
      | None() -> Some(0)
      | x @ Some(0) -> x
      | Some _ ->
        this.evalCIExpr(context, e2).flatMap(n2 -> Some(btoi(n2 != 0)))
      }

    | CIAbs(n) ->
      this.evalCIExpr(context, n).flatMap(x -> Some(if (x < 0) -x else x))

    | CExists(select) ->
      evalSelect(context, select, Some(this)) match {
      | SelectDir(dirName, _) ->
        dir = context.getEagerDir(dirName);
        size = dir.size(context);
        Some(if (size > 0) 1 else 0)
      | SelectArray _ -> Some(1)
      | SelectError(exn) -> throw exn
      }

    | CCoalesce(el) ->
      for (e in el) {
        this.evalCIExpr(context, e) match {
        | None() -> continue
        | v @ Some(_) -> return v
        }
      };
      None()

    | CIIsNull(e) ->
      this.evalCIExpr(context, e) match {
      | None() -> Some(1)
      | Some _ -> Some(0)
      }

    | CFIsNull(e) ->
      this.evalCFExpr(context, e) match {
      | None() -> Some(1)
      | Some _ -> Some(0)
      }

    | CSIsNull(e) ->
      this.evalCSExpr(context, e) match {
      | None() -> Some(1)
      | Some _ -> Some(0)
      }

    | CEQuery(select) ->
      this.evalQuery(context, select) match {
      | None() -> None()
      | Some(CInt(n)) -> Some(n)
      | e ->
        debug(e);
        invariant_violation("Unexpected value in iexpr")
      }

    | CBetween(e1, e2, e3) ->
      this.bopCompare(context, Lte(), e2, e1).flatMap(n1 ->
        this.bopCompare(context, Lte(), e1, e3).flatMap(n2 ->
          Some(btoi(n1 != 0 && n2 != 0))
        )
      )

    | CNotBetween(e1, e2, e3) ->
      this.bopCompare(context, Lte(), e2, e1).flatMap(n1 ->
        this.bopCompare(context, Lte(), e1, e3).flatMap(n2 ->
          Some(btoi(n1 == 0 || n2 == 0))
        )
      )

    | CIn(v, set) ->
      for (elt in set) {
        this.bopCompare(context, Eq(), v, elt) match {
        | None()
        | Some(0) ->
          void
        | x -> break x
        }
      } else {
        Some(0)
      }
    }
  }

  private fun evalQuery(
    context: mutable SKFS.Context,
    select: CSelect,
  ): ?CValue {
    evalSelect(context, select, Some(this)) match {
    | SelectDir(dirName, types) ->
      dir = context.getEagerDir(dirName);
      size = dir.size(context);
      if (size == 0) {
        errorEval("SELECT used as value returns no value");
      };
      if (size > 1) {
        errorEval("SELECT used as value returns multiple values");
      };
      key = dir.keys().min().fromSome();
      files = dir.getArray(context, key);
      if (files.size() == 0) {
        errorEval("SELECT used as value returns no value");
      };
      if (files.size() > 1) {
        errorEval("SELECT used as value returns multiple values");
      };
      Row::fromFile(files[0]) match {
      | RowNone() -> errorEval("SELECT used as value returns no value")
      | RowRepeat(_, n) ->
        invariant(n > 1);
        errorEval("SELECT used as value returns multiple values")
      | err @ RowError _ -> throw err
      | row @ RowNullableValues _
      | row @ RowValues _ ->
        if (row.size() != 1) {
          errorEval("SELECT used as value returns multiple columns");
        };
        row.getValue(types[0], 0)
      | row @ RowKind _ ->
        debug(row);
        invariant_violation("RowKind should have been resolved")
      }
    | SelectArray(values, types) ->
      if (values.size() == 0) {
        errorEval("SELECT used as value returns no value");
      };
      if (values.size() > 1) {
        errorEval("SELECT used as value returns multiple values");
      };
      values.getValue(types[0], 0)
    | SelectError(exn) -> throw exn
    }
  }

  fun evalCGExpr(context: mutable SKFS.Context, e: SKSQL.CGExpr): ?CValue {
    result = e match {
    | CGNull() -> None()
    | CIExpr(ie) -> this.evalCIExpr(context, ie).map(x -> CInt(x))
    | CFExpr(fe) -> this.evalCFExpr(context, fe).map(x -> CFloat(x))
    | CSExpr(se) -> this.evalCSExpr(context, se).map(x -> CString(x))
    };
    result
  }

  fun bopCompare(
    context: mutable SKFS.Context,
    bop: ComparisonKind,
    ge1: CGExpr,
    ge2: CGExpr,
  ): ?Int {
    ge1 match {
    | CGNull() -> None()
    | CIExpr(ie1) ->
      ge2 match {
      | CGNull() -> None()
      | CIExpr(ie2) ->
        this.evalCIExpr(context, ie1).flatMap(n1 ->
          this.evalCIExpr(context, ie2).flatMap(n2 -> {
            Some(
              btoi(
                bop match {
                | Lt() -> n1 < n2
                | Lte() -> n1 <= n2
                | Gte() -> n1 >= n2
                | Gt() -> n1 > n2
                | Eq() -> n1 == n2
                | Diff() -> n1 != n2
                },
              ),
            )
          })
        )
      | CFExpr(fe2) ->
        this.evalCIExpr(context, ie1).flatMap(n1 ->
          this.evalCFExpr(context, fe2).flatMap(f2 -> {
            f1 = n1.toFloat();
            Some(
              btoi(
                bop match {
                | Lt() -> f1 < f2
                | Lte() -> f1 <= f2
                | Gte() -> f1 >= f2
                | Gt() -> f1 > f2
                | Eq() -> f1 == f2
                | Diff() -> f1 != f2
                },
              ),
            )
          })
        )
      | CSExpr _ -> invariant_violation("TODO: string comparison (I)")
      }
    | CFExpr(fe1) ->
      ge2 match {
      | CGNull() -> None()
      | CIExpr(ie2) ->
        this.evalCFExpr(context, fe1).flatMap(f1 ->
          this.evalCIExpr(context, ie2).flatMap(n2 -> {
            f2 = n2.toFloat();
            Some(
              btoi(
                bop match {
                | Lt() -> f1 < f2
                | Lte() -> f1 <= f2
                | Gte() -> f1 >= f2
                | Gt() -> f1 > f2
                | Eq() -> f1 == f2
                | Diff() -> f1 != f2
                },
              ),
            )
          })
        )
      | CFExpr(fe2) ->
        this.evalCFExpr(context, fe1).flatMap(f1 ->
          this.evalCFExpr(context, fe2).flatMap(f2 -> {
            Some(
              btoi(
                bop match {
                | Lt() -> f1 < f2
                | Lte() -> f1 <= f2
                | Gte() -> f1 >= f2
                | Gt() -> f1 > f2
                | Eq() -> f1 == f2
                | Diff() -> f1 != f2
                },
              ),
            )
          })
        )
      | CSExpr _ -> invariant_violation("TODO: string comparison (F)")
      }
    | CSExpr _ -> invariant_violation("TODO: string comparison")
    }
  }
}
