/*****************************************************************************/
/* Functions evaluating SQL. */
/*****************************************************************************/
module SKSQL;

const INSERT_BUCKET_SIZE: Int = 100000;

fun computeTableDescr(name: String, schema: Array<TypeDescr>): DirDescr {
  dirNameStr = "/" + name + "/";
  dirName = SKFS.DirName::create(dirNameStr);
  colVec = mutable Vector[];
  for (i in Range(0, schema.size())) {
    colVec.push((schema[i].name, i));
  };
  cols = Map::createFromItems(colVec);
  DirDescr{name, schema, cols, dirName}
}

fun computeInsert(
  pos: Int,
  paramsOpt: ?Array<String>,
  rawValues: InsertValues,
  table: DirDescr,
): Row {
  values = rawValues match {
  | IQuery _ ->
    invariant_violation("TODO: IQuery values in INSERT (SqlEval.sk)")
  | IValues(vals) -> vals
  };
  schemaSize = table.schema.size();
  valueSize = values.size();
  svalues = paramsOpt match {
  | None() ->
    if (valueSize != schemaSize) {
      error(pos, "Value size mismatch with table schema");
    };
    values
  | Some(params) ->
    paramSize = params.size();
    if (paramSize != valueSize) {
      error(pos, "Value size mismatch");
    };
    if (paramSize != schemaSize) {
      error(pos, "Value size mismatch with table schema");
    };
    size = schemaSize;
    cols = table.cols;
    result = Array<Value>::mfill(params.size(), VNull());
    for (i in Range(0, size)) {
      colName = params[i];
      if (!cols.containsKey(colName)) {
        error(pos, "Column not found: " + colName);
      };
      result![cols[colName]] = values[i];
    };
    unsafe_chill_trust_me(result)
  };
  Row::fromCValues(
    svalues.mapWithIndex((idx, val) -> {
      if (val is VNull _) return (None() : ?CValue);
      table.schema[idx].ty match {
      | INTEGER() ->
        val match {
        | VInt(n) -> Some(CInt(n))
        | _ -> error(pos, "Type mismatch")
        }
      | FLOAT() -> invariant_violation("TODO: insert FLOAT")
      | TEXT() ->
        val match {
        | VString(str) -> Some(CString(str))
        | _ -> error(pos, "Type mismatch")
        }
      }
    }),
  )
}

fun computeKinds(
  params: Array<CGExpr>,
  ekinds: Array<(Int, IKind)>,
): Array<(Int, IKind, Type)> {
  size = params.size();
  paramTypes = params.map(x -> x.getType());
  colSet = mutable Set[];
  ikinds = ekinds.map(eik -> {
    (colNumber, kind) = eik;
    !colNumber = colNumber - 1;
    if (colNumber < 0 || colNumber >= size) {
      errorEval("ORDER BY out of bounds");
    };
    if (colSet.contains(colNumber)) {
      errorEval("invalid ORDER by");
    };
    colSet.add(colNumber);
    (colNumber, kind)
  });
  computeOrder(paramTypes, ikinds)
}

fun computeOrder(
  paramTypes: Array<Type>,
  ikinds: Array<(Int, IKind)>,
): Array<(Int, IKind, Type)> {
  size = paramTypes.size();
  defaultKinds = Array<?(Int, SKSQL.IKind, SKSQL.Type)>::mfillBy(size, i ->
    Some((i, (INONE() : IKind), paramTypes[i]))
  );
  kinds = mutable Vector[];
  for (ik in ikinds) {
    (colNumber, kind) = ik;
    defaultKinds![colNumber] = None();
    kinds.push((colNumber, kind, paramTypes[colNumber]))
  };
  for (defaultKind in defaultKinds) {
    defaultKind match {
    | None() -> void
    | Some(k) -> kinds.push(k)
    }
  };
  kinds.toArray()
}

class EvaluatorSaved{
  idRoot: Int,
  tableCounters: SortedMap<String, Int>,
} extends SKFS.File

mutable class Evaluator{
  mutable idRoot: Int,
  mutable tableCounters: SortedMap<String, Int>,
} {
  readonly fun clone(): Evaluator {
    static{idRoot => this.idRoot, tableCounters => this.tableCounters}
  }

  static fun create(context: mutable SKFS.Context): mutable this {
    _ = getSelectOutputDir(context);
    _ = getSelectInputDir(context);
    _ = getTableDir(context);
    mutable Evaluator{idRoot => 0, tableCounters => SortedMap[]}
  }

  static fun fromSaved(saved: EvaluatorSaved): mutable this {
    mutable Evaluator{
      idRoot => saved.idRoot,
      tableCounters => saved.tableCounters,
    }
  }

  readonly fun save(): EvaluatorSaved {
    EvaluatorSaved{idRoot => this.idRoot, tableCounters => this.tableCounters}
  }

  mutable fun newKey(dirName: String): SKFS.BaseName {
    result = this.tableCounters[dirName];
    this.!tableCounters[dirName] = result + 1;
    SKFS.IID(result)
  }

  mutable fun stmtStr(
    context: mutable SKFS.Context,
    idRoot: Int,
    str: String,
  ): void {
    lex = SKSQL.Lexer(idRoot, Buffer(str));
    (_, stmtAst) = SKSQL.parseStmt(lex, 0);
    this.stmt(context, stmtAst)
  }

  mutable fun write(
    context: mutable SKFS.Context,
    dirName: SKFS.DirName,
    key: SKFS.BaseName,
    value: SKFS.File,
  ): void {
    context.getEagerDir(dirName).write(context, key, value);
  }

  mutable fun writeArray(
    context: mutable SKFS.Context,
    dirName: SKFS.DirName,
    key: SKFS.BaseName,
    values: Array<SKFS.File>,
  ): void {
    context.getEagerDir(dirName).writeArray(context, key, values);
  }

  mutable fun stmt(context: mutable SKFS.Context, stmt: Stmt): void {
    stmt match {
    | Table{name, schema} ->
      dirDescr = computeTableDescr(name, schema);
      this.createTable(context, name, dirDescr)
    | Insert{pos, name, paramsOpt, values} ->
      this.insert(context, pos, name, paramsOpt, values)
    | selectAst @ Select{} ->
      compiler = SKSQL.Compiler::create(selectAst.pos);
      select = compiler.compileSelect(context, selectAst);
      input = getSelectInputDir(context);
      this.write(context, input.dirName, SKFS.SID::create(select.id), select);
      context.update()
    | index @ Index _ ->
      input = getIndexInputDir(context);
      this.write(context, input.dirName, SKFS.SID::create(index.name), index);
      _ = getIndexOutputDir(context);
      context.update()
    | _ -> invariant_violation("TODO rest of stmt in SqlEval.sk")
    /*
      | View{name: String, query: Query}
      | Drop{kind: TableKind, name: String}
      | Delete{colName: ?String, name: String, where: ?Expr}
      | Update{name: String, sets: Array<(String, Expr)>, where: ?Expr}
      | Replace{name: String, values: InsertValues}
    */
    };
  }

  mutable fun insert(
    context: mutable SKFS.Context,
    pos: Int,
    name: String,
    paramsOpt: ?Array<String>,
    rawValues: InsertValues,
  ): void {
    baseName = SKFS.SID::create(name);
    table = getTable(context, pos, baseName);
    dir = getDir(table);
    key = this.newKey(name);
    row = computeInsert(pos, paramsOpt, rawValues, table);
    context.getEagerDir(dir.dirName).write(context, key, row);
  }

  mutable fun createTable(
    context: mutable SKFS.Context,
    name: String,
    dirDescr: DirDescr,
    init: Array<Row> = Array[],
  ): void {
    dirName = dirDescr.dirName;
    _ = context.mkdirCompressed(Row::fromFile, dirName, init, (idx, row) ~> {
      file: SKFS.File = row;
      key = SKFS.IID(idx);
      path = SKFS.Path::create(dirName, key);
      SKFS.FixedRow(key, (SKFS.Source::create(path), Array[file]))
    });
    tables = getTableDir(context);
    context
      .getEagerDir(tables.dirName)
      .write(context, SKFS.SID::create(name), dirDescr);
    this.!tableCounters[name] = 0;
    if (context.debugMode) {
      print_string("CREATED: " + name);
    };
  }
}

class EndOfFile() extends Exception

@cpp_export("SKIP_throw_EndOfFile")
fun throwEndOfFile(): void {
  throw EndOfFile()
}

@cpp_extern("SKIP_String_concatN")
native fun concatArray(Array<String>): String;

@cpp_extern("SKIP_read_file")
native fun read_file(String): String;

fun read(fileNameOpt: ?String): String {
  fileNameOpt match {
  | None() ->
    buffer = mutable Vector[];
    vtry(
      () ->
        loop {
          line = read_line();
          buffer.push(line);
          buffer.push("\n");
        },
      _endOfFile -> concatArray(buffer.toArray()),
    )
  | Some(fileName) -> read_file(fileName)
  }
}

fun getLine(buffer: Buffer, pos: Int): Int {
  line = 1;
  for (i in Range(0, pos)) {
    if (buffer[i] == '\n') {
      !line = line + 1;
    }
  };
  line
}

fun printErrorAndExit(buffer: Buffer, pos: Int, msg: String): void {
  leftSpaces = 0;
  cursor = 0;
  line = 0;
  !pos = min(buffer.size() - 1, pos);
  while (pos - cursor > 0) {
    if (buffer[pos - cursor] == '\n') {
      !line = line + 1;
      if (line == 1) {
        !leftSpaces = cursor;
      };
      if (line == 5) break void;
    };
    !cursor = cursor + 1
  };
  if (pos - leftSpaces < 0) {
    !leftSpaces = pos;
  };
  right = 0;
  while (pos + right < buffer.size() && buffer[pos + right] != '\n') {
    !right = right + 1
  };
  txtBegin = max(0, pos - cursor);
  txtEnd = min(buffer.size(), pos + right);
  print_error(buffer.slice(txtBegin, txtEnd));
  spaceBuffer = mutable Vector[];
  for (_ in Range(0, leftSpaces - 1)) spaceBuffer.push(' ');
  margin = String::fromChars(spaceBuffer.toArray());
  print_error(margin + "^");
  print_error(margin + "|");
  print_error(margin + " ----- ERROR");
  errLine = getLine(buffer, pos);
  charPos = `characters ${leftSpaces}-${leftSpaces}`;
  print_error(`File "", line ${errLine}, ${charPos}:`);
  print_error(msg);
  exit(2)
}

fun printRow(row: SKSQL.Row, types: Array<Type>): void {
  size = row.size();
  if (row is RowKind _) {
    invariant_violation("Cannot print a RowKind");
  };
  if (size == 1) {
    row.getValue(types[0], 0) match {
    | None() -> print_string("")
    | Some(v) -> print_string(v.toString())
    };
    return void;
  };
  for (i in Range(0, size - 1)) {
    row.getValue(types[i], i) match {
    | None() -> void
    | Some(v) -> print_raw(v.toString())
    };
    print_raw("|");
  };
  row.getValue(types[size - 1], size - 1) match {
  | None() -> print_string("")
  | Some(v) -> print_string(v.toString())
  }
}

fun showSelect(context: mutable SKFS.Context, select: Select): void {
  outputDir = getSelectOutputDir(context);
  outputDir.get(context, SKFS.SID::create(select.id)) match {
  | SelectDir(dirName, types) ->
    dir = context.getEagerDir(dirName);
    dir.onFiles(files ~> {
      for (kv in files) {
        (_, rows) = kv;
        for (row in rows) {
          row match {
          | RowNone() -> void
          | RowRepeat(r, n) ->
            for (_ in Range(0, n)) {
              printRow(r, types)
            }
          | r -> printRow(Row::fromFile(r), types)
          }
        }
      }
    })
  | SelectArray(row, types) -> printRow(row, types)
  | SelectError(err) -> print_string(err.msg)
  }
}

class EvalExnEnv(
  lex: Lexer,
  pos: Int,
  evaluator: EvaluatorSaved,
  inserts: SortedMap<String, (DirDescr, List<Vector<Row>>)>,
) extends SKFS.File

fun evalWithContext(context: mutable SKFS.Context, packInserts: Bool): Bool {
  env = context.getGlobal("EvalExnEnv").fromSome() match {
  | x @ EvalExnEnv _ -> x
  | _ -> invariant_violation("Wrong environement type")
  };
  lex = env.lex;
  pos = env.pos;

  if (isEOF(lex, pos)) return false;
  evaluator = Evaluator::fromSaved(env.evaluator);

  if (packInserts) {
    readStmt: ?Stmt = None();
    mtables: mutable Map<
      String,
      (DirDescr, mutable Vector<Row>),
    > = mutable Map[];
    for (tableName => data in env.inserts) {
      (dirDescr, _) = data;
      mtables![tableName] = (dirDescr, mutable Vector[]);
    };
    for (_ in Range(0, INSERT_BUCKET_SIZE)) {
      if (isEOF(lex, pos)) break void;
      (!pos, stmt) = parseStmt(lex, pos);
      stmt match {
      | table @ Table _ ->
        dirDescr = computeTableDescr(table.name, table.schema);
        mtables![table.name] = (dirDescr, mutable Vector[])
      | Insert{
        name,
        paramsOpt,
        values => rawValues,
      } if (mtables.containsKey(name)) ->
        (dirDescr, inserts) = mtables[name];
        row = computeInsert(pos, paramsOpt, rawValues, dirDescr);
        inserts.push(row)
      | _ ->
        !readStmt = Some(stmt);
        break void
      }
    };

    for (tableName => data in mtables) {
      (dirDescr, mrows) = data;
      rows = unsafe_chill_trust_me(mrows);
      env.inserts.maybeGet(tableName) match {
      | None() -> !env.inserts[tableName] = (dirDescr, List[rows])
      | Some((_, rowsList)) ->
        !rowsList = List.Cons(rows, rowsList);
        !env.inserts[tableName] = (dirDescr, rowsList)
      }
    };

    if (isEOF(lex, pos) || readStmt is Some _) {
      for (tableName => data in env.inserts) {
        (dirDescr, rowsList) = data;
        rows = rowsList.flatten().collect(Array);
        evaluator.createTable(context, tableName, dirDescr, rows);
        evaluator.!tableCounters[tableName] = rows.size();
      };
      !env.inserts = SortedMap[];
    };

    if (readStmt is Some _) {
      stmt = readStmt.fromSome();

      evaluator.stmt(context, stmt);

      stmt match {
      | select @ Select _ ->
        context.!deps = SKFS.Deps[];
        showSelect(context, select)
      | _ -> void
      };
    };
  } else {
    if (isEOF(lex, pos)) return false;
    (!pos, stmt) = parseStmt(lex, pos);

    evaluator.stmt(context, stmt);

    stmt match {
    | select @ Select _ ->
      context.!deps = SKFS.Deps[];
      showSelect(context, select)
    | _ -> void
    };
  };
  context.setGlobal(
    "EvalExnEnv",
    EvalExnEnv(lex, pos, evaluator.save(), env.inserts),
  );
  packInserts
}

fun setupContext(context: mutable SKFS.Context, buffer: Buffer): void {
  (evaluator, inserts) = context.getGlobal("EvalExnEnv") match {
  | None() -> (Evaluator::create(context).save(), SortedMap[])
  | Some(env @ EvalExnEnv _) -> (env.evaluator, env.inserts)
  | Some _ -> invariant_violation("EvalExnEnv has the wrong type")
  };
  context.!failOnExn = true;
  origEnv = EvalExnEnv(Lexer(0, buffer), 0, evaluator, inserts);
  context.setGlobal("EvalExnEnv", origEnv);
}

fun evalExn(buffer: Buffer, packInserts: Bool): mutable SKFS.Context {
  gcontext = mutable SKFS.Context{unsafeReuse => true};
  setupContext(gcontext, buffer);
  SKFS.disableGC();
  SKFS.runWithGcReturnContext(gcontext.clone(), icontext ~> {
    context = SKFS.Context::fromSaved(icontext);
    shouldContinue = false;
    /*    vtry(
          () -> {
    */
    !shouldContinue = evalWithContext(context, packInserts);
    /*      },
          err -> {
            err match {
            | Error(pos, str) -> printErrorAndExit(buffer, pos, str)
            | exn -> throw exn
            }
          },
        );
    */
    if (shouldContinue) Some(context.clone()) else {
      context.update();
      None()
    }
  })
}

fun extractSql(chars: Buffer): void {
  lex = Lexer(0, chars);
  pos = 0;
  while (!isEOF(lex, pos)) {
    (!pos, test) = parseTest(lex, pos);
    test match {
    | TestStmt{posBegin, posEnd}
    | TestQuery{posBegin, posEnd} ->
      print_string(chars.slice(posBegin, posEnd));
      print_string(";\n")
    | _ -> void
    }
  };
}

fun parseSql(buffer: Buffer): void {
  lex = Lexer(0, buffer);
  pos = 0;
  while (!isEOF(lex, pos)) {
    loc = SKFS.newObstack();
    (!pos, _) = parseStmt(lex, pos);
    SKFS.destroyObstack(loc);
  };
}

fun eval(args: Array<String>): mutable SKFS.Context {
  buffer = Buffer(read(if (args.size() > 1) Some(args[1]) else None()));
  //    context.!debugMode = true;
  _fileName = if (args.size() == 0) "" else args[args.size() - 1];
  //    print_string("ExceptionMode: " + exnMode);
  //    print_string("FileName: " + fileName);
  evalExn(buffer, true)
}
