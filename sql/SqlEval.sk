/*****************************************************************************/
/* Functions evaluating SQL. */
/*****************************************************************************/
module SKSQL;

fun computeTableDescr(name: String, schema: Array<TypeDescr>): DirDescr {
  dirNameStr = "/" + name + "/";
  dirName = SKFS.DirName::create(dirNameStr);
  colVec = mutable Vector[];
  for (i in Range(0, schema.size())) {
    colVec.push((schema[i].name, i));
  };
  cols = Map::createFromItems(colVec);
  DirDescr{name, schema, cols, dirName}
}

fun computeInsert(
  pos: Int,
  paramsOpt: ?Array<String>,
  rawValues: InsertValues,
  table: DirDescr,
): Row {
  values = rawValues match {
  | IQuery _ -> todo()
  | IValues(vals) ->
    vals.map(x ->
      x match {
      | VNull() -> SVNull()
      | VInt(n) -> SVInt(n)
      | VLShift(n1, n2) -> SVInt(n1.shl(n2))
      | VFloat(_, _) -> todo()
      | VString(str) -> SVString(str)
      }
    )
  };
  schemaSize = table.schema.size();
  valueSize = values.size();
  row = paramsOpt match {
  | None() ->
    if (valueSize != schemaSize) {
      error(pos, "Value size mismatch with table schema");
    };
    Row(values)
  | Some(params) ->
    paramSize = params.size();
    if (paramSize != valueSize) {
      error(pos, "Value size mismatch");
    };
    if (paramSize != schemaSize) {
      error(pos, "Value size mismatch with table schema");
    };
    size = schemaSize;
    cols = table.cols;
    result = Array<SValue>::mfill(params.size(), SVInt(0));
    for (i in Range(0, size)) {
      colName = params[i];
      if (!cols.containsKey(colName)) {
        error(pos, "Column not found: " + colName);
      };
      result![cols[colName]] = values[i];
    };
    Row(result.chill())
  };
  row
}

fun computeKinds(
  pos: Int,
  size: Int,
  ekinds: Array<(Expr, IKind)>,
): Array<(Int, IKind)> {
  processed = Array::mfill(size, false);
  kinds = mutable Vector[];
  for (eik in ekinds) {
    (e, ik) = eik;
    e match {
    | Literal(colNumberStr) ->
      for (digit in colNumberStr) {
        if (!Chars.isDigit(digit)) {
          error(pos, "Invalid column number in ORDER BY");
        }
      };
      colNumber = colNumberStr.toInt() - 1;
      if (colNumber >= size) {
        error(pos, "ORDER BY out of bounds");
      };
      kinds.push((colNumber, ik))
    | _ -> error(pos, "Invalid ORDER BY")
    }
  };
  for (i in Range(0, size)) {
    if (processed[i]) continue;
    kinds.push((i, INONE()));
  };
  kinds.toArray()
}

class EvaluatorSaved{
  idRoot: Int,
  tableCounters: SortedMap<String, Int>,
} extends SKFS.File

mutable class Evaluator{
  mutable idRoot: Int,
  context: mutable SKFS.Context,
  mutable tableCounters: SortedMap<String, Int>,
} {
  readonly fun clone(): Evaluator {
    static{
      idRoot => this.idRoot,
      context => this.context.clone(),
      tableCounters => this.tableCounters,
    }
  }

  static fun create(context: mutable SKFS.Context): mutable this {
    _ = getSelectOutputDir(context);
    _ = getSelectInputDir(context);
    _ = getTableDir(context);
    mutable Evaluator{idRoot => 0, context, tableCounters => SortedMap[]}
  }

  static fun fromSaved(
    context: mutable SKFS.Context,
    saved: EvaluatorSaved,
  ): mutable this {
    mutable Evaluator{
      context,
      idRoot => saved.idRoot,
      tableCounters => saved.tableCounters,
    }
  }

  readonly fun save(): EvaluatorSaved {
    EvaluatorSaved{idRoot => this.idRoot, tableCounters => this.tableCounters}
  }

  mutable fun newKey(dirName: String): SKFS.BaseName {
    result = this.tableCounters[dirName];
    this.!tableCounters[dirName] = result + 1;
    SKFS.IID(result)
  }

  mutable fun stmtStr(idRoot: Int, str: String): void {
    chars = str.chars().toArray();
    lex = SKSQL.Lexer(idRoot, chars);
    (_, stmtAst) = SKSQL.parseStmt(lex, 0);
    this.stmt(stmtAst)
  }

  mutable fun write(
    dirName: SKFS.DirName,
    key: SKFS.BaseName,
    value: SKFS.File,
  ): void {
    this.context.getDir2(dirName).write(this.context, key, value);
  }

  mutable fun writeArray(
    dirName: SKFS.DirName,
    key: SKFS.BaseName,
    values: Array<SKFS.File>,
  ): void {
    this.context.getDir2(dirName).writeArray(this.context, key, values);
  }

  mutable fun stmt(stmt: Stmt): void {
    stmt match {
    | Table{name, schema} ->
      dirDescr = computeTableDescr(name, schema);
      this.createTable(name, dirDescr)
    | Insert{pos, name, paramsOpt, values} ->
      this.insert(pos, name, paramsOpt, values)
    | select @ Select{} ->
      input = getSelectInputDir(this.context);
      this.write(input.dirName, SKFS.SID(select.id), select)
    | _ -> todo()
    /*
      | View{name: String, query: Query}
      | Drop{kind: TableKind, name: String}
      | Delete{colName: ?String, name: String, where: ?Expr}
      | Index{name: String, fields: (String, Array<(String, IKind)>)}
      | Update{name: String, sets: Array<(String, Expr)>, where: ?Expr}
      | Replace{name: String, values: InsertValues}
    */
    };
    this.context.update()
  }

  mutable fun insert(
    pos: Int,
    name: String,
    paramsOpt: ?Array<String>,
    rawValues: InsertValues,
  ): void {
    baseName = SKFS.SID(name);
    table = getTable(this.context, pos, baseName);
    dir = getDir(table);
    key = this.newKey(name);
    row = computeInsert(pos, paramsOpt, rawValues, table);
    this.context.getDir2(dir.dirName).write(this.context, key, row);
  }

  mutable fun createTable(
    name: String,
    dirDescr: DirDescr,
    init: Array<(SKFS.BaseName, Row)> = Array[],
  ): void {
    _ = this.context.mkdir(Row::fromFile, dirDescr.dirName, init);
    tables = getTableDir(this.context);
    this.context.getDir2(tables.dirName).write(
      this.context,
      SKFS.SID(name),
      dirDescr,
    );
    this.!tableCounters[name] = 0;
    if (this.context.debugMode) {
      print_string("CREATED: " + name);
    };
  }
}

class EndOfFile() extends Exception

@cpp_export("SKIP_throw_EndOfFile")
fun throwEndOfFile(): void {
  throw EndOfFile()
}

@cpp_extern("SKIP_String_concatN")
native fun concatArray(Array<String>): String;

fun read(): String {
  buffer = mutable Vector[];
  vtry(
    () ->
      loop {
        line = read_line();
        buffer.push(line);
        buffer.push("\n");
      },
    _endOfFile -> concatArray(buffer.toArray()),
  )
}

fun getLine(chars: Array<Char>, pos: Int): Int {
  line = 1;
  for (i in Range(0, pos)) {
    if (chars[i] == '\n') {
      !line = line + 1;
    }
  };
  line
}

fun printErrorAndExit(
  fileName: String,
  chars: Array<Char>,
  pos: Int,
  msg: String,
): void {
  leftSpaces = 0;
  cursor = 0;
  line = 0;
  !pos = min(chars.size() - 1, pos);
  while (pos - cursor > 0) {
    if (chars[pos - cursor] == '\n') {
      !line = line + 1;
      if (line == 1) {
        !leftSpaces = cursor;
      };
      if (line == 5) break void;
    };
    !cursor = cursor + 1
  };
  if (pos - leftSpaces < 0) {
    !leftSpaces = pos;
  };
  right = 0;
  while (pos + right < chars.size() && chars[pos + right] != '\n') {
    !right = right + 1
  };
  txtBegin = max(0, pos - cursor);
  txtEnd = min(chars.size(), pos + right);
  print_error(String::fromChars(chars.slice(txtBegin, txtEnd)));
  spaceBuffer = mutable Vector[];
  for (_ in Range(0, leftSpaces - 1)) spaceBuffer.push(' ');
  margin = String::fromChars(spaceBuffer.toArray());
  print_error(margin + "^");
  print_error(margin + "|");
  print_error(margin + " ----- ERROR");
  errLine = getLine(chars, pos);
  charPos = `characters ${leftSpaces}-${leftSpaces}`;
  print_error(`File "${fileName}", line ${errLine}, ${charPos}:`);
  print_error(msg);
  exit(2)
}

fun printRow(row: SKSQL.Row): void {
  values = row.values;
  size = values.size();
  if (size == 1) {
    print_string(values[0]);
    return void;
  };
  for (i in Range(0, size - 1)) {
    print_raw(values[i].toString());
    print_raw("|");
  };
  print_string(values[size - 1]);
}

fun showSelect(context: mutable SKFS.Context, select: Select): void {
  outputDir = getSelectOutputDir(context);
  dirName = outputDir.get(context, SKFS.SID(select.id));
  dir = context.getDir2(dirName);
  files = dir.files();
  for (file in files) {
    rows = dir.getArrayRaw(file);
    for (row in rows) {
      printRow(SKSQL.Row::fromFile(row));
    }
  }
}

class EvalExnEnv(
  lex: Lexer,
  pos: Int,
  evaluator: EvaluatorSaved,
) extends SKFS.File

fun compactInserts(
  table: Table,
  lex: Lexer,
  pos: Int,
  evaluator: mutable Evaluator,
): Int {
  i = 0;
  inserts = mutable Vector[];
  dirDescr = computeTableDescr(table.name, table.schema);
  loop {
    if (isEOF(lex, pos)) break void;
    posBefore = pos;
    (!pos, stmt) = parseStmt(lex, pos);
    stmt match {
    | Insert{name, paramsOpt, values => rawValues} if (name == table.name) ->
      key = SKFS.IID(i);
      row = computeInsert(pos, paramsOpt, rawValues, dirDescr);
      inserts.push((key, row));
      !i = i + 1
    | _ ->
      !pos = posBefore;
      break void
    }
  };
  evaluator.!tableCounters[table.name] = i;
  evaluator.createTable(table.name, dirDescr, inserts.toArray());
  pos
}

fun evalExn(gcontext: mutable SKFS.Context, chars: Array<Char>): void {
  gevaluator = Evaluator::create(gcontext);
  origEnv = EvalExnEnv(Lexer(0, chars), 0, gevaluator.save());
  gcontext.setGlobal("EvalExnEnv", origEnv);
  SKFS.runWithGc(gcontext.clone(), icontext ~> {
    context = SKFS.Context::fromSaved(icontext);
    env = context.getGlobal("EvalExnEnv").fromSome() match {
    | x @ EvalExnEnv _ -> x
    | _ -> invariant_violation("Wrong environement type")
    };
    lex = env.lex;
    pos = env.pos;
    evaluator = Evaluator::fromSaved(context, env.evaluator);
    (!pos, stmt) = parseStmt(lex, pos);
    stmt match {
    | table @ Table _ -> !pos = compactInserts(table, lex, pos, evaluator)
    | _ -> evaluator.stmt(stmt)
    };
    stmt match {
    | select @ Select _ ->
      showSelect(context, select);
      !context = SKFS.Context::fromSaved(icontext)
    | _ -> void
    };
    context.setGlobal("EvalExnEnv", EvalExnEnv(lex, pos, evaluator.save()));
    if (isEOF(lex, pos)) None() else Some(context.clone())
  })
}

fun extractSql(chars: Array<Char>): void {
  lex = Lexer(0, chars);
  pos = 0;
  while (!isEOF(lex, pos)) {
    (!pos, test) = parseTest(lex, pos);
    test match {
    | TestStmt{posBegin, posEnd}
    | TestQuery{posBegin, posEnd} ->
      print_string(String::fromChars(chars.slice(posBegin, posEnd)));
      print_string(";\n")
    | _ -> void
    }
  };
}

fun parseSql(chars: Array<Char>): void {
  lex = Lexer(0, chars);
  pos = 0;
  while (!isEOF(lex, pos)) {
    loc = SKFS.newObstack();
    (!pos, _) = parseStmt(lex, pos);
    SKFS.destroyObstack(loc);
  };
}

fun eval(args: Array<String>): mutable SKFS.Context {
  txt = read();
  SKFS.run(context ~> {
    //    context.!debugMode = true;
    context.!failOnExn = true;
    exnMode = args.contains("--backtrace");
    if (args.contains("--extract-sql")) {
      extractSql(txt.chars().toArray());
      return void;
    };
    fileName = if (args.size() == 0) "" else args[args.size() - 1];
    //    print_string("ExceptionMode: " + exnMode);
    //    print_string("FileName: " + fileName);
    chars = txt.chars().toArray();
    if (exnMode) evalExn(context, chars) else {
      context.vtry(
        () -> evalExn(context, chars),
        e ->
          e match {
          | Error(pos, msg) ->
            printErrorAndExit(fileName, chars, pos, msg);
            invariant_violation("Unreachable")
          | exn -> throw (exn)
          }
        ,
      )
    }
  });
}
