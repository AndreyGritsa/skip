/*****************************************************************************/
/* Functions evaluating SQL. */
/*****************************************************************************/
module SKSQL;

const INSERT_BUCKET_SIZE: Int = 100000;

fun computeTableDescr(name: String, schema: Array<TypeDescr>): DirDescr {
  dirNameStr = "/" + name + "/";
  dirName = SKFS.DirName::create(dirNameStr);
  colVec = mutable Vector[];
  for (i in Range(0, schema.size())) {
    colVec.push((schema[i].name, i));
  };
  cols = Map::createFromItems(colVec);
  DirDescr{name, schema, cols, dirName}
}

fun computeInsert(
  pos: Int,
  paramsOpt: ?Array<String>,
  rawValues: InsertValues,
  table: DirDescr,
): Buffer {
  values = rawValues match {
  | IQuery _ -> todo()
  | IValues(vals) ->
    vals.map(x ->
      x match {
      | VNull() -> SVNull()
      | VInt(n) -> SVInt(n)
      | VLShift(n1, n2) -> SVInt(n1.shl(n2))
      | VFloat(_, _) -> todo()
      | VString(str) -> SVString(str)
      }
    )
  };
  schemaSize = table.schema.size();
  valueSize = values.size();
  row = paramsOpt match {
  | None() ->
    if (valueSize != schemaSize) {
      error(pos, "Value size mismatch with table schema");
    };
    values
  | Some(params) ->
    paramSize = params.size();
    if (paramSize != valueSize) {
      error(pos, "Value size mismatch");
    };
    if (paramSize != schemaSize) {
      error(pos, "Value size mismatch with table schema");
    };
    size = schemaSize;
    cols = table.cols;
    result = Array<SValue>::mfill(params.size(), SVInt(0));
    for (i in Range(0, size)) {
      colName = params[i];
      if (!cols.containsKey(colName)) {
        error(pos, "Column not found: " + colName);
      };
      result![cols[colName]] = values[i];
    };
    result.chill()
  };
  compress(row)
}

fun computeKinds(
  pos: Int,
  size: Int,
  ekinds: Array<(Expr, IKind)>,
): Array<(Int, IKind)> {
  processed = Array::mfill(size, false);
  kinds = mutable Vector[];
  for (eik in ekinds) {
    (e, ik) = eik;
    e match {
    | Literal(colNumberStr) ->
      for (digit in colNumberStr) {
        if (!Chars.isDigit(digit)) {
          error(pos, "Invalid column number in ORDER BY");
        }
      };
      colNumber = colNumberStr.toInt() - 1;
      if (colNumber >= size) {
        error(pos, "ORDER BY out of bounds");
      };
      kinds.push((colNumber, ik))
    | _ -> error(pos, "Invalid ORDER BY")
    }
  };
  for (i in Range(0, size)) {
    if (processed[i]) continue;
    kinds.push((i, INONE()));
  };
  kinds.toArray()
}

class EvaluatorSaved{
  idRoot: Int,
  tableCounters: SortedMap<String, Int>,
} extends SKFS.File

mutable class Evaluator{
  mutable idRoot: Int,
  context: mutable SKFS.Context,
  mutable tableCounters: SortedMap<String, Int>,
} {
  readonly fun clone(): Evaluator {
    static{
      idRoot => this.idRoot,
      context => this.context.clone(),
      tableCounters => this.tableCounters,
    }
  }

  static fun create(context: mutable SKFS.Context): mutable this {
    _ = getSelectOutputDir(context);
    _ = getSelectInputDir(context);
    _ = getTableDir(context);
    mutable Evaluator{idRoot => 0, context, tableCounters => SortedMap[]}
  }

  static fun fromSaved(
    context: mutable SKFS.Context,
    saved: EvaluatorSaved,
  ): mutable this {
    mutable Evaluator{
      context,
      idRoot => saved.idRoot,
      tableCounters => saved.tableCounters,
    }
  }

  readonly fun save(): EvaluatorSaved {
    EvaluatorSaved{idRoot => this.idRoot, tableCounters => this.tableCounters}
  }

  mutable fun newKey(dirName: String): SKFS.BaseName {
    result = this.tableCounters[dirName];
    this.!tableCounters[dirName] = result + 1;
    SKFS.IID(result)
  }

  mutable fun stmtStr(idRoot: Int, str: String): void {
    lex = SKSQL.Lexer(idRoot, Buffer(str));
    (_, stmtAst) = SKSQL.parseStmt(lex, 0);
    this.stmt(stmtAst)
  }

  mutable fun write(
    dirName: SKFS.DirName,
    key: SKFS.BaseName,
    value: SKFS.File,
  ): void {
    this.context.getEagerDir(dirName).write(this.context, key, value);
  }

  mutable fun writeArray(
    dirName: SKFS.DirName,
    key: SKFS.BaseName,
    values: Array<SKFS.File>,
  ): void {
    this.context.getEagerDir(dirName).writeArray(this.context, key, values);
  }

  mutable fun stmt(stmt: Stmt): void {
    stmt match {
    | Table{name, schema} ->
      dirDescr = computeTableDescr(name, schema);
      this.createTable(name, dirDescr)
    | Insert{pos, name, paramsOpt, values} ->
      this.insert(pos, name, paramsOpt, values)
    | select @ Select{} ->
      input = getSelectInputDir(this.context);
      this.write(input.dirName, SKFS.SID::create(select.id), select)
    | _ -> todo()
    /*
      | View{name: String, query: Query}
      | Drop{kind: TableKind, name: String}
      | Delete{colName: ?String, name: String, where: ?Expr}
      | Index{name: String, fields: (String, Array<(String, IKind)>)}
      | Update{name: String, sets: Array<(String, Expr)>, where: ?Expr}
      | Replace{name: String, values: InsertValues}
    */
    };
    this.context.update()
  }

  mutable fun insert(
    pos: Int,
    name: String,
    paramsOpt: ?Array<String>,
    rawValues: InsertValues,
  ): void {
    baseName = SKFS.SID::create(name);
    table = getTable(this.context, pos, baseName);
    dir = getDir(table);
    key = this.newKey(name);
    row = Row(decompress(computeInsert(pos, paramsOpt, rawValues, table)));
    this.context.getEagerDir(dir.dirName).write(this.context, key, row);
  }

  mutable fun createTable(
    name: String,
    dirDescr: DirDescr,
    init: Array<Buffer> = Array[],
  ): void {
    dirName = dirDescr.dirName;
    _ = this.context.mkdirCompressed(
      Row::fromFile,
      dirName,
      init,
      (idx, values) ~> {
        row: SKFS.File = Row(decompress(values));
        key = SKFS.IID(idx);
        path = SKFS.Path::create(dirName, key);
        SKFS.FixedRow(key, (path, Array[row]))
      },
    );
    tables = getTableDir(this.context);
    this.context.getEagerDir(tables.dirName).write(
      this.context,
      SKFS.SID::create(name),
      dirDescr,
    );
    this.!tableCounters[name] = 0;
    if (this.context.debugMode) {
      print_string("CREATED: " + name);
    };
  }
}

class EndOfFile() extends Exception

@cpp_export("SKIP_throw_EndOfFile")
fun throwEndOfFile(): void {
  throw EndOfFile()
}

@cpp_extern("SKIP_String_concatN")
native fun concatArray(Array<String>): String;

fun read(): String {
  buffer = mutable Vector[];
  vtry(
    () ->
      loop {
        line = read_line();
        buffer.push(line);
        buffer.push("\n");
      },
    _endOfFile -> concatArray(buffer.toArray()),
  )
}

fun getLine(buffer: Buffer, pos: Int): Int {
  line = 1;
  for (i in Range(0, pos)) {
    if (buffer[i] == '\n') {
      !line = line + 1;
    }
  };
  line
}

fun printErrorAndExit(
  fileName: String,
  buffer: Buffer,
  pos: Int,
  msg: String,
): void {
  leftSpaces = 0;
  cursor = 0;
  line = 0;
  !pos = min(buffer.size() - 1, pos);
  while (pos - cursor > 0) {
    if (buffer[pos - cursor] == '\n') {
      !line = line + 1;
      if (line == 1) {
        !leftSpaces = cursor;
      };
      if (line == 5) break void;
    };
    !cursor = cursor + 1
  };
  if (pos - leftSpaces < 0) {
    !leftSpaces = pos;
  };
  right = 0;
  while (pos + right < buffer.size() && buffer[pos + right] != '\n') {
    !right = right + 1
  };
  txtBegin = max(0, pos - cursor);
  txtEnd = min(buffer.size(), pos + right);
  print_error(buffer.slice(txtBegin, txtEnd));
  spaceBuffer = mutable Vector[];
  for (_ in Range(0, leftSpaces - 1)) spaceBuffer.push(' ');
  margin = String::fromChars(spaceBuffer.toArray());
  print_error(margin + "^");
  print_error(margin + "|");
  print_error(margin + " ----- ERROR");
  errLine = getLine(buffer, pos);
  charPos = `characters ${leftSpaces}-${leftSpaces}`;
  print_error(`File "${fileName}", line ${errLine}, ${charPos}:`);
  print_error(msg);
  exit(2)
}

fun printRow(row: SKSQL.Row): void {
  values = row.values;
  size = values.size();
  if (size == 1) {
    print_string(values[0]);
    return void;
  };
  for (i in Range(0, size - 1)) {
    print_raw(values[i].toString());
    print_raw("|");
  };
  print_string(values[size - 1]);
}

fun showSelect(context: mutable SKFS.Context, select: Select): void {
  outputDir = getSelectOutputDir(context);
  dirName = outputDir.get(context, SKFS.SID::create(select.id));
  dir = context.getEagerDir(dirName);
  dir.onFiles(files ~> {
    for (kv in files) {
      (_, rows) = kv;
      for (row in rows) {
        printRow(SKSQL.Row::fromFile(row));
      }
    }
  })
}

class EvalExnEnv(
  lex: Lexer,
  pos: Int,
  evaluator: EvaluatorSaved,
  inserts: SortedMap<String, (DirDescr, List<Vector<Buffer>>)>,
) extends SKFS.File

fun evalExn(gcontext: mutable SKFS.Context, buffer: Buffer): void {
  gevaluator = Evaluator::create(gcontext);
  origEnv = EvalExnEnv(Lexer(0, buffer), 0, gevaluator.save(), SortedMap[]);
  gcontext.setGlobal("EvalExnEnv", origEnv);
  SKFS.runWithGc(gcontext.clone(), icontext ~> {
    context = SKFS.Context::fromSaved(icontext);
    env = context.getGlobal("EvalExnEnv").fromSome() match {
    | x @ EvalExnEnv _ -> x
    | _ -> invariant_violation("Wrong environement type")
    };
    lex = env.lex;
    pos = env.pos;
    readStmt: ?Stmt = None();
    if (isEOF(lex, pos)) return None();
    evaluator = Evaluator::fromSaved(context, env.evaluator);
    mtables: mutable Map<
      String,
      (DirDescr, mutable Vector<Buffer>),
    > = mutable Map[];
    for (tableName => data in env.inserts) {
      (dirDescr, _) = data;
      mtables![tableName] = (dirDescr, mutable Vector[]);
    };
    for (_ in Range(0, INSERT_BUCKET_SIZE)) {
      if (isEOF(lex, pos)) break void;
      (!pos, stmt) = parseStmt(lex, pos);
      stmt match {
      | table @ Table _ ->
        dirDescr = computeTableDescr(table.name, table.schema);
        mtables![table.name] = (dirDescr, mutable Vector[])
      | Insert{
        name,
        paramsOpt,
        values => rawValues,
      } if (mtables.containsKey(name)) ->
        (dirDescr, inserts) = mtables[name];
        row = computeInsert(pos, paramsOpt, rawValues, dirDescr);
        inserts.push(row)
      | _ ->
        !readStmt = Some(stmt);
        break void
      }
    };

    for (tableName => data in mtables) {
      (dirDescr, mrows) = data;
      rows = unsafe_chill_trust_me(mrows);
      env.inserts.maybeGet(tableName) match {
      | None() -> !env.inserts[tableName] = (dirDescr, List[rows])
      | Some((_, rowsList)) ->
        !rowsList = List.Cons(rows, rowsList);
        !env.inserts[tableName] = (dirDescr, rowsList)
      }
    };

    if (isEOF(lex, pos) || readStmt is Some _) {
      for (tableName => data in env.inserts) {
        (dirDescr, rowsList) = data;
        rows = rowsList.flatten().collect(Array);
        evaluator.createTable(tableName, dirDescr, rows);
        evaluator.!tableCounters[tableName] = rows.size();
      };
      !env.inserts = SortedMap[];
    };

    readStmt match {
    | None() -> void
    | Some(stmt) ->
      evaluator.stmt(stmt);

      stmt match {
      | select @ Select _ -> showSelect(context, select)
      | _ -> void
      }
    };
    //    !context = SKFS.Context::fromSaved(icontext);
    context.setGlobal(
      "EvalExnEnv",
      EvalExnEnv(lex, pos, evaluator.save(), env.inserts),
    );
    Some(context.clone())
  })
}

fun extractSql(chars: Buffer): void {
  lex = Lexer(0, chars);
  pos = 0;
  while (!isEOF(lex, pos)) {
    (!pos, test) = parseTest(lex, pos);
    test match {
    | TestStmt{posBegin, posEnd}
    | TestQuery{posBegin, posEnd} ->
      print_string(chars.slice(posBegin, posEnd));
      print_string(";\n")
    | _ -> void
    }
  };
}

fun parseSql(buffer: Buffer): void {
  lex = Lexer(0, buffer);
  pos = 0;
  while (!isEOF(lex, pos)) {
    loc = SKFS.newObstack();
    (!pos, _) = parseStmt(lex, pos);
    SKFS.destroyObstack(loc);
  };
}

fun eval(args: Array<String>): mutable SKFS.Context {
  buffer = Buffer(read());
  SKFS.run(context ~> {
    //    context.!debugMode = true;
    context.!failOnExn = true;
    if (args.contains("--extract-sql")) {
      extractSql(buffer);
      return void;
    };
    _fileName = if (args.size() == 0) "" else args[args.size() - 1];
    //    print_string("ExceptionMode: " + exnMode);
    //    print_string("FileName: " + fileName);
    evalExn(context, buffer)
  });
}
