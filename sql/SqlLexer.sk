module SKSQL;

@cpp_extern("SKIP_String_unsafe_get")
native fun stringUnsafeGet(str: String, idx: Int): Char;

@cpp_extern("SKIP_String_unsafe_get")
native fun stringUnsafeGetInt(str: String, idx: Int): UInt32;

@cpp_extern("SKIP_String_unsafe_set")
native fun stringUnsafeSet(str: String, idx: Int, Int): void;

@cpp_extern("SKIP_String_unsafe_write_int")
native fun stringUnsafeWriteInt(str: String, idx: Int, Int): void;

@cpp_extern("SKIP_String_unsafe_write_string")
native fun stringUnsafeWriteString(str: String, idx: Int, String): void;

@cpp_extern("SKIP_String_unsafe_read_int")
native fun stringUnsafeReadInt(str: String, idx: Int): Int;

@cpp_extern("SKIP_String_unsafe_read_string")
native fun stringUnsafeReadString(str: String, idx: Int, Int): String;

@cpp_extern("SKIP_String_unsafe_size")
native fun stringUnsafeSize(str: String): Int;

@cpp_extern("SKIP_String_unsafe_slice")
native fun stringUnsafeSlice(str: String, Int, Int): String;

@cpp_extern("SKIP_String_unsafe_create")
native fun stringUnsafeCreate(Int): String;

mutable class Buffer(content: String) {
  static fun create(size: Int): mutable this {
    mutable Buffer(stringUnsafeCreate(size))
  }

  readonly fun get(idx: Int): Char {
    stringUnsafeGet(this.content, idx)
  }

  readonly fun getInt(idx: Int): Int {
    stringUnsafeGetInt(this.content, idx).toInt()
  }

  readonly fun size(): Int {
    stringUnsafeSize(this.content)
  }

  readonly fun slice(n1: Int, n2: Int): String {
    stringUnsafeSlice(this.content, n1, n2)
  }

  mutable fun set(n: Int, v: Int): void {
    stringUnsafeSet(this.content, n, v)
  }

  mutable fun writeInt(n: Int, v: Int): void {
    stringUnsafeWriteInt(this.content, n, v)
  }

  mutable fun writeString(n: Int, str: String): void {
    stringUnsafeWriteString(this.content, n, str)
  }

  readonly fun readInt(n: Int): Int {
    stringUnsafeReadInt(this.content, n)
  }

  readonly fun readString(n: Int, size: Int): String {
    stringUnsafeReadString(this.content, n, size)
  }
}

class Lexer(idRoot: Int, content: Buffer) {
  fun next(pos: Int): (Int, Token) {
    tok = this.token(pos);
    (tok.posEnd, tok)
  }

  fun skipSpaces(pos: Int): Int {
    // skip whitespaces
    loop {
      if (pos >= this.content.size()) {
        return pos;
      };
      currentChar = this.content[pos];
      currentChar match {
      | ' ' | '\n' | '\r' ->
        !pos = pos + 1;
        continue
      | '#' ->
        while (pos < this.content.size() && this.content[pos] != '\n') {
          !pos = pos + 1;
        };
        continue
      | _ -> break void
      }
    };
    pos
  }

  fun token(posBegin: Int, size: Int = this.content.size()): Token {
    !size = min(size, this.content.size());
    !posBegin = this.skipSpaces(posBegin);
    pos = posBegin;
    if (pos >= this.content.size()) {
      error(this.content.size() - 1, "Unexpected end of file");
    };
    !posBegin = pos;
    currentChar = this.content[pos];
    !pos = pos + 1;
    currentChar match {
    | _ if (pos >= this.content.size()) -> void
    | _ if (Chars.isDigit(currentChar)) ->
      while (pos < size && Chars.isDigit(this.content[pos])) {
        !pos = pos + 1
      }
    | _ if (isLetter(currentChar)) ->
      while (pos < size && isLetterOrDigit(this.content[pos])) {
        !pos = pos + 1
      }
    | _ -> void
    };
    posEnd = pos;
    Token(posBegin, posEnd)
  }

  fun isEqAtF(token: Token, str: String, f: Char ~> Char): Bool {
    strIter = str.getIter();
    for (pos in Range(token.posBegin, token.posEnd)) {
      c1 = this.content[pos];
      strIter.next() match {
      | Some(c2) if (f(c1) == f(c2)) -> continue
      | _ -> return false
      }
    };
    strIter.atEnd()
  }

  fun isEqAt(token: Token, str: String): Bool {
    this.isEqAtF(token, str, x ~> x)
  }

  fun isEqUpperAt(token: Token, str: String): Bool {
    this.isEqAtF(token, str, x ~> x.capitalize())
  }

  fun isEq(pos: Int, str: String): Bool {
    !pos = this.skipSpaces(pos);
    if (pos >= this.content.size()) return false;
    this.isEqAt(this.token(pos), str)
  }

  fun isKeyword(pos: Int): Bool {
    !pos = this.skipSpaces(pos);
    if (pos >= this.content.size()) return false;
    isKeyword(this.word(pos))
  }

  fun isEqUpper(pos: Int, str: String): Bool {
    !pos = this.skipSpaces(pos);
    if (pos >= this.content.size()) return false;
    this.isEqUpperAt(this.token(pos), str)
  }

  fun expect(pos: Int, str: String): Int {
    (!pos, tok) = this.next(pos);
    if (!this.isEqAt(tok, str)) {
      word = this.wordAt(tok);
      error(
        tok.posBegin,
        "Expected token: '" + str + "' found '" + word + "' instead",
      );
    };
    pos
  }

  fun expectUpper(pos: Int, str: String): Int {
    (!pos, tok) = this.next(pos);
    if (!this.isEqUpperAt(tok, str)) {
      word = this.wordAt(tok);
      error(
        tok.posBegin,
        "Expected token: '" + str + "' found '" + word + "' instead",
      );
    };
    pos
  }

  fun word(pos: Int): String {
    tok = this.token(pos);
    this.wordAt(tok)
  }

  fun nextWord(pos: Int): (Int, String) {
    (!pos, tok) = this.next(pos);
    (pos, this.wordAt(tok));
  }

  fun wordAt(tok: Token): String {
    this.content.slice(tok.posBegin, tok.posEnd)
  }

  fun nextInt(pos: Int): (Int, Int) {
    (!pos, str) = this.nextWord(pos);
    vtry(
      () -> (pos, str.toInt()),
      _ -> error(pos, "Expected integer, found: " + str),
    )
  }
}
