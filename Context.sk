module SKFS;

class StringFile(value: .String) extends File

class DirAlreadyExists(dirName: DirName) extends Exception {
  fun toString(): String {
    `Directory ${this.dirName} already exists`
  }
}

fun start<T>(f: (mutable Context) -> T): (mutable Context, T) {
  context = mutable Context{};
  result = f(context);
  context.updateFixedDeps();
  (context, result)
}

fun run(f: (mutable Context) -> void): mutable Context {
  context = mutable Context{};
  f(context);
  context.updateFixedDeps();
  context
}

mutable class Context{
  mutable dirs: Dirs = Dirs{},
  mutable lazyVisitedList: List<Path> = List[],
  mutable lazyVisitedSet: SortedSet<Path> = SortedSet[],
  mutable reads: mutable Vector<Path> = mutable Vector[],
  mutable time: Int = 0,
  mutable tick: Int = 0,
  mutable toUpdate: SortedMap<Int, DirName> = SortedMap[],
  mutable deps: List<Vector<(Path, DirName, DirName, BaseName)>> = List[],
  mutable fixedDeps: Map<Path, Set<(DirName, DirName, BaseName)>> = Map[],
  mutable newDeps: SortedMap<
    Path,
    SortedSet<(DirName, DirName, BaseName)>,
  > = SortedMap[],
  mutable debugMode: Bool = true,
  mutable hasPre: SortedSet<DirName> = SortedSet[],
  mutable hasNext: SortedSet<DirName> = SortedSet[],
  mutable newDirs: SortedSet<DirName> = SortedSet[],
} {
  mutable fun getReads(): Vector<Path> {
    reads = freeze(this.reads);
    this.reads.clear();
    reads
  }

  readonly fun getDeps(path: Path): Set<(DirName, DirName, BaseName)> {
    set = if (!this.fixedDeps.containsKey(path)) {
      Set[]
    } else {
      this.fixedDeps[path]
    };
    this.newDeps.maybeGet(path) match {
    | None() -> set
    | Some(newDeps) ->
      mset = Set::mcreateFromItems(set);
      for (dep in newDeps) {
        mset.insert(dep);
      };
      freeze(mset)
    }
  }

  readonly fun debug(pathStr: String): void {
    print_string("Debug " + pathStr + ":");
    path = Path::fromString(pathStr);
    this.dirs.maybeGet(path.dirName) match {
    | None() -> print_string("Directory does not exist")
    | Some(dir) ->
      values = dir.getArrayRaw(path.baseName);
      debug(values)
    }
  }

  readonly fun getValue(pathStr: String): Array<File> {
    path = Path::fromString(pathStr);
    dir = this.dirs[path.dirName];
    values = dir.getArrayRaw(path.baseName);
    values
  }

  mutable fun updateFixedDeps(): void {
    fixedDeps = mutable Map[];
    invariant(this.fixedDeps.isEmpty());
    for (depVector in this.deps) {
      for (read in depVector) {
        (path, sourceDir, targetDir, baseName) = read;
        if (!fixedDeps.containsKey(path)) {
          fixedDeps![path] = mutable Set[];
        };
        fixedDeps[path].add((sourceDir, targetDir, baseName));
      }
    };
    this.!deps = List[];
    this.!fixedDeps = freeze(fixedDeps);
  }

  mutable fun updateNewDeps(): void {
    for (depVector in this.deps) {
      for (read in depVector) {
        (path, sourceDir, targetDir, baseName) = read;
        reader = (sourceDir, targetDir, baseName);
        if (this.fixedDeps.containsKey(path)) {
          if (this.fixedDeps[path].contains(reader)) {
            continue;
          };
        };
        if (!this.newDeps.containsKey(path)) {
          !this.newDeps[path] = SortedSet[];
        };
        !this.newDeps[path] = this.newDeps[path].add(reader);
      }
    };
    this.!deps = List[];
  }

  mutable fun update(): void {
    this.updateNewDeps();

    dirs = this.dirs;

    for (dirName in this.hasPre) {
      preDirName = dirName.pre();
      dir = dirs.get(dirName);
      preDir = dirs.maybeGet(preDirName) match {
      | None() ->
        this.!newDirs = this.newDirs.add(preDirName);
        preDir = Dir{
          time => this.timeStamp(),
          isInput => false,
          dirName => preDirName,
          fixedData => FixedData{dirName => preDirName, data => Array[]},
        };
        this.setDir(preDirName, preDir);
        preDir
      | Some(preDir) -> preDir
      };
      for (kv in dir.data.getChangesAfter(this.tick - 1)) {
        (key, _) = kv;
        values = dir.getArrayRaw(key);
        _ = preDir.writeEntry(this, Path(preDir.dirName, key), key, values);
      }
    };

    loop {
      this.toUpdate.minimum() match {
      | None() -> return void
      | Some((time, dirName)) ->
        this.!toUpdate = this.toUpdate.remove(time);
        dir = this.getDir(dirName);
        dir.update(this)
      }
    };
  }

  mutable fun timeStamp(): Int {
    this.!time = this.time + 1;
    this.time
  }

  mutable fun mkdir<T: File>(
    conv: File ~> T,
    dirNameStr: String,
    content: Array<(BaseName, T)> = Array[],
  ): Handle<T> {
    dir = this.mkdirMulti(
      dirNameStr,
      content.map(kv -> {
        (key, value) = kv;
        (key, Array[value])
      }),
    );
    this.!newDirs = this.newDirs.add(dir.dirName);
    this.setDir(dir.dirName, dir);
    Handle(conv, dir.dirName)
  }

  mutable fun mkdirMulti<T: File>(
    dirNameStr: String,
    content: Array<(BaseName, Array<T>)> = Array[],
  ): Dir {
    dirName = DirName::create(dirNameStr);
    if (this.dirs.state.containsKey(dirName)) {
      throw DirAlreadyExists(dirName);
    };
    vector = mutable Vector[];
    for (kv in content) {
      (key, values) = kv;
      path = Path(dirName, key);
      vector.push(FixedRow(key, (path, values.map(x -> (x : File)))));
    };
    vector.sort();
    fixedData = FixedData{dirName, data => vector.toArray()};
    dir = Dir{time => this.timeStamp(), isInput => true, dirName, fixedData};
    this.!dirs = this.dirs.set(dir.time, dirName, dir);
    dir
  }

  mutable fun setDir(dirName: DirName, dir: Dir): void {
    this.!dirs = this.dirs.set(dir.time, dirName, dir);
  }

  readonly fun getDir(dirName: DirName): Dir {
    this.dirs.get(dirName);
  }

  mutable fun removeDir(dirName: DirName): void {
    dir = this.getDir(dirName);
    for (childName in dir.childDirs) {
      this.removeDir(childName);
    };
    if (this.debugMode) {
      print_string("REMOVED: " + dirName);
    };
    this.setDir(
      dirName,
      Dir{
        time => this.timeStamp(),
        dirName => dirName,
        isInput => false,
        fixedData => FixedData::empty(dirName),
      },
    );
  }

  readonly fun maybeGetDir<T: File>(dirName: DirName): ?Dir {
    this.dirs.maybeGet(freeze(dirName));
  }

  mutable fun addDep(path: Path): void {
    this.reads.push(path)
  }
}

class Dirs{state: DMap<DirName, Dir> = DMap::empty()} {
  fun set<T: File>(time: Int, key: DirName, value: Dir): this {
    !this.state = this.state.set(time, key, value);
    this
  }
  fun maybeGet(key: DirName): ?Dir {
    this.state.maybeGet(key)
  }
  fun get(key: DirName): Dir {
    this.maybeGet(key) match {
    | None() -> invariant_violation("Directory not found: " + key)
    | Some(x) -> x
    }
  }
}

module end;
