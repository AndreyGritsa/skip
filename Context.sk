/*****************************************************************************/
/* File defining the context.
 *
 * The context is almost always mutable (unless it is copied to the shared
 * heap).
 *
 * It keeps track of all the manipulation of the file system. Directories,
 * dependencies etc ...
 */
/*****************************************************************************/

module SKFS;

/*****************************************************************************/
/* Constants */
/*****************************************************************************/

const debugMode: Bool = false;

// Unused constants. Are defined because of a bug in the compiler ... Sigh.

const dummyDirty: Map<DirName, Set<BaseName>> = Map[];
const dummyDirtyReaders: Map<DirName, Map<DirName, Set<BaseName>>> = Map[];

/*****************************************************************************/
/* The types used to manage dependencies. */
/*****************************************************************************/

// An Arrow represent an operation from a parent to a child.
// Typically, a map is a tranformation that associates a value from a parent
// to a child. The association between the two is called an Arrow.

value class Arrow(
  parentName: DirName,
  childName: DirName,
) uses Hashable, Orderable

// An ArrowKey, is an Arrow plus a key (the key is from the parent).
// This type is used to describe the root of a dependency on an EagerMap.
// Let's say we have a directory A mapped to B. So B is the result of a map
// applied to A with a given function.

// If during the transformation from A to B, a key is read in third directory,
// we will need to remember that the read occured while processing a map
// from A to B on the key K. Hence the type: ArrowKey(A, B, K).

value class ArrowKey(
  parentName: DirName,
  childName: DirName,
  key: BaseName,
) uses Hashable, Orderable

/*****************************************************************************/
/* The function used to start the system. */
/*****************************************************************************/

fun run(f: (mutable Context) -> void): mutable Context {
  context = mutable Context{};
  f(context);
  context.initPre();
  context
}

/*****************************************************************************/
/* Primitives used to make a file "dirty" (dirty means that it needs to be
 * recomputed.
 *
 * - dirtyReaders are files that are made dirty because of a read access
 * - dirty are files that are made dirty because of a Map.
 */
/*****************************************************************************/

fun updateDirtyReaders(context: mutable Context, path: Path): void {
  for (reader in context.getDeps(path)) {
    child = context.unsafeMaybeGetDir(reader.childName) match {
    | None() -> continue
    | Some(x) -> x
    };
    parent = context.unsafeMaybeGetDir(reader.parentName) match {
    | None() -> continue
    | Some(x) -> x
    };
    context.!dirtyReaders = List.Cons(reader, context.dirtyReaders);
    context.!toUpdate = context.toUpdate.set(
      (child.getTime(), parent.getTime()),
      Arrow(reader.parentName, reader.childName),
    );
  };
}

/*****************************************************************************/
/* Dependencies tracking. */
/*****************************************************************************/

value class Deps(
  data: HashMap<Path, SortedSet<ArrowKey>> = HashMap[],
  idata: HashMap<DirName, SortedSet<Path>> = HashMap[],
) {
  static fun createFromItems(items: Array<(Path, ArrowKey)>): this {
    deps = Deps();
    for (item in items) {
      (path, arrowKey) = item;
      !deps[path] = arrowKey;
    };
    deps
  }

  fun maybeGet(path: Path): ?SortedSet<ArrowKey> {
    this.data.maybeGet(path)
  }

  fun set(path: Path, arrowKey: ArrowKey): this {
    set = this.data.maybeGet(path) match {
    | None() -> SortedSet[]
    | Some(x) -> x
    };
    !set = set.set(arrowKey);
    !this.data[path] = set;
    !this = this.iset(arrowKey.childName, path);

    this
  }

  fun iset(dirName: DirName, arrow: Path): this {
    iset = this.idata.maybeGet(dirName) match {
    | None() -> SortedSet[]
    | Some(x) -> x
    };
    !iset = iset.set(arrow);
    !this.idata[dirName] = iset;
    this
  }

  fun iremove(dirName: DirName, arrow: Path): this {
    iset = this.idata.maybeGet(dirName) match {
    | None() -> SortedSet[]
    | Some(x) -> x
    };
    !iset = iset.remove(arrow);
    if (iset.isEmpty()) {
      !this.idata = this.idata.remove(dirName);
    } else {
      !this.idata[dirName] = iset;
    };
    this
  }

  fun remove(path: Path, arrowKey: ArrowKey): this {
    set = this.data.maybeGet(path) match {
    | None() -> SortedSet[]
    | Some(x) -> x
    };
    !set = set.remove(arrowKey);
    if (set.isEmpty()) {
      !this.data = this.data.remove(path)
    } else {
      !this.data[path] = set
    };
    !this = this.iremove(arrowKey.childName, path);
    this
  }

  fun removeDir(dirName: DirName): this {
    paths = this.idata.maybeGet(dirName) match {
    | None() -> return this
    | Some(x) -> x
    };
    for (path in paths) {
      this.data.maybeGet(path) match {
      | None() -> continue
      | Some(vset) ->
        !this.data[path] = vset.filter(x ->
          !(x.parentName == dirName || x.childName == dirName)
        )
      }
    };
    !this.idata = this.idata.remove(dirName);
    this
  }
}

/*****************************************************************************/
/* The context */
/*****************************************************************************/

mutable class Context{
  mutable pwd: String = "/",
  mutable dirs: Dirs = Dirs{},
  mutable reads: SortedSet<Path> = SortedSet[],
  mutable time: Int = 1,
  mutable tick: Int = 1,
  mutable lazyCapacity: Int = 10,
  mutable toUpdate: SortedMap<(Int, Int), Arrow> = SortedMap[],
  mutable deps: Deps = Deps[],
  mutable debugMode: Bool = debugMode,
  mutable failOnExn: Bool = true,
  mutable hasPre: SortedSet<DirName> = SortedSet[],
  mutable newDirs: SortedSet<DirName> = SortedSet[],
  mutable toReset: SortedSet<DirName> = SortedSet[],
  mutable globals: SortedMap<String, File> = SortedMap[],
  mutable asyncList: List<Path> = List[],
  mutable dirty: List<Path> = List[],
  mutable dirtyReaders: List<ArrowKey> = List[],
  mutable unsafeReuse: Bool = false,
  mutable arrowStack: List<ArrowKey> = List[],
  mutable lazyGets: SortedSet<Path> = SortedSet[],
  mutable lazyGetsQueueIn: List<Array<Path>> = List[],
  mutable lazyGetsQueueOut: List<Array<Path>> = List[],
  mutable lazyGetsRefCount: SortedMap<Path, Int> = SortedMap[],
  mutable reallyRemoveDir: Bool = true,
} {
  mutable fun pushAsync(path: Path): void {
    this.!asyncList = List.Cons(path, this.asyncList);
  }

  mutable fun popAsync(): ?Path {
    this.asyncList match {
    | List.Nil() -> None()
    | List.Cons(x, rl) ->
      this.!asyncList = rl;
      Some(x)
    }
  }

  readonly fun clone(): this {
    static{
      pwd => this.pwd,
      dirs => this.dirs,
      reads => this.reads,
      time => this.time,
      tick => this.tick,
      toUpdate => this.toUpdate,
      deps => this.deps,
      debugMode => this.debugMode,
      failOnExn => this.failOnExn,
      hasPre => this.hasPre,
      newDirs => this.newDirs,
      toReset => this.toReset,
      globals => this.globals,
      asyncList => this.asyncList,
      dirty => this.dirty,
      dirtyReaders => this.dirtyReaders,
      unsafeReuse => this.unsafeReuse,
      arrowStack => this.arrowStack,
      lazyGets => this.lazyGets,
      lazyGetsQueueIn => this.lazyGetsQueueIn,
      lazyGetsQueueOut => this.lazyGetsQueueOut,
      lazyGetsRefCount => this.lazyGetsRefCount,
      reallyRemoveDir => this.reallyRemoveDir,
    }
  }

  static fun fromSaved(ctx: Context): mutable this {
    mutable static{
      pwd => ctx.pwd,
      dirs => ctx.dirs,
      reads => ctx.reads,
      time => ctx.time,
      tick => ctx.tick,
      toUpdate => ctx.toUpdate,
      deps => ctx.deps,
      debugMode => ctx.debugMode,
      failOnExn => ctx.failOnExn,
      hasPre => ctx.hasPre,
      newDirs => ctx.newDirs,
      toReset => ctx.toReset,
      globals => ctx.globals,
      asyncList => ctx.asyncList,
      dirty => ctx.dirty,
      dirtyReaders => ctx.dirtyReaders,
      unsafeReuse => ctx.unsafeReuse,
      arrowStack => ctx.arrowStack,
      lazyGets => ctx.lazyGets,
      lazyGetsQueueIn => ctx.lazyGetsQueueIn,
      lazyGetsQueueOut => ctx.lazyGetsQueueOut,
      lazyGetsRefCount => ctx.lazyGetsRefCount,
      reallyRemoveDir => ctx.reallyRemoveDir,
    }
  }

  mutable fun replaceFromSaved(ctx: Context): void {
    this.!pwd = ctx.pwd;
    this.!dirs = ctx.dirs;
    this.!reads = ctx.reads;
    this.!time = ctx.time;
    this.!tick = ctx.tick;
    this.!toUpdate = ctx.toUpdate;
    this.!deps = ctx.deps;
    this.!debugMode = ctx.debugMode;
    this.!failOnExn = ctx.failOnExn;
    this.!hasPre = ctx.hasPre;
    this.!newDirs = ctx.newDirs;
    this.!toReset = ctx.toReset;
    this.!globals = ctx.globals;
    this.!asyncList = ctx.asyncList;
    this.!dirty = ctx.dirty;
    this.!dirtyReaders = ctx.dirtyReaders;
    this.!unsafeReuse = ctx.unsafeReuse;
    this.!arrowStack = ctx.arrowStack;
    this.!lazyGets = ctx.lazyGets;
    this.!lazyGetsQueueIn = ctx.lazyGetsQueueIn;
    this.!lazyGetsQueueOut = ctx.lazyGetsQueueOut;
    this.!lazyGetsRefCount = ctx.lazyGetsRefCount;
    this.!reallyRemoveDir = ctx.reallyRemoveDir;
  }

  mutable fun getReads(): SortedSet<Path> {
    this.reads
  }

  mutable fun enter(arrow: ArrowKey): void {
    this.!arrowStack = List.Cons(arrow, this.arrowStack);
  }

  mutable fun leave(arrow: ArrowKey): void {
    this.arrowStack match {
    | List.Nil() -> invariant_violation("Cannot leave empty context")
    | List.Cons(arr, rl) ->
      invariant(arr == arrow);
      this.!arrowStack = rl
    }
  }

  readonly fun currentArrow(): ?ArrowKey {
    this.arrowStack match {
    | List.Nil() -> None()
    | List.Cons(x, _) -> Some(x)
    }
  }

  readonly fun getDeps(path: Path): SortedSet<ArrowKey> {
    this.deps.maybeGet(path) match {
    | None() -> SortedSet[]
    | Some(deps) -> deps
    }
  }

  readonly fun debug(path: Path): void {
    this.dirs.maybeGet(path.dirName) match {
    | None() -> print_string("Directory does not exist")
    | Some(dir) ->
      values = dir.getArrayRaw(path.baseName);
      debug(values)
    }
  }

  readonly fun getValue(path: Path): Array<File> {
    dir = this.dirs[path.dirName];
    values = dir.getArrayRaw(path.baseName);
    values
  }

  mutable fun updateNewDeps(reader: ArrowKey, reads: SortedSet<Path>): void {
    readSet = mutable Set[];
    for (read in reads) {
      readSet.insert(read);
    };
    for (path in readSet) {
      this.!deps = this.deps.set(path, reader);
    };
  }

  mutable fun initPre(): void {
    this.updatePre(this.dirs.state.items().map(x -> x.i0).collect(SortedSet));
  }

  mutable fun updatePre(toUpdate: SortedSet<DirName>): void {
    if (this.debugMode) {
      print_string(`------------ UPDATE PRE ------------`);
    };

    for (dirName in toUpdate) {
      if (!this.hasPre.contains(dirName)) continue;
      preDirName = dirName.pre();
      dir = this.unsafeGetEagerDir(dirName);
      this.unsafeMaybeGetEagerDir(preDirName) match {
      | None() ->
        this.!newDirs = this.newDirs.add(preDirName);
        time = this.timeStamp();
        preDir = EagerDir{
          time,
          input => false,
          dirName => preDirName,
          totalSize => 0,
          fixedData => FixedDir{},
          creator => this.currentArrow(),
        };
        dir.unsafeIterKeys((key, _time) -> {
          values = dir.getArrayRaw(key).collect(Array);
          !preDir = preDir.writeEntry(
            this,
            Path::create(preDir.dirName, key),
            key,
            values,
          );
        });
        this.setDir(preDir.dirName, preDir);
        updateDirtyReaders(this, Path::create(preDirName.tag(), DIR_TAG));
        this.setDir(preDirName, preDir)
      | Some(preDir) ->
        for (kv in dir.data.getChangesAfter(this.tick - 1)) {
          (key, _) = kv;
          values = dir.getArrayRaw(key).collect(Array);
          !preDir = preDir.writeEntry(
            this,
            Path::create(preDir.dirName, key),
            key,
            values,
          );
        };
        this.setDir(preDir.dirName, preDir)
      }
    }
  }

  mutable fun updateLazyGets(): void {
    for (path in this.lazyGets) {
      refCount = this.lazyGetsRefCount.maybeGet(path) match {
      | None() -> 0
      | Some(x) -> x
      };
      this.!lazyGetsRefCount[path] = refCount + 1;
    };
    this.!lazyGetsQueueIn = List.Cons(
      this.lazyGets.toArray(),
      this.lazyGetsQueueIn,
    );
    this.!lazyGets = SortedSet[];
    if (this.tick <= this.lazyCapacity) return void;
    queue = this.lazyGetsQueueOut match {
    | List.Nil() ->
      invariant(this.lazyGetsQueueIn is List.Cons _);
      this.!lazyGetsQueueOut = this.lazyGetsQueueIn.reversed();
      this.!lazyGetsQueueIn = List[];
      this.lazyGetsQueueOut
    | l -> l
    };
    queue match {
    | List.Nil() -> invariant_violation("LazyGets reached empty queue")
    | List.Cons(lazyGets, rl) ->
      this.!lazyGetsQueueOut = rl;
      toRemove = mutable Map[];
      for (path in lazyGets) {
        refCount = this.lazyGetsRefCount.maybeGet(path) match {
        | None() -> invariant_violation("Not found")
        | Some(x) -> x
        };
        !refCount = refCount - 1;
        if (refCount == 0) {
          this.!lazyGetsRefCount = this.lazyGetsRefCount.remove(path);
          if (!toRemove.containsKey(path.dirName)) {
            toRemove![path.dirName] = mutable Set[];
          };
          toRemove[path.dirName].insert(path.baseName);
        } else {
          this.!lazyGetsRefCount[path] = refCount;
        }
      };
      for (dirName => keys in toRemove) {
        dir = this.unsafeGetLazyDir(dirName);
        data = dir.data;
        for (key in keys) {
          data.maybeGet(key) match {
          | Some(LDefined(_, reads)) ->
            for (read in reads) {
              this.!deps = this.deps.remove(
                read,
                ArrowKey(dirName, dirName, key),
              )
            }
          | _ -> void
          };
          !data = data.remove(key);
        };
        !dir.data = data;
        this.setDir(dirName, dir)
      }
    };
  }

  mutable fun update(): void {
    hasBackgroundWork = this.updateWithStatus(0);
    if (hasBackgroundWork) {
      invariant_violation(
        "update should not be called when there is background work" +
          "use updateWithStatus instead",
      );
    };
    void
  }

  mutable fun updateWithStatus(backgroundRounds: Int): Bool {
    if (this.debugMode) {
      print_string(`------------ UPDATE (TICK: ${this.tick}) ------------`);
    };

    this.!tick = this.tick + 1;

    this.updateLazyGets();

    while (backgroundRounds > 0) {
      roundsCopy = backgroundRounds;
      !backgroundRounds = withRegion(this, (obstack, context) ~> {
        rounds = roundsCopy;
        while (rounds > 0) {
          path = context.popAsync() match {
          | None() ->
            !rounds = 0;
            break void
          | Some(x) -> x
          };
          dir = context.unsafeGetLazyDir(path.dirName);
          _ = dir.unsafeGetArray(context, path.baseName);
          updateDirtyReaders(context, path);
          !rounds = rounds - 1;
          if (shouldGC(obstack) != 0) {
            break void;
          }
        };
        rounds
      })
    };

    dirty = mutable Map<DirName, mutable Set<BaseName>>[];
    dirtyReaders = mutable Map<
      DirName,
      mutable Map<DirName, mutable Set<BaseName>>,
    >[];

    loop {
      for (path in this.dirty) {
        dirty.maybeGet(path.dirName) match {
        | None() ->
          set = mutable Set[path.baseName];
          dirty![path.dirName] = set
        | Some(set) -> set.insert(path.baseName)
        };
      };
      this.!dirty = List[];
      for (reader in this.dirtyReaders) {
        if (!dirtyReaders.containsKey(reader.parentName)) {
          dirtyReaders![reader.parentName] = mutable Map[];
        };

        if (!dirtyReaders[reader.parentName].containsKey(reader.childName)) {
          dirtyReaders[reader.parentName]![reader.childName] = mutable Set[];
        };
        dirtyReaders[reader.parentName][reader.childName].insert(reader.key);
      };
      this.!dirtyReaders = List[];
      toUpdate = this.toUpdate.minimum();
      toUpdate match {
      | None() ->
        invariant(this.dirty.isEmpty());
        invariant(this.dirtyReaders.isEmpty());
        this.updatePre(this.toReset);
        this.!toReset = SortedSet[];
        return !this.asyncList.isEmpty()
      | Some((time, Arrow(parentName, childName))) ->
        this.!toReset = this.toReset.set(childName);
        this.!toUpdate = this.toUpdate.remove(time);
        this.unsafeMaybeGetDir(childName) match {
        | None()
        | Some(DeletedDir _) ->
          void
        | Some(child @ LazyDir _) ->
          child.update(this, dirtyReaders.maybeGet(child.dirName))
        | Some(child @ EagerDir _) ->
          this.!toReset = this.toReset.set(parentName);
          (mapFun, rangeOpt) = child.parents.maybeGet(parentName) match {
          | None() -> invariant_violation("Could not find parent")
          | Some(f) -> f
          };
          EagerDir::update(
            this,
            dirty,
            dirtyReaders,
            parentName,
            mapFun,
            rangeOpt,
            child,
          )
        }
      }
    }
  }

  mutable fun timeStamp(): Int {
    this.!time = this.time + 1;
    this.time
  }

  mutable fun mkdir<T: File>(
    conv: File ~> T,
    dirName: DirName,
    content: Array<(BaseName, T)> = Array[],
  ): EHandle<T> {
    this.mkdirMulti(
      dirName,
      content.map(kv -> {
        (key, value) = kv;
        (key, Array[value])
      }),
    );
    EHandle(conv, dirName)
  }

  mutable fun mkdirMulti(
    dirName: DirName,
    content: Array<(BaseName, Array<File>)> = Array[],
  ): void {
    if (this.dirs.state.containsKey(dirName)) {
      throw DirAlreadyExists(dirName);
    };
    !content = content.sortedBy(x ~> x.i0);
    vector: mutable Vector<FixedRow<Array<File>>> = mutable Vector[];
    valueAcc = mutable Vector[];
    last: ?BaseName = None();
    for (kv in content) {
      (key, values) = kv;
      last match {
      | None() ->
        valueAcc.extend(values);
        !last = Some(key)
      | Some(oldKey) if (oldKey == key) -> valueAcc.extend(values)
      | Some(oldKey) ->
        path = Source::create(Path::create(dirName, oldKey));
        vector.push(FixedRow(oldKey, (path, valueAcc.toArray())));
        !last = Some(key);
        valueAcc.clear();
        valueAcc.extend(values)
      };
    };
    last match {
    | None() -> void
    | Some(key) ->
      path = Source::create(Path::create(dirName, key));
      vector.push(FixedRow(key, (path, valueAcc.toArray())))
    };
    fixedData = FixedDir{data => vector.toArray()};

    time = this.timeStamp();
    totalSize = fixedData.data.size();
    creator = this.currentArrow();
    dir = EagerDir{time, input => true, dirName, fixedData, totalSize, creator};
    this.!dirs = this.dirs.set(dir.time, dirName, dir);
    this.!newDirs = this.newDirs.add(dirName);
  }

  mutable fun mkdirCompressed<T: File, Row: frozen>(
    conv: File ~> T,
    dirName: DirName,
    content: Array<Row>,
    decompress: (Int, Row) ~> FixedRow<Array<File>>,
  ): EHandle<T> {
    if (this.dirs.state.containsKey(dirName)) {
      throw DirAlreadyExists(dirName);
    };
    fixedData = CompressedDir{data => content, decompress};

    time = this.timeStamp();
    totalSize = fixedData.data.size();
    creator = this.currentArrow();
    dir = EagerDir{time, input => true, dirName, fixedData, totalSize, creator};
    this.!dirs = this.dirs.set(dir.time, dirName, dir);
    this.!newDirs = this.newDirs.add(dirName);
    EHandle(conv, dirName)
  }

  mutable fun setDir(dirName: DirName, dir: Dir): void {
    /*
    dirNamePwdStr = this.pwd.join("/");
    dirNameStr = dirName.toString();
    dirNameArr = dirNameStr.split("/");
    if (dirNameArr.size() < 2) {
      error(`Invalid directory name: ${dirNameStr}`);
    };
    lastDirName = dirNameArr[dirNameArr.size() - 2];
    if (dirNamePwdStr + lastDirName + "/" != dirNameStr) {
      error(`Cannot create directory ${dirNameStr} from path ${dirNamePwdStr}`);
    };
    */
    // TODO: re-enable this when the dirNames are represented as lists
    this.!dirs = this.dirs.set(dir.getTime(), dirName, dir);
  }

  mutable fun getDir(dirName: DirName): Dir {
    this.addDep(Path::create(dirName.tag(), DIR_TAG));
    this.dirs.get(dirName);
  }

  readonly fun unsafeGetDir(dirName: DirName): Dir {
    this.dirs.get(dirName);
  }

  mutable fun unsafeGetLazyDir(dirName: DirName): LazyDir {
    this.unsafeGetDir(dirName) match {
    | d @ LazyDir _ -> d
    | _ -> invariant_violation("unsafeGetLazyDir: Was expecting LazyDir")
    }
  }

  mutable fun unsafeGetEagerDir(dirName: DirName): EagerDir {
    this.unsafeGetDir(dirName) match {
    | d @ EagerDir _ -> d
    | _ -> invariant_violation("unsafeGetEagerDir: Was expecting EagerDir")
    }
  }

  mutable fun unsafeMaybeGetLazyDir(dirName: DirName): ?LazyDir {
    this.unsafeMaybeGetDir(dirName) match {
    | None()
    | Some(DeletedDir _) ->
      None()
    | Some(d @ LazyDir _) -> Some(d)
    | _ -> invariant_violation("unsafeMaybeGetLazyDir: Was expecting LazyDir")
    }
  }

  mutable fun unsafeMaybeGetEagerDir(dirName: DirName): ?EagerDir {
    this.unsafeMaybeGetDir(dirName) match {
    | None()
    | Some(DeletedDir _) ->
      None()
    | Some(d @ EagerDir _) -> Some(d)
    | _ -> invariant_violation("unsafeMaybeGetEagerDir: Was expecting EagerDir")
    }
  }

  mutable fun getLazyDir(dirName: DirName): LazyDir {
    this.getDir(dirName) match {
    | d @ LazyDir _ -> d
    | _ -> invariant_violation("getLazyDir: Was expecting LazyDir")
    }
  }

  mutable fun getEagerDir(dirName: DirName): EagerDir {
    this.getDir(dirName) match {
    | d @ EagerDir _ -> d
    | _ -> invariant_violation("getEagerDir: Was expecting EagerDir")
    }
  }

  mutable fun maybeGetLazyDir(dirName: DirName): ?LazyDir {
    this.maybeGetDir(dirName) match {
    | None()
    | Some(DeletedDir _) ->
      None()
    | Some(d @ LazyDir _) -> Some(d)
    | _ -> invariant_violation("maybeGetLazyDir: Was expecting LazyDir")
    }
  }

  mutable fun maybeGetEagerDir(dirName: DirName): ?EagerDir {
    this.maybeGetDir(dirName) match {
    | None()
    | Some(DeletedDir _) ->
      None()
    | Some(d @ EagerDir _) -> Some(d)
    | _ -> invariant_violation("maybeGetEagerDir: Was expecting EagerDir")
    }
  }

  mutable fun removeDir(dirName: DirName): void {
    if (this.debugMode) {
      print_string("REMOVED: " + dirName);
    };
    this.unsafeMaybeGetEagerDir(dirName) match {
    | None() -> return void
    | Some(dir) ->
      for (parentName => _ in dir.parents) {
        this.unsafeMaybeGetEagerDir(parentName) match {
        | None() -> continue
        | Some(parent) ->
          !parent.childDirs = parent.childDirs.remove(dirName);
          this.setDir(parent.dirName, parent)
        }
      }
    };
    this.!deps = this.deps.removeDir(dirName);
    if (this.reallyRemoveDir) {
      this.!dirs.state = this.dirs.state.remove(dirName)
    } else {
      this.setDir(dirName, DeletedDir{dirName, time => this.timeStamp()})
    };
  }

  mutable fun maybeGetDir<T: File>(dirName: DirName): ?Dir {
    this.addDep(Path::create(dirName.tag(), DIR_TAG));
    this.dirs.maybeGet(dirName);
  }

  readonly fun unsafeMaybeGetDir<T: File>(dirName: DirName): ?Dir {
    this.dirs.maybeGet(dirName);
  }

  mutable fun addDep(path: Path): void {
    this.!reads = this.reads.set(path);
  }

  mutable fun setGlobal(name: String, file: File): void {
    this.!globals = this.globals.set(name, file);
  }

  readonly fun getGlobal(name: String): ?File {
    this.globals.maybeGet(name)
  }
}

class Dirs{state: DMap<DirName, Dir> = DMap::empty()} {
  fun set<T: File>(time: Int, key: DirName, value: Dir): this {
    !this.state = this.state.set(TimeTag::create(time), key, value);
    this
  }
  fun maybeGet(key: DirName): ?Dir {
    this.state.maybeGet(key)
  }
  fun get(key: DirName): Dir {
    this.maybeGet(key) match {
    | None() -> invariant_violation("Directory not found: " + key)
    | Some(x) -> x
    }
  }
}

@cpp_extern
private native base class Obstack

@debug
@cpp_extern("SKIP_new_Obstack")
private native fun newObstack(): Obstack;

@debug
@cpp_extern("SKIP_destroy_Obstack")
private native fun destroyObstack(Obstack): void;

@debug
@cpp_extern("SKIP_destroy_Obstack_with_value")
private native fun destroyObstackWithValue<T>(Obstack, List<T>): List<T>;

@debug
@cpp_extern("SKIP_context_sync")
private native fun gContextSync(Context): Context;

@debug
@cpp_extern("SKIP_context_init")
private native fun gContextInit(Context): Context;

@debug
@cpp_extern("SKIP_context_get")
native fun gContextGet(): Context;

@debug
@cpp_extern("sk_verify_shared")
native fun .verify(Context): void;

@debug
@cpp_extern("SKIP_should_GC")
native fun shouldGC(Obstack): UInt32;

@debug
@cpp_extern("SKIP_disable_GC")
native fun disableGC(): void;

@debug
@cpp_extern("SKIP_enable_GC")
native fun enableGC(): void;

@cpp_noinline
fun runWithGcReturnContext(
  origContext: Context,
  f: Context ~> ?Context,
): mutable Context {
  context = gContextInit(origContext);
  loop {
    pos = newObstack();
    newContextOpt = f(context);
    newContextOpt match {
    | None() -> return Context::fromSaved(context)
    | Some(newContext) ->
      !context = gContextSync(newContext);
      destroyObstack(pos)
    }
  }
}

fun runWithGc(origContext: Context, f: Context ~> ?Context): void {
  _ = runWithGcReturnContext(origContext, f);
}

fun withRegion<T>(
  context: mutable Context,
  f: (Obstack, mutable Context) ~> T,
): T {
  saved = newObstack();
  fresult = f(saved, context);
  copied = destroyObstackWithValue(saved, List[(context.clone(), fresult)]);
  (icontext, copiedResult) = copied.getHead();
  context.replaceFromSaved(icontext);
  copiedResult
}

module end;
