module SKFS;

class StringFile(value: .String) extends File

class DirAlreadyExists(dirName: DirName) extends Exception {
  fun toString(): String {
    `Directory ${this.dirName} already exists`
  }
}

fun start<T>(f: (mutable Context) -> T): (mutable Context, T) {
  context = mutable Context{};
  result = f(context);
  context.updateNewDeps();
  context.initPre();
  context.updateFixedDeps();
  (context, result)
}

fun run(f: (mutable Context) -> void): mutable Context {
  context = mutable Context{};
  f(context);
  context.updateNewDeps();
  context.initPre();
  context.updateFixedDeps();
  context
}

const debugMode: Bool = false;

const dummyDirty: Map<DirName, Set<BaseName>> = Map[];
const dummyDirtyReaders: Map<DirName, Map<DirName, Set<BaseName>>> = Map[];

/*****************************************************************************/
/* Primitives used to make a file "dirty" (dirty means that it needs to be
 * recomputed.
 *
 * - dirtyReaders are files that are made dirty because of a read access
 * - dirty are files that are made dirty because of a Map.
 *
 */
/*****************************************************************************/

fun updateDirtyReaders(context: mutable Context, path: Path): void {
  readers = context.getDeps(path);

  for (reader in readers) {
    (parentName, childName, baseName) = reader;
    child = context.unsafeGetDir(childName);

    addDirtyReader(context, parentName, childName, baseName);
    context.!toUpdate = context.toUpdate.set(
      child.getTime(),
      (parentName, childName),
    );
  };
}

fun addDirtyReader(
  context: mutable Context,
  parentName: DirName,
  childName: DirName,
  baseName: BaseName,
): void {
  if (!context.dirtyReaders.containsKey(parentName)) {
    context.dirtyReaders![parentName] = mutable Map[];
  };

  if (!context.dirtyReaders[parentName].containsKey(childName)) {
    context.dirtyReaders[parentName]![childName] = mutable Set[];
  };
  context.dirtyReaders[parentName][childName].insert(baseName);
}

/*****************************************************************************/
/* The context */
/*****************************************************************************/

mutable class Context{
  mutable pwd: String = "/",
  mutable dirs: Dirs = Dirs{},
  mutable lazyVisitedList: List<Path> = List[],
  mutable lazyVisitedSet: SortedSet<Path> = SortedSet[],
  mutable reads: mutable Vector<Path> = mutable Vector[],
  mutable time: Int = 1,
  mutable tick: Int = 1,
  mutable toUpdate: SortedMap<Int, (DirName, DirName)> = SortedMap[],
  mutable deps: List<Array<(Path, DirName, DirName, BaseName)>> = List[],
  mutable fixedDeps: Map<Path, Set<(DirName, DirName, BaseName)>> = Map[],
  mutable newDeps: SortedMap<
    Path,
    SortedSet<(DirName, DirName, BaseName)>,
  > = SortedMap[],
  mutable debugMode: Bool = debugMode,
  mutable failOnExn: Bool = true,
  mutable hasPre: SortedSet<DirName> = SortedSet[],
  mutable hasNext: SortedSet<DirName> = SortedSet[],
  mutable newDirs: SortedSet<DirName> = SortedSet[],
  mutable toReset: SortedSet<DirName> = SortedSet[],
  mutable globals: SortedMap<String, File> = SortedMap[],
  dirty: mutable Map<DirName, mutable Set<BaseName>> = mutable Map[],
  dirtyReaders: mutable Map<
    DirName,
    mutable Map<DirName, mutable Set<BaseName>>,
  > = mutable Map[],
} {
  readonly fun vtry<T>(f: () -> T, onError: .Exception -> T): T {
    if (this.failOnExn) f() else vtry(f, onError)
  }

  readonly fun clone(): this {
    static{
      pwd => this.pwd,
      dirs => this.dirs,
      lazyVisitedList => this.lazyVisitedList,
      lazyVisitedSet => this.lazyVisitedSet,
      reads => Vector[],
      time => this.time,
      tick => this.tick,
      toUpdate => this.toUpdate,
      deps => this.deps,
      fixedDeps => this.fixedDeps,
      newDeps => this.newDeps,
      debugMode => this.debugMode,
      hasPre => this.hasPre,
      hasNext => this.hasNext,
      newDirs => this.newDirs,
      toReset => this.toReset,
      globals => this.globals,
    }
  }

  static fun fromSaved(ctx: Context): mutable this {
    mutable static{
      pwd => ctx.pwd,
      dirs => ctx.dirs,
      lazyVisitedList => ctx.lazyVisitedList,
      lazyVisitedSet => ctx.lazyVisitedSet,
      reads => mutable Vector[],
      time => ctx.time,
      tick => ctx.tick,
      toUpdate => ctx.toUpdate,
      deps => ctx.deps,
      fixedDeps => ctx.fixedDeps,
      newDeps => ctx.newDeps,
      debugMode => ctx.debugMode,
      hasPre => ctx.hasPre,
      hasNext => ctx.hasNext,
      newDirs => ctx.newDirs,
      toReset => ctx.toReset,
      globals => ctx.globals,
    }
  }

  mutable fun getReads(): Vector<Path> {
    reads = this.reads.chill();
    reads
  }

  readonly fun getDeps(path: Path): Set<(DirName, DirName, BaseName)> {
    set = if (!this.fixedDeps.containsKey(path)) {
      Set[]
    } else {
      this.fixedDeps[path]
    };
    this.newDeps.maybeGet(path) match {
    | None() -> set
    | Some(newDeps) ->
      mset = Set::mcreateFromItems(set);
      for (dep in newDeps) {
        mset.insert(dep);
      };
      mset.chill()
    }
  }

  readonly fun debug(path: Path): void {
    this.dirs.maybeGet(path.dirName) match {
    | None() -> print_string("Directory does not exist")
    | Some(dir) ->
      values = dir.getArrayRaw(path.baseName);
      debug(values)
    }
  }

  readonly fun getValue(path: Path): Array<File> {
    dir = this.dirs[path.dirName];
    values = dir.getArrayRaw(path.baseName);
    values
  }

  mutable fun updateFixedDeps(): void {
    fixedDeps = mutable Map[];
    invariant(this.fixedDeps.isEmpty());
    for (depVector in this.deps) {
      for (read in depVector) {
        (path, sourceDir, targetDir, baseName) = read;
        if (!fixedDeps.containsKey(path)) {
          fixedDeps![path] = mutable Set[];
        };
        fixedDeps[path].add((sourceDir, targetDir, baseName));
      }
    };
    this.!deps = List[];
    this.!fixedDeps = fixedDeps.chill().map((_, v) -> v.chill());
  }

  mutable fun updateNewDeps(): void {
    for (depVector in this.deps) {
      for (read in depVector) {
        (path, sourceDir, targetDir, baseName) = read;
        reader = (sourceDir, targetDir, baseName);
        if (this.fixedDeps.containsKey(path)) {
          if (this.fixedDeps[path].contains(reader)) {
            continue;
          };
        };
        if (!this.newDeps.containsKey(path)) {
          this.!newDeps[path] = SortedSet[];
        };
        this.!newDeps[path] = this.newDeps[path].add(reader);
      }
    };
    this.!deps = List[];
  }

  mutable fun initPre(): void {
    this.updatePre(this.dirs.state.items().map(x -> x.i0).collect(SortedSet));
  }

  mutable fun updatePre(toUpdate: SortedSet<DirName>): void {
    if (this.debugMode) {
      print_string(`------------ UPDATE PRE ------------`);
    };

    for (dirName in toUpdate) {
      if (!this.hasPre.contains(dirName)) continue;
      preDirName = dirName.pre();
      dir = this.unsafeGetEagerDir(dirName);
      this.unsafeMaybeGetEagerDir(preDirName) match {
      | None() ->
        this.!newDirs = this.newDirs.add(preDirName);
        time = this.timeStamp();
        preDir = EagerDir{
          time,
          input => false,
          dirName => preDirName,
          fixedData => FixedData{data => Array[]},
        };
        dir.unsafeIterKeys((key, _time) -> {
          values = dir.getArrayRaw(key);
          !preDir = preDir.writeEntry(
            this,
            Path(preDir.dirName, key),
            key,
            values,
          );
        });
        this.setDir(preDir.dirName, preDir);
        updateDirtyReaders(this, Path(preDirName.tag(), DirTag()));
        this.setDir(preDirName, preDir)
      | Some(preDir) ->
        for (kv in dir.data.getChangesAfter(this.tick - 1)) {
          (key, _) = kv;
          values = dir.getArrayRaw(key);
          !preDir = preDir.writeEntry(
            this,
            Path(preDir.dirName, key),
            key,
            values,
          );
        };
        this.setDir(preDir.dirName, preDir)
      }
    }
  }

  mutable fun update(): void {
    if (this.debugMode) {
      print_string(`------------ UPDATE (TICK: ${this.tick}) ------------`);
    };

    this.updateNewDeps();

    this.!tick = this.tick + 1;
    loop {
      toUpdate = this.toUpdate.minimum();
      toUpdate match {
      | None() ->
        this.dirty.clear();
        this.dirtyReaders.clear();
        this.updatePre(this.toReset);
        this.!toReset = SortedSet[];
        return void
      | Some((time, (parentName, childName))) ->
        this.!toReset = this.toReset.set(childName);
        this.!toUpdate = this.toUpdate.remove(time);
        this.unsafeGetDir(childName) match {
        | DeletedDir _ -> void
        | dir @ LazyDir _ -> dir.updateLazy(this)
        | EagerDir _ ->
          this.!toReset = this.toReset.set(parentName);
          EagerDir::update(this, parentName, childName)
        }
      };
    };
  }

  mutable fun timeStamp(): Int {
    this.!time = this.time + 1;
    this.time
  }

  mutable fun mkdir<T: File>(
    conv: File ~> T,
    dirName: DirName,
    content: Array<(BaseName, T)> = Array[],
  ): EHandle<T> {
    dir = this.mkdirMulti(
      dirName,
      content.map(kv -> {
        (key, value) = kv;
        (key, Array[value])
      }),
    );
    this.!newDirs = this.newDirs.add(dir.getDirName());
    this.setDir(dir.getDirName(), dir);
    EHandle(conv, dir.getDirName())
  }

  mutable fun mkdirMulti<T: File>(
    dirName: DirName,
    content: Array<(BaseName, Array<T>)> = Array[],
  ): Dir {
    if (this.dirs.state.containsKey(dirName)) {
      throw DirAlreadyExists(dirName);
    };
    vector = mutable Vector[];
    for (kv in content) {
      (key, values) = kv;
      path = Path(dirName, key);
      vector.push(FixedRow(key, (path, values.map(x -> (x : File)))));
    };
    vector.sort();
    fixedData = FixedData{data => vector.toArray()};
    time = this.timeStamp();
    dir = EagerDir{time, input => true, dirName, fixedData};
    this.!dirs = this.dirs.set(dir.time, dirName, dir);
    dir
  }

  mutable fun setDir(dirName: DirName, dir: Dir): void {
    /*
    dirNamePwdStr = this.pwd.join("/");
    dirNameStr = dirName.toString();
    dirNameArr = dirNameStr.split("/");
    if (dirNameArr.size() < 2) {
      error(`Invalid directory name: ${dirNameStr}`);
    };
    lastDirName = dirNameArr[dirNameArr.size() - 2];
    if (dirNamePwdStr + lastDirName + "/" != dirNameStr) {
      error(`Cannot create directory ${dirNameStr} from path ${dirNamePwdStr}`);
    };
    */
    // TODO: re-enable this when the dirNames are represented as lists
    this.!dirs = this.dirs.set(dir.getTime(), dirName, dir);
  }

  mutable fun getDir(dirName: DirName): Dir {
    this.addDep(Path(dirName.tag(), DirTag()));
    this.dirs.get(dirName);
  }

  readonly fun unsafeGetDir(dirName: DirName): Dir {
    this.dirs.get(dirName);
  }

  mutable fun unsafeGetLazyDir(dirName: DirName): LazyDir {
    this.unsafeGetDir(dirName) match {
    | d @ LazyDir _ -> d
    | _ -> invariant_violation("Was expecting LazyDir")
    }
  }

  mutable fun unsafeGetEagerDir(dirName: DirName): EagerDir {
    this.unsafeGetDir(dirName) match {
    | d @ EagerDir _ -> d
    | _ -> invariant_violation("Was expecting EagerDir")
    }
  }

  mutable fun unsafeMaybeGetLazyDir(dirName: DirName): ?LazyDir {
    this.unsafeMaybeGetDir(dirName) match {
    | None() -> None()
    | Some(d @ LazyDir _) -> Some(d)
    | _ -> invariant_violation("Was expecting LazyDir")
    }
  }

  mutable fun unsafeMaybeGetEagerDir(dirName: DirName): ?EagerDir {
    this.unsafeMaybeGetDir(dirName) match {
    | None() -> None()
    | Some(d @ EagerDir _) -> Some(d)
    | _ -> invariant_violation("Was expecting EagerDir")
    }
  }

  mutable fun getLazyDir(dirName: DirName): LazyDir {
    this.getDir(dirName) match {
    | d @ LazyDir _ -> d
    | _ -> invariant_violation("Was expecting LazyDir")
    }
  }

  mutable fun getEagerDir(dirName: DirName): EagerDir {
    this.getDir(dirName) match {
    | d @ EagerDir _ -> d
    | _ -> invariant_violation("Was expecting EagerDir")
    }
  }

  mutable fun maybeGetLazyDir(dirName: DirName): ?LazyDir {
    this.maybeGetDir(dirName) match {
    | None() -> None()
    | Some(d @ LazyDir _) -> Some(d)
    | _ -> invariant_violation("Was expecting LazyDir")
    }
  }

  mutable fun maybeGetEagerDir(dirName: DirName): ?EagerDir {
    this.maybeGetDir(dirName) match {
    | None() -> None()
    | Some(d @ EagerDir _) -> Some(d)
    | _ -> invariant_violation("Was expecting EagerDir")
    }
  }

  mutable fun removeDir(dirName: DirName): void {
    if (this.debugMode) {
      print_string("REMOVED: " + dirName);
    };
    this.setDir(dirName, DeletedDir{dirName, time => this.timeStamp()});
  }

  mutable fun maybeGetDir<T: File>(dirName: DirName): ?Dir {
    this.addDep(Path(dirName.tag(), DirTag()));
    this.dirs.maybeGet(dirName);
  }

  readonly fun unsafeMaybeGetDir<T: File>(dirName: DirName): ?Dir {
    this.dirs.maybeGet(dirName);
  }

  mutable fun addDep(path: Path): void {
    this.reads.push(path)
  }

  mutable fun setGlobal(name: String, file: File): void {
    this.!globals = this.globals.set(name, file);
  }

  readonly fun getGlobal(name: String): ?File {
    this.globals.maybeGet(name)
  }
}

class Dirs{state: DMap<DirName, Dir> = DMap::empty()} {
  fun set<T: File>(time: Int, key: DirName, value: Dir): this {
    !this.state = this.state.set(TimeTag::create(time), key, value);
    this
  }
  fun maybeGet(key: DirName): ?Dir {
    this.state.maybeGet(key)
  }
  fun get(key: DirName): Dir {
    this.maybeGet(key) match {
    | None() -> invariant_violation("Directory not found: " + key)
    | Some(x) -> x
    }
  }
}

@cpp_extern
private native base class Obstack

@debug
@cpp_extern("SKIP_new_Obstack")
private native fun newObstack(): Obstack;

@debug
@cpp_extern("SKIP_destroy_Obstack")
private native fun destroyObstack(Obstack): void;

@debug
@cpp_extern("SKIP_context_sync")
private native fun gContextSync(Context): void;

@debug
@cpp_extern("SKIP_context_init")
private native fun gContextInit(Context): void;

@debug
@cpp_extern("SKIP_context_get")
native fun gContextGet(): Context;

fun runWithGc(origContext: Context, f: Context ~> ?Context): void {
  !f = intern(f);
  gContextInit(origContext);
  context = origContext;
  loop {
    pos = newObstack();
    newContextOpt = f(context);
    newContextOpt match {
    | None() -> return void
    | Some(newContext) ->
      gContextSync(newContext);
      !context = gContextGet();
      destroyObstack(pos)
    }
  }
}

module end;
