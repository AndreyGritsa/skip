module SKFS;

class DirAlreadyExists(dirName: DirName) extends Exception {
  fun toString(): String {
    `Directory ${this.dirName} already exists`
  }
}

fun start<T>(f: (mutable Context) -> T): (mutable Context, T) {
  context = mutable Context{};
  result = f(context);
  context.updateFixedDeps();
  (context, result)
}

mutable class Handle<Value>{
  mutable state: State = State{},
  reads: mutable Vector<Path> = mutable Vector[],
  private writes: mutable Map<BaseName, Array<Value>> = mutable Map[],
} {
  readonly fun getDir<T: File>(dirRef: DirRef<T>): Dir<T> {
    this.state.getDir(freeze(dirRef));
  }

  mutable fun writeArray(key: BaseName, values: Array<Value>): void {
    this.writes![key] = values;
  }

  fun getModifs(): (Array<(BaseName, Array<Value>)>, Vector<Path>) {
    result = mutable Vector[];
    for (key => values in this.writes) {
      result.push((key, values));
    };
    (result.toArray(), this.reads)
  }

  mutable fun remove(key: BaseName): void {
    this.writes![key] = Array[];
  }

  mutable fun addDep(path: Path): void {
    this.reads.push(path)
  }
}

mutable class Context{
  mutable state: State = State{},
  mutable time: Int = 0,
  mutable toUpdate: SortedMap<Int, (mutable Context) ~> void> = SortedMap[],
  mutable deps: List<Vector<(Path, DirName, DirName, BaseName)>> = List[],
  mutable fixedDeps: Map<Path, Set<(DirName, DirName, BaseName)>> = Map[],
  mutable newDeps: SortedMap<
    Path,
    SortedSet<(DirName, DirName, BaseName)>,
  > = SortedMap[],
  debugMode: Bool = true,
} {
  readonly fun getDeps(path: Path): Set<(DirName, DirName, BaseName)> {
    set = if (!this.fixedDeps.containsKey(path)) {
      Set[]
    } else {
      this.fixedDeps[path]
    };
    this.newDeps.maybeGet(path) match {
    | None() -> set
    | Some(newDeps) ->
      mset = Set::mcreateFromItems(set);
      for (dep in newDeps) {
        mset.insert(dep);
      };
      freeze(mset)
    }
  }

  mutable fun debug(pathStr: String): void {
    path = Path::fromString(pathStr);
    dirRef = DirRef<File>(path.dirName);
    dir = this.state.dirs[dirRef];
    values = dir.getArrayRaw(path.baseName);
    debug(values)
  }

  mutable fun updateFixedDeps(): void {
    fixedDeps = mutable Map[];
    invariant(this.fixedDeps.isEmpty());
    for (depVector in this.deps) {
      for (read in depVector) {
        (path, sourceDir, targetDir, baseName) = read;
        if (!fixedDeps.containsKey(path)) {
          fixedDeps![path] = mutable Set[];
        };
        fixedDeps[path].add((sourceDir, targetDir, baseName));
      }
    };
    this.!deps = List[];
    this.!fixedDeps = freeze(fixedDeps);
  }

  mutable fun updateNewDeps(): void {
    for (depVector in this.deps) {
      for (read in depVector) {
        (path, sourceDir, targetDir, baseName) = read;
        reader = (sourceDir, targetDir, baseName);
        if (this.fixedDeps.containsKey(path)) {
          if (this.fixedDeps[path].contains(reader)) {
            continue;
          };
        };
        if (!this.newDeps.containsKey(path)) {
          !this.newDeps[path] = SortedSet[];
        };
        !this.newDeps[path] = this.newDeps[path].add(reader);
      }
    };
    this.!deps = List[];
  }

  mutable fun update(): void {
    this.updateNewDeps();
    loop {
      this.toUpdate.minimum() match {
      | None() -> return void
      | Some((_, updateFun)) -> updateFun(this)
      }
    }
  }

  mutable fun timeStamp(): Int {
    this.!time = this.time + 1;
    this.time
  }

  mutable fun mkdir<Value: File>(
    dirNameStr: String,
    content: Array<(String, Value)> = Array[],
  ): Dir<Value> {
    this.mkdirMulti(
      dirNameStr,
      content.map(kv -> {
        (key, value) = kv;
        (key, Array[value])
      }),
    )
  }

  mutable fun mkdirMulti<Value: File>(
    dirNameStr: String,
    content: Array<(String, Array<Value>)> = Array[],
  ): Dir<Value> {
    dirName = DirName::create(dirNameStr);
    if (this.state.dirs.state.containsKey(dirName)) {
      throw DirAlreadyExists(dirName);
    };
    vector = mutable Vector[];
    for (kv in content) {
      (key, values) = kv;
      baseName = SID::create(key);
      path = Path(dirName, baseName);
      vector.push(FixedRow(baseName, (path, values)));
    };
    vector.sort();
    fixedData = FixedData{dirName, data => vector.toArray()};
    dir = Dir{time => this.timeStamp(), dirName, fixedData};
    dirRef: DirRef<Value> = DirRef(dirName);
    this.!state = this.state.setDir(dirRef, dir);
    dir
  }

  mutable fun setDir<T: File>(dirRef: DirRef<T>, dir: Dir<T>): void {
    this.!state = this.state.setDir(dirRef, dir);
  }

  readonly fun getDir<T: File>(dirRef: DirRef<T>): Dir<T> {
    this.state.getDir(freeze(dirRef));
  }

  readonly fun maybeGetDir<T: File>(dirRef: DirRef<T>): ?Dir<T> {
    this.state.maybeGetDir(freeze(dirRef));
  }

  mutable fun setFun<T1: File, T2: File>(
    funRef: FunRef<T1, T2>,
    mapFun: MapFun<T1, T2>,
  ): void {
    this.!state = this.state.setFun(funRef, mapFun);
  }
}

class State{dirs: Dirs = Dirs{}, funs: Funs = Funs{}} {
  fun setDir<T: File>(dirRef: DirRef<T>, dir: Dir<T>): this {
    !this.dirs = this.dirs.set(dirRef, dir);
    this
  }

  fun getDir<T: File>(dirRef: DirRef<T>): Dir<T> {
    this.dirs.get(dirRef)
  }

  fun maybeGetDir<T: File>(dirRef: DirRef<T>): ?Dir<T> {
    this.dirs.maybeGet(dirRef)
  }

  fun setFun<T1: File, T2: File>(
    funRef: FunRef<T1, T2>,
    mapFun: MapFun<T1, T2>,
  ): this {
    !this.funs = this.funs.set(funRef, mapFun);
    this
  }
}

class DirRef<Value: File>(dirName: DirName)

class Dirs{state: SortedMap<DirName, File> = SortedMap[]} {
  fun set<T: File>(key: DirRef<T>, value: Dir<T>): this {
    !this.state = this.state.set(key.dirName, unsafeToFile(value));
    this
  }
  fun get<T: File>(key: DirRef<T>): Dir<T> {
    unsafeFromFile(this.state.get(key.dirName));
  }
  fun maybeGet<T: File>(key: DirRef<T>): ?Dir<T> {
    this.state.maybeGet(key.dirName).map(unsafeFromFile)
  }
}

value class FunRef<T1, T2>(dirName: DirName)

class Funs{state: SortedMap<DirName, File> = SortedMap[]} {
  fun set<T1: File, T2: File>(
    key: FunRef<T1, T2>,
    value: MapFun<T1, T2>,
  ): this {
    !this.state = this.state.add(key.dirName, unsafeToFile(value));
    this
  }
  fun get<T1: File, T2: File>(key: FunRef<T1, T2>): MapFun<T1, T2> {
    unsafeFromFile(this.state.get(key.dirName));
  }
}

module end;
