/*****************************************************************************/
/* File logic.
 *
 * This code validates files and directory names. So we check that we use
 * the right characters (a-zA-Z0-9_) and that the paths are properly separated
 * with '/'.
 *
 */
/*****************************************************************************/

module SKFS;

const root: DirName = DirName::create("/");

base class FileName extends File uses Hashable, Orderable, Show

class Path(dirName: DirName, baseName: BaseName) extends FileName {
  static fun fromString(path: String): this {
    chars = path.chars();
    i = chars.size() - 1;
    lastSlashOpt = loop {
      if (i < 0) {
        break None();
      };
      if (chars[i] == '/') {
        break Some(i);
      };
      !i = i - 1;
    };
    lastSlash = lastSlashOpt match {
    | None() -> error(path, "Invalid path, no '/' found")
    | Some(x) -> x
    };
    dirNameChars = mutable Vector[];
    baseNameChars = mutable Vector[];
    for (j in Range(0, chars.size())) {
      if (j <= lastSlash) {
        dirNameChars.push(chars[j]);
      } else {
        baseNameChars.push(chars[j])
      }
    };
    if (baseNameChars.size() == 0) {
      error(path, "Invalid path, missing BaseName");
    };
    dirName = DirName::create(String::fromChars(dirNameChars.toArray()));
    baseName = BaseName::create(String::fromChars(baseNameChars.toArray()));
    Path(dirName, baseName)
  }

  fun toString(): String {
    this.dirName.toString() + this.baseName
  }
}

class DirName private (dirName: String) extends FileName {
  static fun create(dirName: String): DirName {
    static::validateDirName(dirName);
    static(dirName)
  }

  fun pre(): this {
    DirName(this.dirName + "pre/")
  }

  fun next(): this {
    DirName(this.dirName + "next/")
  }

  static private fun validateDirName(dirName: String): void {
    validator = mutable SKFSImpl.NameValidator(dirName, dirName.chars(), 0);
    validator.go()
  }

  fun toString(): String {
    this.dirName
  }
}

base class BaseName extends FileName {
  static overridable fun create(str: String): this {
    for (char in str) {
      if (char >= '0' && char <= '9' || char == '-') {
        return IID::create(str);
      } else {
        return SID::create(str);
      }
    };
    SID::create(str)
  }
}

class IID(value: Int) extends BaseName {
  static fun create(key: String): IID {
    chars = Vector::mcreateFromItems(key.chars());
    chars.reverse();
    base = 1;
    n = 0;
    for (c in chars) {
      if (c == '-') {
        !n = -n;
        continue;
      };
      !n = n + (c.code() - '0'.code()) * base;
      !base = base * 10;
    };
    IID(n)
  }

  fun toString(): String {
    this.value.toString()
  }
}
class SID private (value: String) extends BaseName {
  static private fun validateBaseName(baseName: String): void {
    validator = mutable SKFSImpl.NameValidator(baseName, baseName.chars(), 0);
    validator.mustBeBaseName();
    if (!validator.reachedEnd()) {
      validator.error("Unexpected characters after file name");
    }
  }

  static fun create(value: String): BaseName {
    static::validateBaseName(value);
    SID(value)
  }

  fun toString(): String {
    this.value
  }
}

base class Exception extends .Exception uses Show
class InvalidPathExn(dirName: String, reason: String) extends SKFS.Exception {
  fun toString(): String {
    `Invalid path(${this.dirName}): ${this.reason}`
  }
}

fun error<T>(fileName: String, msg: String): T {
  if (!testMode) {
    print_error("Error: " + msg + "\n");
  };
  throw (SKFS.InvalidPathExn(fileName, msg))
}

module end;

/*****************************************************************************/
/* Implementation details. */
/*****************************************************************************/

module SKFSImpl;

// This is a state machine that walks the string and checks that is it a
// correct dirName.

mutable class NameValidator(
  dirName: String,
  chars: Vector<Char>,
  mutable idx: Int,
) {
  readonly fun error(msg: String): void {
    SKFS.error(this.dirName, msg)
  }

  readonly fun current(): Char {
    this.chars[this.idx]
  }

  readonly fun reachedEnd(): Bool {
    this.idx >= this.chars.size()
  }

  mutable fun next(): void {
    this.!idx = this.idx + 1
  }

  mutable fun go(): void {
    if (this.reachedEnd()) {
      this.error("path is empty");
    };
    while (this.idx < this.chars.size() - 1) {
      this.mustBeSlash();
      this.mustBeBaseName();
    };
    this.mustBeSlash();
    if (!this.reachedEnd()) {
      this.error("Unexpected characters at the end of the path");
    };
  }

  mutable fun mustBeSlash(): void {
    if (this.reachedEnd()) {
      this.error("Expected a slash, reached the end of the path instead");
    };
    c = this.current();
    if (c == '/') {
      this.next()
    } else {
      this.error(`Expected a slash, found '${c}' instead`);
    }
  }

  static fun validChar(c: Char): Bool {
    c match {
    | '_' | '-' -> true
    | _ -> false
    }
  }

  mutable fun mustBeBaseName(): void {
    if (this.reachedEnd() || this.current() == '/') {
      this.error("Empty baseName");
    };
    c = this.current();
    if (c >= '0' && c <= '9' || c == '-') {
      this.next();
      while (!this.reachedEnd()) {
        !c = this.current();
        if (c >= '0' && c <= '9') {
          this.next();
        } else {
          break void
        };
      }
    } else {
      !c = this.current();
      if (
        (c >= 'a' && c <= 'z') ||
        c >= 'A' && c <= 'Z' ||
        static::validChar(c)
      ) {
        while (!this.reachedEnd()) {
          !c = this.current();
          if (
            (c >= 'a' && c <= 'z') ||
            c >= 'A' && c <= 'Z' ||
            c >= '0' && c <= '9' ||
            static::validChar(c)
          ) {
            this.next();
          } else {
            break void
          };
        }
      }
    }
  }
}

module end;

module SKFSTest;

fun testDirNameFail(str: String): void {
  expectFail(`Test DirName: '${str}'`, () -> _ = SKFS.DirName::create(str));
}

fun testDirNamePass(str: String): void {
  expectPass(`Test DirName: '${str}'`, () -> _ = SKFS.DirName::create(str));
}

fun testBaseNameFail(str: String): void {
  expectFail(`Test BaseName: '${str}'`, () -> _ = SKFS.BaseName::create(str));
}

fun testBaseNamePass(str: String): void {
  expectPass(`Test BaseName: '${str}'`, () -> _ = SKFS.BaseName::create(str));
}

fun testDirName(): void {
  testDirNameFail(" ");
  testDirNameFail("??$");
  testDirNameFail(".");
  testDirNameFail("//");
  testDirNameFail("\n");
  testDirNamePass("/");
  testDirNameFail("/missingTrailingSlash");
  testDirNamePass("/1223/");
  testDirNamePass("/dir/");
  testDirNamePass("/dir1/dir2/");
}

fun testBaseName(): void {
  testBaseNameFail("");
  testBaseNameFail(" ");
  testBaseNamePass("aa");
  testBaseNameFail("aa/");
  testBaseNameFail("abc ");
  testBaseNamePass("123");
  testBaseNamePass("__");
  testBaseNamePass("-123");
  testBaseNamePass("hello-world");
}

module end;
