module alias AP = ArgumentParser;

const argsSchema: Array<AP.Param> = Array[
  AP.BoolParam{name => "all", help => "run all the tests", negatable => false},
  AP.BoolParam{name => "debug", help => "", negatable => false},
  AP.BoolParam{name => "sessions", help => "", negatable => false},
  AP.StringParam{name => "test", help => "The name of the test to run"},
  AP.StringParam{name => "init", help => "Initializes a new data file"},
  AP.StringParam{name => "data", help => "Loads an existing data file"},
  AP.StringParam{
    name => "connect",
    help => "Same as --subscribe, but sends the initial state first",
  },
  AP.StringParam{
    name => "subscribe",
    help => "Subscribes to a directory change",
  },
  AP.IntParam{name => "reconnect", help => "reconnects to a session id"},
  AP.StringParam{name => "cmd", help => "Name of the command to run on change"},
];

const parsedArgs: AP.ParseResult = AP.parse(argsSchema, arguments()) match {
| Success(value) -> value
| Failure(error) ->
  print_error(error.getMessage());
  exit(2)
};

const argMap: Map<String, AP.Value> = parsedArgs.argumentValues;

native base class Proc

@cpp_extern("SKIP_exec")
native fun exec(String): Proc;

@cpp_extern("SKIP_write_to_proc")
native fun writeToProc(Proc, String): void;

@cpp_extern("SKIP_wait_for_proc")
native fun waitForProc(Proc): Int;

untracked fun main(): void {
  if (parsedArgs.unknown.size() != 0) {
    unknownOptions = parsedArgs.unknown.filter(x ->
      x != "" && x.getIter().next() == Some('-')
    );
    for (option in unknownOptions) {
      if (option != "--help") print_error("Unknown option: " + option);
    };
    if (unknownOptions.size() != 0) {
      print_error(AP.help(argsSchema));
      exit(2);
    }
  };
  argFiles = parsedArgs.unknown.toArray();
  if (argFiles.size() > 0) {
    for (file in argFiles) {
      print_error("Error: don't know what to do with " + file);
    };
    exit(2);
  };

  argMap.maybeGet("sessions" + "") match {
  | Some(AP.BoolValue _) ->
    if (SKFS.gHasContext() == 0) {
      invariant(argMap.maybeGet("data" + "") is Some(AP.MissingValue{}));
      print_error("Error: option --data is missing");
      exit(2);
    };
    startContext = SKFS.gContextGet();
    context = SKFS.Context::fromSaved(startContext);
    startTime = context.time;
    for (id => dirName in context.sessions) {
      sub = context.unsafeGetEagerDir(dirName).subs[id];
      print_string(
        id.toString() +
          "\t" +
          dirName.toString() +
          "\t" +
          if (sub.status == 0) "CONNECTED" else "DISCONNECTED",
      );
    };
    _context = SKFS.gContextSync(startTime, startContext, context.clone());
    return void
  | _ -> void
  };

  argMap.maybeGet("reconnect" + "") match {
  | Some(AP.IntValue{value => sessionID}) ->
    if (SKFS.gHasContext() == 0) {
      invariant(argMap.maybeGet("data" + "") is Some(AP.MissingValue{}));
      print_error("Error: option --data is missing");
      exit(2);
    };
    startContext = SKFS.gContextGet();
    context = SKFS.Context::fromSaved(startContext);
    startTime = context.time;
    dirName = context.sessions.maybeGet(sessionID) match {
    | None() ->
      print_error("Error: session not found");
      exit(2)
    | Some(x) -> x
    };
    edir = context.unsafeGetEagerDir(dirName);
    edir.reconnect(context, sessionID);
    _context = SKFS.gContextSync(startTime, startContext, context.clone());
    return void
  | _ -> void
  };

  subscribe = argMap.maybeGet("connect" + "") match {
  | Some(AP.StringValue{value => dirName}) -> Some((dirName, true))
  | _ ->
    argMap.maybeGet("subscribe" + "") match {
    | Some(AP.StringValue{value => dirName}) -> Some((dirName, false))
    | _ -> None()
    }
  };

  subscribe match {
  | None() -> void
  | Some((dirNameStr, init)) ->
    if (SKFS.gHasContext() == 0) {
      invariant(argMap.maybeGet("data" + "") is Some(AP.MissingValue{}));
      print_error("Error: option --data is missing");
      exit(2);
    };
    startContext = SKFS.gContextGet();
    context = SKFS.Context::fromSaved(startContext);
    startTime = context.time;
    dirName = SKFS.DirName::create(dirNameStr);
    edir = context.unsafeMaybeGetDir(dirName) match {
    | Some(SKFS.LazyDir _) ->
      print_error("Error: cannot connect to a lazy directory");
      exit(2)
    | Some(edir @ SKFS.EagerDir _) -> edir
    | _ ->
      print_error("Error: directory not found");
      exit(3)
    };
    cmd = argMap.maybeGet("cmd" + "") match {
    | Some(AP.StringValue{value => x}) -> x
    | _ ->
      print_error("Error: missing --cmd");
      exit(4)
    };
    sessionID = edir.subscribe(context, cmd, init);
    print_string(sessionID.toString());
    _context = SKFS.gContextSync(startTime, startContext, context.clone());
    return void
  };

  if (argMap.maybeGet("all") is Some(AP.BoolValue _)) {
    testFuns = SKFSTest.getAllTests();
    for (testName => testFun in testFuns) {
      print_string(
        "/*****************************************************************************/",
      );
      print_string("/* " + testName + " */");
      print_string(
        "/*****************************************************************************/",
      );
      _ = testFun();
      print_string("");
    };
    return void;
  } else if (argMap.maybeGet("test") is Some(AP.StringValue _)) {
    testFuns = SKFSTest.getAllTests();
    testName = argMap["test"] match {
    | AP.StringValue{value => testName} ->
      if (!testFuns.containsKey(testName)) {
        print_error("Error: unknown test " + testName + "\n");
        for (key => _ in testFuns) {
          print_error("  " + key + "\n");
        };
        exit(4);
      };
      testName
    | _ ->
      print_error("Invalid test name type");
      exit(2)
    };
    context = testFuns[testName]();
    if (argMap.maybeGet("debug") is Some(AP.BoolValue _)) {
      SKFS.toplevel(context)
    } else {
      return void
    }
  } else if (argMap.maybeGet("init") is Some(AP.StringValue _)) {
    SKFS.runWithGc(SKSQL.makeSqlContext().clone(), (ctx) ~> SKFS.CStop(ctx));
    return void;
  } else if (argMap.maybeGet("data") is Some(AP.StringValue _)) {
    // this was handled in the C++ side
    void
  };
  if (argMap.maybeGet("debug") is Some(AP.BoolValue _)) {
    SKFS.toplevel(mutable SKFS.Context{});
  } else {
    SKSQL.eval(SKSQL.makeSqlContext())
  }
}
