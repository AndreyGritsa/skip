module SKFS;

@cpp_runtime("SKIP_Reactive_unsafe")
private native fun unsafeToInt<T>(T): Int;

@cpp_extern("SKIP_unsafe")
private native fun unsafeFromFile<T>(File): T;

@cpp_extern("SKIP_unsafe")
private native fun unsafeToFile<T>(T): File;

private class RefCountedTable<T: File>(
  cache: SortedMap<BaseName, Map<T, Int>>,
) {
  fun create(): this {
    static(SortedMap[])
  }

  fun add(key: BaseName, values: Array<T>): this {
    newMap = this.cache.maybeGet(key) match {
    | None() ->
      newMap = mutable Map[];
      values.each(value -> {
        refCount = if (newMap.containsKey(value)) newMap[value] else {
          0
        };
        newMap![value] = refCount + 1;
      });
      newMap
    | Some(map) ->
      newMap = map.clone();
      values.each(value -> {
        refCount = if (newMap.containsKey(value)) newMap[value] else {
          0
        };
        newMap![value] = refCount + 1;
      });
      newMap
    };
    !this.cache = this.cache.set(key, unsafe_chill_trust_me(newMap));
    this
  }

  fun remove(key: BaseName, values: Array<T>): this {
    newMap = this.cache.maybeGet(key) match {
    | None() -> invariant_violation("Cannot remove a nonexistent entry")
    | Some(map) ->
      newMap = map.clone();
      values.each(value -> {
        refCount = if (newMap.containsKey(value)) newMap[value] else {
          0
        };
        !refCount = refCount - 1;
        if (refCount > 0) {
          newMap![value] = refCount;
        } else {
          newMap.remove(value);
        }
      });
      newMap
    };
    !this.cache = this.cache.set(key, unsafe_chill_trust_me(newMap));
    this
  }

  fun containsKey(key: BaseName): Bool {
    this.cache.containsKey(key)
  }

  fun get(key: BaseName): Array<T> {
    result = mutable Vector[];
    this.cache.maybeGet(key).each(map ->
      map.each((key, refCount) -> {
        invariant(refCount > 0);
        for (_ in Range(0, refCount)) {
          result.push(key)
        }
      })
    );
    result.sort();
    result.toArray()
  }

  fun keys(): mutable Iterator<BaseName> {
    this.cache.keys()
  }
}

private mutable class ArrayDiff<T: File>{
  oldValues: Array<T>,
  newValues: Array<T>,
  mutable index1: Int = 0,
  mutable index2: Int = 0,
  toChange: mutable Vector<(T, Int)> = mutable Vector[],
} {
  private mutable fun loopThis(): void {
    valueOpt1 = this.oldValues.maybeGet(this.index1);
    valueOpt2 = this.newValues.maybeGet(this.index2);
    (valueOpt1, valueOpt2) match {
    | (None(), None()) -> void
    | (None(), Some(value)) ->
      this.toChange.push((value, 1));
      this.!index2 = this.index2 + 1;
      this.loopThis()
    | (Some(value), None()) ->
      this.toChange.push((value, -1));
      this.!index1 = this.index1 + 1;
      this.loopThis()
    | (Some(value1), Some(value2)) ->
      unsafeToInt(value1).compare(unsafeToInt(value2)) match {
      | LT() ->
        this.toChange.push((value1, -1));
        this.!index1 = this.index1 + 1
      | GT() ->
        this.toChange.push((value2, 1));
        this.!index2 = this.index2 + 1
      | EQ() ->
        this.!index1 = this.index1 + 1;
        this.!index2 = this.index2 + 1
      };
      this.loopThis()
    }
  }
  mutable fun getResult(): (Array<(T, Int)>) {
    this.loopThis();
    this.toChange.toArray()
  }
}

private fun diffArrays<T: File>(
  oldValues: Array<T>,
  newValues: Array<T>,
): (Array<T>, Array<T>) {
  vecDiff = mutable ArrayDiff{oldValues, newValues};
  toChange = vecDiff.getResult();
  toAdd = mutable Vector[];
  toRemove = mutable Vector[];
  for (valueAndIncr in toChange) {
    (value, incr) = valueAndIncr;
    if (incr < 0) toRemove.push(value) else toAdd.push(value);
  };
  (toAdd.toArray(), toRemove.toArray())
}

value class Source(
  origKey: Path,
  targetDir: DirName,
) uses Hashable, Orderable, Show {
  fun toString(): String {
    "Source(" + this.origKey + ", " + this.targetDir + ")"
  }
}

class Table<Value: File> private {
  refCountedTable: RefCountedTable<Value>,
  sourceTable: SortedMap<Source, Array<Value>>,
} {
  static fun create(): this {
    static{
      refCountedTable => RefCountedTable(SortedMap[]),
      sourceTable => SortedMap[],
    }
  }

  fun setWithStatus(
    source: Source,
    key: BaseName,
    values: Array<Value>,
  ): (this, Bool) {
    !values = values.map(x -> intern(x));
    newValues = {
      x = Vector::mcreateFromItems(values);
      x.sort();
      x.toArray()
    };
    this.sourceTable.maybeGet(source) match {
    | None() ->
      !this.sourceTable = this.sourceTable.set(source, newValues);
      !this.refCountedTable = this.refCountedTable.add(key, newValues);
      (this, true)
    | Some(oldValues) ->
      !this.sourceTable = this.sourceTable.set(source, newValues);
      (toAdd, toRemove) = diffArrays(oldValues, newValues);
      !this = if (toRemove.size() > 0) {
        !this.refCountedTable = this.refCountedTable.remove(key, toRemove);
        this
      } else {
        this
      };
      !this = if (toAdd.size() > 0) {
        !this.refCountedTable = this.refCountedTable.add(key, toAdd);
        this;
      } else {
        this
      };
      (this, toAdd.size() > 0 || toRemove.size() > 0)
    }
  }

  fun set(source: Source, key: BaseName, values: Array<Value>): this {
    (!this, _) = this.setWithStatus(source, key, values);
    this
  }

  fun get(key: BaseName): Array<Value> {
    this.refCountedTable.get(key)
  }

  fun containsKey(key: BaseName): Bool {
    this.refCountedTable.containsKey(key);
  }

  fun keys(): mutable Iterator<BaseName> {
    this.refCountedTable.keys()
  }
}

module end;

module SKFSTest;

class TestFailure() extends Exception

class SBox(value: String) extends SKFS.File {
  fun toString(): String {
    "SBox(" + this.value + ")"
  }
}

fun testTable(
  rtable: SKFS.Table<SBox>,
  map: readonly Map<(SKFS.Source, SKFS.BaseName), Array<SBox>>,
  keyRange: Int,
): void {
  for (keyNbr in Range(0, keyRange)) {
    key = SKFS.BaseName::create("" + keyNbr);
    values = mutable Vector[];
    for (sourceKey => array in map) {
      (_, k) = sourceKey;
      if (k == key) {
        array.each(value -> values.push(value))
      }
    };
    values.sort();
    valuesMap = values.toArray();
    valuesTable = rtable.get(key);
    mvaluesTable = Array::mcreateFromItems(valuesTable);
    mvaluesTable.sort();
    !valuesTable = freeze(mvaluesTable);
    if (valuesMap != valuesTable) {
      debug(`Inconsistent result for key: ${key}`);
      debug(`TestMap says: ${valuesMap}`);
      debug(`Rtable says : ${valuesTable}`);
      throw TestFailure();
    }
  }
}

fun test(): void {
  // Config
  sourceRange = 2;
  keyRange = 1000;
  valueSize = 8;
  valueRange = 8;
  iterations = 300;
  percentChancesOfRemoval = 10;
  verbose = false;

  debug("Reactive table Test: STARTING");
  try {
    r = Random::mcreate(23);
    rtable = SKFS.Table::create();
    map = mutable Map<(SKFS.Source, SKFS.BaseName), Array<SBox>>[];
    for (_ in Range(0, iterations)) {
      root = SKFS.DirName::create("/");
      source = SKFS.Source(
        SKFS.Path::create(
          root,
          SKFS.BaseName::create("" + r.random(0, sourceRange)),
        ),
        root,
      );
      key = SKFS.BaseName::create("" + r.random(0, keyRange));
      if (r.random(0, 100) < percentChancesOfRemoval) {
        !rtable = rtable.set(source, key, Array[]);
        map![(source, key)] = Array[];
      } else {
        values = mutable Vector[];
        for (_ in Range(0, valueSize)) {
          values.push(SBox("" + r.random(0, valueRange)));
        };
        if (verbose) {
          debug(`Adding: (${source}, ${key}) => ${values})`);
        };
        arr = values.toArray();
        !rtable = rtable.set(source, key, arr);
        !rtable = intern(rtable);
        map![(source, key)] = arr;
        testTable(rtable, map, keyRange);
      }
    };
    debug("Reactive table test: OK");
  } catch {
  | TestFailure() -> debug("FAILED")
  }
}

module end;
