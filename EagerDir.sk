/*****************************************************************************/
/* Eager directories. */
/*****************************************************************************/
module SKFS;

/*****************************************************************************/
/* Constants. */
/*****************************************************************************/

const PURGE_LIMIT: Int = 30;

/*****************************************************************************/
/* The signature of a function used by apply. */
/*****************************************************************************/

type MapFun = (
  mutable Context,
  mutable Writer,
  BaseName,
  mutable Iterator<File>,
) ~> void;

/*****************************************************************************/
/* The action passed to aggregate functions. */
/*****************************************************************************/

value class Aggregate(state: File, compactor: ICompactor)

/*****************************************************************************/
/* Compaction types and helpers. */
/*****************************************************************************/

class Compactor{
  compactor: ICompactor,
  fixed: Array<(BaseName, File)>,
  modified: SortedMap<BaseName, File>,
} {
  static fun create(
    fixedData: FixedData<Array<File>>,
    compactor: ICompactor,
  ): this {
    acc = mutable Vector[];
    current = mutable IntRef(0);
    while (current.value < fixedData.size()) {
      key = fixedData[current.value].key;
      iterator = static::makeCompactKeyIterator(fixedData, key, current);
      acc.push((key, compactor.init(iterator)));
    };
    fixed = acc.toArray();
    static{compactor, fixed, modified => SortedMap[]}
  }

  static fun makeCompactKeyIterator(
    fixedData: FixedData<Array<File>>,
    key: BaseName,
    current: mutable IntRef,
  ): mutable Iterator<File> {
    while (
      current.value < fixedData.size() &&
      fixedData[current.value].key == key
    ) {
      for (file in fixedData[current.value].value.i1) {
        yield file;
      };
      current.incr()
    };
  }

  fun get(key: BaseName): ?File {
    this.modified.maybeGet(key) match {
    | None() -> this.getFixed(key, 0, this.fixed.size() - 1)
    | x -> x
    }
  }

  fun getArray(key: BaseName): Array<File> {
    this.get(key) match {
    | None() -> Array[]
    | Some(x) -> Array[x]
    }
  }

  private fun getFixed(key: BaseName, i: Int, j: Int): ?File {
    if (i > j) {
      return None();
    };
    pivot = (i + j) / 2;
    key.compare(this.fixed[pivot].i0) match {
    | LT() -> this.getFixed(key, i, pivot - 1)
    | EQ() -> Some(this.fixed[pivot].i1)
    | GT() -> this.getFixed(key, pivot + 1, j)
    }
  }
}

class ICompactor{
  canReset: Bool,
  init: (mutable Iterator<File> ~> File),
  update: (File, Array<File>, Array<File>) ~> ?File,
}

mutable class IntRef(mutable value: Int) {
  mutable fun incr(): void {
    this.!value = this.value + 1
  }
}

/*****************************************************************************/
/* Ranges. */
/*****************************************************************************/

value class KeyRange(start: BaseName, end: BaseName) uses Orderable, Show {
  fun toString(): String {
    `[${this.start}, ${this.end}]`
  }
}

/*****************************************************************************/
/* Keys and newDirs produced during a mapping. */
/*****************************************************************************/

value class MInfo(
  keys: Array<BaseName>,
  newDirs: Array<DirName>,
  reads: ReadSet,
) {
  static fun empty(): this {
    MInfo(Array[], Array[], ReadSet[])
  }
  fun isEmpty(): Bool {
    this.keys.size() == 0 && this.newDirs.size() == 0 && this.reads.isEmpty()
  }
}

/*****************************************************************************/
/* An Eager Directory. */
/*****************************************************************************/

class EagerDir{
  time: Int,
  dirName: DirName,
  input: Bool,
  fixedData: FixedData<Array<File>>,
  totalSize: Int,
  creator: ?ArrowKey,
  fixedOld: FixedSingle<Source, MInfo> = FixedSingle::empty(),
  data: DMap<BaseName, SortedMap<Source, Array<File>>> = Nil(),
  old: SortedMap<Source, MInfo> = SortedMap[],
  parents: FixedSingle<
    DirName,
    (MapFun, ?Array<KeyRange>),
  > = FixedSingle::empty(),
  childDirs: SortedSet<DirName> = SortedSet[],
  slices: RangeMapList<BaseName, DirName> = RangeMapList[],
  compactor: ?Compactor = None(),
  purgeCount: Int = 0,
} extends Dir {
  fun purgeOld(): FixedSingle<Source, MInfo> {
    current = 0;
    acc = mutable Vector[];
    for (source => minfo in this.old) {
      while (
        current < this.fixedOld.size() &&
        this.fixedOld[current].i0 < source
      ) {
        acc.push(this.fixedOld[current]);
        !current = current + 1;
      };
      while (
        current < this.fixedOld.size() &&
        this.fixedOld[current].i0 == source
      ) {
        !current = current + 1;
      };
      if (!minfo.isEmpty()) {
        acc.push((source, minfo));
      }
    };
    while (current < this.fixedOld.size()) {
      acc.push(this.fixedOld[current]);
      !current = current + 1;
    };
    FixedSingle(acc.toArray());
  }

  fun purgeData(): SKFS.FixedData<Array<SKFS.File>> {
    current = 0;
    acc = mutable Vector[];

    this.data.eachWithTime((key, time) -> {
      while (
        current < this.fixedData.size() &&
        this.fixedData[current].key < key
      ) {
        acc.push(this.fixedData[current]);
        !current = current + 1;
      };
      map = this.data.maybeGet(key).fromSome();
      for (source => values in map) {
        while (
          current < this.fixedData.size() &&
          this.fixedData[current].key == key &&
          this.fixedData[current].value.i0 < source
        ) {
          acc.push(this.fixedData[current]);
          !current = current + 1;
        };
        if (values.size() > 0) {
          acc.push(FixedRow(key, (source, values), TimeTag::create(time)));
        };
        while (
          current < this.fixedData.size() &&
          this.fixedData[current].key == key &&
          this.fixedData[current].value.i0 == source
        ) {
          !current = current + 1;
        };
      };
      while (
        current < this.fixedData.size() &&
        this.fixedData[current].key == key
      ) {
        acc.push(this.fixedData[current]);
        !current = current + 1;
      };
    });
    while (current < this.fixedData.size()) {
      acc.push(this.fixedData[current]);
      !current = current + 1;
    };
    FixedDir::create(acc.toArray());
  }

  fun purge(): this {
    fixedOld = this.purgeOld();
    fixedData = this.purgeData();
    this with {old => SortedMap[], data => DMap::empty(), fixedData, fixedOld};
  }

  fun isInput(): Bool {
    this.input
  }

  fun getTime(): Int {
    this.time
  }

  fun getChangesAfter(time: Int): Set<BaseName> {
    this.data.getChangesAfter(time).union(this.fixedData.getChangesAfter(time))
  }

  private static fun fixedMapData(
    context: mutable Context,
    oldVec: mutable Vector<(Source, MInfo)>,
    parent: EagerDir,
    childName: DirName,
    f: MapFun,
    acc: mutable Vector<FixedRow<Array<File>>>,
    current: mutable IntRef,
  ): void {
    key = parent.fixedData[current.value].key;
    // fast path
    if (
      parent.compactor is None() &&
      current.value + 1 < parent.fixedData.size() &&
      parent.fixedData[current.value + 1].key != key
    ) {
      fixedFiles = parent.fixedData[current.value].value.i1.iterator();
      static::mapRow(
        context,
        acc,
        oldVec,
        parent.dirName,
        childName,
        key,
        fixedFiles,
        f,
      );
      current.incr();
      return void;
    };

    valueAcc = mutable Vector[];
    while (
      current.value < parent.fixedData.size() &&
      parent.fixedData[current.value].key == key
    ) {
      for (elt in parent.fixedData[current.value].value.i1) {
        valueAcc.push(elt);
      };
      current.incr();
    };
    fixedFiles = parent.compactor match {
    | None() -> valueAcc.iterator()
    | Some(compact) -> compact.getArray(key).iterator()
    };
    static::mapRow(
      context,
      acc,
      oldVec,
      parent.dirName,
      childName,
      key,
      fixedFiles,
      f,
    );
  }

  private static fun subMapData(
    obstack: Obstack,
    context: mutable Context,
    parent: EagerDir,
    childName: DirName,
    f: MapFun,
    currentStart: Int,
    currentEnd: Int,
    start: ?Boundary<BaseName>,
    end: ?BaseName,
  ): (
    readonly Vector<FixedRow<Array<File>>>,
    readonly Vector<(Source, MInfo)>,
    ?BaseName,
    Int,
  ) {
    acc = mutable Vector[];
    oldVec = mutable Vector[];
    current = mutable IntRef(currentStart);
    size = 0;

    for (key => _ in parent.data.itemsAfterKey(start)) {
      end match {
      | Some(endKey) if (key > endKey) -> break void
      | _ -> void
      };
      while (
        current.value <= currentEnd &&
        parent.fixedData[current.value].key < key
      ) {
        fixedKey = parent.fixedData[current.value].key;
        static::fixedMapData(
          context,
          oldVec,
          parent,
          childName,
          f,
          acc,
          current,
        );
        !size = size + 1;
        if (shouldGC(obstack) != 0) {
          return (acc, oldVec, Some(fixedKey), current.value);
        }
      };
      while (
        current.value <= currentEnd &&
        parent.fixedData[current.value].key == key
      ) {
        current.incr();
      };

      static::mapRow(
        context,
        acc,
        oldVec,
        parent.dirName,
        childName,
        key,
        parent.getIterRaw(key),
        f,
      );
      !size = size + 1;
      if (shouldGC(obstack) != 0) {
        return (acc, oldVec, Some(key), current.value);
      }
    };

    while (current.value <= currentEnd) {
      fixedKey = parent.fixedData[current.value].key;
      static::fixedMapData(context, oldVec, parent, childName, f, acc, current);
      !size = size + 1;
      if (shouldGC(obstack) != 0) {
        return (acc, oldVec, Some(fixedKey), current.value);
      }
    };
    (acc, oldVec, None(), current.value)
  }

  private static fun mapData(
    context: mutable Context,
    oldVec: mutable Vector<(Source, MInfo)>,
    parent: EagerDir,
    childName: DirName,
    f: MapFun,
    acc: mutable Vector<FixedRow<Array<File>>>,
    rangeOpt: ?KeyRange,
  ): void {
    last: ?Boundary<BaseName> = rangeOpt match {
    | None() -> None()
    | Some(range) -> Some(Inclusive(range.start))
    };
    current = rangeOpt match {
    | None() -> 0
    | Some(range) ->
      pos = parent.fixedData.getPos(range.start);
      if (pos < 0) 0 else pos
    };
    end = rangeOpt.map(r -> r.end);
    currentEnd = end match {
    | None() -> parent.fixedData.size() - 1
    | Some(key) ->
      pos = parent.fixedData.getPos(key);
      if (pos < parent.fixedData.size() && parent.fixedData[pos].key != key) {
        !pos = pos - 1;
      };
      min(parent.fixedData.size() - 1, pos)
    };

    loop {
      lcurrent = current;
      llast = last;

      (localAcc, localOldVec, lastSkipped, !current) = withRegion(
        context,
        (obstack, context) ~> {
          static::subMapData(
            obstack,
            context,
            parent,
            childName,
            f,
            lcurrent,
            currentEnd,
            llast,
            end,
          );
        },
      );

      acc.extend(localAcc);
      oldVec.extend(localOldVec);

      !last = lastSkipped.map(x -> Exclusive(x));
      if (last is None _) {
        break void;
      }
    };
  }

  private static fun mapRow(
    context: mutable Context,
    acc: mutable Vector<FixedRow<Array<File>>>,
    oldVec: mutable Vector<(Source, MInfo)>,
    parentName: DirName,
    childName: DirName,
    key: BaseName,
    values: mutable Iterator<File>,
    f: MapFun,
  ): void {
    arrow = ArrowKey(parentName, childName, key);
    context.enter(arrow);

    if (context.debugMode) {
      print_string(`MAP_ROW: ${parentName} ${key}`);
    };

    newDirsCopy = context.newDirs;
    readsCopy = context.reads;

    context.!newDirs = SortedSet[];
    context.!reads = ReadSet[];

    writer = mutable Writer{};
    f(context, writer, key, values);

    kvArray = writer.getWrites();
    newDirs = context.newDirs;
    reads = context.getReads();
    context.!newDirs = newDirsCopy;
    context.!reads = readsCopy;

    context.updateNewDeps(ArrowKey(parentName, childName, key), reads);

    path = Path::create(parentName, key);
    source = Source::create(path);
    time = context.timeStamp();

    for (kv in kvArray) {
      (k, v) = kv;
      acc.push(FixedRow(k, (source, v), TimeTag::create(time)))
    };

    if (!kvArray.isEmpty() || !newDirs.isEmpty()) {
      oldVec.push(
        (source, MInfo(kvArray.map(kv -> kv.i0), newDirs.toArray(), reads)),
      );
    };

    context.leave(arrow);
  }

  static fun isReusable(
    context: readonly Context,
    child: EagerDir,
    parents: FixedSingle<DirName, (MapFun, ?Array<KeyRange>)>,
  ): Bool {
    if (context.unsafeReuse) return true;
    same = (native_eq(parents, child.parents) == 0);
    if (same && child.creator != context.currentArrow()) {
      invariant_violation(
        "Duplicate subdirectory: " +
          child.dirName.toString() +
          "\nFirst created: " +
          inspect(child.creator).toString() +
          "\nThen: " +
          inspect(context.currentArrow()).toString(),
      );
    };
    same
  }

  static fun reuseDir(context: mutable Context, childName: DirName): void {
    if (context.debugMode) {
      print_string(`REUSING: ${childName}`);
    };
    context.!newDirs = context.newDirs.add(childName);
  }

  static fun apply(
    context: mutable Context,
    parentName: DirName,
    childName: DirName,
    f: MapFun,
    compactorOpt: ?ICompactor = None(),
    rangeOpt: ?Array<KeyRange> = None(),
  ): void {
    parents = FixedSingle::create(mutable Vector[(parentName, (f, rangeOpt))]);
    static::applyMany(context, parents, childName, compactorOpt);
  }

  static fun applyMany(
    context: mutable Context,
    parents: FixedSingle<DirName, (MapFun, ?Array<KeyRange>)>,
    childName: DirName,
    compactorOpt: ?ICompactor = None(),
  ): void {
    if (context.newDirs.contains(childName)) {
      error(`Error: directory ${childName.toString()} already exists`);
    };
    context.unsafeMaybeGetEagerDir(childName) match {
    | Some(child) if (static::isReusable(context, child, parents)) ->
      static::reuseDir(context, childName);
      return void
    | _ -> void
    };

    context.!newDirs = context.newDirs.add(childName);

    acc = mutable Vector<FixedRow<Array<File>>>[];
    oldVec = mutable Vector[];

    for (parentName => parentData in parents) {
      (f, rangeOpt) = parentData;
      parent = context.unsafeGetEagerDir(parentName);
      rangeOpt match {
      | None() ->
        static::mapData(context, oldVec, parent, childName, f, acc, None())
      | Some(ranges) ->
        for (range in ranges) {
          static::mapData(
            context,
            oldVec,
            parent,
            childName,
            f,
            acc,
            Some(range),
          );
        }
      }
    };

    acc.sort();
    fixedData = FixedDir::create(acc.toArray());
    time = context.timeStamp();
    totalSize = fixedData.size();
    (!fixedData, compactor) = compactorOpt match {
    | None() -> (fixedData, None())
    | Some(icompactor) ->
      (
        if (icompactor.canReset) fixedData else FixedDir::create(Array[]),
        Some(Compactor::create(fixedData, icompactor)),
      )
    };

    dir = EagerDir{
      time,
      dirName => childName,
      input => false,
      parents,
      fixedData,
      totalSize,
      creator => context.currentArrow(),
      fixedOld => FixedSingle::create(oldVec),
      childDirs => SortedSet[],
      compactor,
    };
    updateDirtyReaders(context, Path::create(childName.tag(), DIR_TAG));
    context.setDir(childName, dir);
    for (parentName => parentData in parents) {
      (_, rangeOpt) = parentData;
      static::addChildToParent(context, parentName, childName, rangeOpt);
    };
    if (context.debugMode) {
      parentNames = parents.items().map(x -> (x.i0, x.i1.i1)).collect(Array);
      print_string(
        `CREATED:  ${childName} (time: ${time}, parents: ${parentNames})`,
      );
    };
  }

  private static fun addChildToParent(
    context: mutable Context,
    parentName: DirName,
    childName: DirName,
    rangeOpt: ?Array<KeyRange>,
  ): void {
    parent = context.unsafeGetEagerDir(parentName);
    rangeOpt match {
    | None() -> !parent.childDirs = parent.childDirs.set(childName)
    | Some(ranges) ->
      for (range in ranges) {
        !parent.purgeCount = parent.purgeCount + 1;
        !parent.slices = parent.slices.add(range.start, range.end, childName)
      }
    };
    if (parent.purgeCount >= PURGE_LIMIT) {
      !parent = parent with {
        slices => parent.purgeSlices(context),
        purgeCount => 0,
      };
    };
    context.setDir(parent.dirName, parent);
  }

  fun getArrayRaw(key: BaseName): Array<File> {
    this.getIterRaw(key).collect(Array)
  }

  private fun getDataIter(key: BaseName): mutable Iterator<File> {
    fixedIter = this.fixedData.getIter(key);
    this.data.maybeGet(key) match {
    | None() ->
      for (rows in fixedIter) {
        for (row in rows.i1) {
          yield row;
        }
      }
    | Some(modified) ->
      fixed = FixedDataIterator::create(this.fixedData.getIter(key));

      for (source => values in modified) {
        while (!fixed.isEnd() && fixed.current().i0.value < source.value) {
          for (file in fixed.current().i1) {
            yield file;
          };
          fixed.next();
        };
        while (!fixed.isEnd() && fixed.current().i0.value == source.value) {
          fixed.next();
        };
        for (file in values) {
          yield file;
        }
      };
      while (!fixed.isEnd()) {
        for (file in fixed.current().i1) {
          yield file;
        };
        fixed.next();
      }
    }
  }

  private fun getIterRaw(key: BaseName): mutable Iterator<File> {
    this.compactor match {
    | None() ->
      for (elt in this.getDataIter(key)) {
        yield elt
      }
    | Some(compact) ->
      for (elt in compact.getArray(key)) {
        yield elt
      }
    }
  }

  private fun getArraySourceKey(source: Source, key: BaseName): Array<File> {
    this.data.maybeGet(key) match {
    | None() -> this.fixedData.getArraySourceKey(source, key).flatten()
    | Some(modified) ->
      modified.maybeGet(source) match {
      | None() -> this.fixedData.getArraySourceKey(source, key).flatten()
      | Some(v) -> v
      }
    }
  }

  static fun update(
    context: mutable Context,
    contextDirty: readonly Map<DirName, readonly Set<BaseName>>,
    contextDirtyReaders: readonly Map<
      DirName,
      readonly Map<DirName, readonly Set<BaseName>>,
    >,
    parentName: DirName,
    mapFun: MapFun,
    rangeOpt: ?Array<KeyRange>,
    child: EagerDir,
  ): void {
    parent = context.unsafeGetEagerDir(parentName);
    childName = child.dirName;

    dirty = mutable Set[];
    if (contextDirtyReaders.containsKey(parent.dirName)) {
      if (contextDirtyReaders[parent.dirName].containsKey(childName)) {
        for (key in contextDirtyReaders[parent.dirName][childName]) {
          rangeOpt match {
          | Some(
            ranges,
          ) if (!ranges.any(range -> range.start <= key && key <= range.end)) ->
            void
          | _ -> dirty.insert(key)
          }
        }
      };
    };
    if (contextDirty.containsKey(parent.dirName)) {
      for (key in contextDirty[parent.dirName]) {
        rangeOpt match {
        | Some(
          ranges,
        ) if (!ranges.any(range -> range.start <= key && key <= range.end)) ->
          void
        | _ -> dirty.insert(key)
        }
      };
    };

    for (key in dirty) {
      context.enter(ArrowKey(parentName, childName, key));
      values = parent.getIterRaw(key);
      path = Path::create(parentName, key);
      source = Source::create(path);
      oldInfo = static::getOld(child, source);
      oldKeys = Set::mcreateFromItems(oldInfo.keys);
      writer = mutable Writer{};
      newDirsCopy = context.newDirs;
      readsCopy = context.reads;
      context.!newDirs = SortedSet[];
      context.!reads = ReadSet[];

      mapFun(context, writer, key, values);

      newDirs = context.newDirs;
      reads = context.getReads();
      context.!newDirs = newDirsCopy;
      context.!reads = readsCopy;

      !child = child.updateNewDirs(context, source, newDirs);
      mapped = writer.getWrites();

      for (read in reads) {
        arrowKey = ArrowKey(parentName, child.dirName, key);
        context.!deps = context.deps.set(read, arrowKey);
      };

      readSet = reads.toSet();

      for (oldRead in oldInfo.reads) {
        if (readSet.contains(oldRead)) continue;
        arrowKey = ArrowKey(parentName, child.dirName, key);
        context.!deps = context.deps.remove(oldRead, arrowKey);
      };

      keys = mutable Vector[];

      for (kv in mapped) {
        (k, rvalues) = kv;

        keys.push(k);
        if (oldKeys.contains(k)) {
          oldKeys.remove(k);
        };
        !child = child.writeEntry(context, path, k, rvalues);
      };

      // Let's remove the keys that no longer exist.
      for (k in oldKeys) {
        !child = child.writeEntry(context, path, k, Array[]);
      };

      // We need to remember what keys we produced for the next
      // time around.
      !child.old[source] = MInfo(keys.toArray(), newDirs.toArray(), reads);

      context.leave(ArrowKey(parentName, childName, key));
    };
    context.setDir(child.dirName, child);
  }

  fun getArray(context: mutable Context, key: BaseName): Array<File> {
    this.getIter(context, key).collect(Array)
  }

  fun getIter(context: mutable Context, key: BaseName): mutable Iterator<File> {
    path = Path::create(this.dirName, key);
    context.addDep(path);
    this.getIterRaw(key)
  }

  fun writeEntry(
    context: mutable Context,
    sourcePath: Path,
    k: BaseName,
    rvalues: Array<File>,
  ): this {
    if (Math.ipow(2, this.data.getHeight() + 1) >= this.fixedData.size()) {
      !this = this.purge();
    };

    source = Source::create(sourcePath);

    oldValues = this.getArraySourceKey(source, k);
    if (native_eq(rvalues, oldValues) == 0) return this;

    totalSize = if (oldValues.size() == 0 && rvalues.size() > 0) {
      this.totalSize + 1
    } else if (oldValues.size() > 0 && rvalues.size() == 0) {
      this.totalSize - 1
    } else {
      this.totalSize
    };

    map = this.data.maybeGet(k) match {
    | None() -> SortedMap[]
    | Some(x) -> x
    };

    !map = map.set(source, rvalues);
    data = this.data.set(TimeTag::create(context.tick), k, map);

    compactor = this.compactor match {
    | None() -> None()
    | Some(cdata) ->
      cdata.get(k) match {
      | None() -> !cdata.modified[k] = cdata.compactor.init(this.getDataIter(k))
      | Some(state) ->
        cdata.compactor.update(state, oldValues, rvalues) match {
        | None() ->
          invariant(cdata.compactor.canReset);
          !cdata.modified[k] = cdata.compactor.init(this.getDataIter(k))
        | Some(new) -> !cdata.modified[k] = new
        }
      };
      Some(cdata)
    };

    context.!dirty = List.Cons(Path::create(this.dirName, k), context.dirty);

    path = Path::create(this.dirName, k);

    if (this.totalSize != totalSize) {
      sizePath = Path::create(this.dirName.size(), SIZE_TAG);
      updateDirtyReaders(context, sizePath);
    };

    !this = this with {data, totalSize, compactor};

    updateDirtyReaders(context, path);

    parentTime = this.time;
    childDirs = SortedSet[];

    for (childName in this.childDirs) {
      context.unsafeMaybeGetEagerDir(childName) match {
      | None() -> continue
      | Some(childDir) ->
        !childDirs = childDirs.set(childName);
        context.!toUpdate = context.toUpdate.set(
          (childDir.time, parentTime),
          Arrow(this.dirName, childName),
        )
      }
    };

    purgeCount = this.purgeCount;
    slices = this.slices;

    for (childNameTime in this.slices.get(k)) {
      !purgeCount = purgeCount + 1;
      childName = childNameTime;
      context.unsafeMaybeGetEagerDir(childName) match {
      | None() -> continue
      | Some(childDir) ->
        context.!toUpdate = context.toUpdate.set(
          (childDir.time, parentTime),
          Arrow(this.dirName, childName),
        )
      }
    };

    if (context.debugMode) {
      name = "" + this.dirName + k;
      print_string(
        `WRITTEN:  ${name}`,
      );
    };

    if (purgeCount >= PURGE_LIMIT) {
      !slices = this.purgeSlices(context);
      !purgeCount = 0;
    };

    this with {childDirs, slices, purgeCount}
  }

  fun purgeSlices(
    context: mutable Context,
  ): RangeMapList<SKFS.BaseName, SKFS.DirName> {
    slices = RangeMapList[];
    childDirs = SortedSet[];
    for (slice in this.slices) {
      for (childDir in slice.i1) {
        !childDirs = childDirs.set(childDir);
      }
    };
    for (child in childDirs) {
      context.unsafeMaybeGetEagerDir(child) match {
      | None() -> continue
      | Some(childDir) ->
        for (parent in childDir.parents.items()) {
          parent.i1.i1 match {
          | None() -> continue
          | Some(ranges) ->
            for (range in ranges) {
              !slices = slices.add(range.start, range.end, childDir.dirName)
            }
          }
        }
      }
    };
    slices
  }

  fun unsafeIterKeys(f: (BaseName, Int) -> void): void {
    fixedData = this.fixedData;
    current = 0;
    this.data.eachWithTime((newKey, time) -> {
      while (current < fixedData.size() && fixedData[current].key < newKey) {
        row = fixedData[current];
        f(row.key, 0);
        !current = current + 1;
      };
      f(newKey, time);
    });
    while (current < fixedData.size()) {
      row = fixedData[current];
      f(row.key, 0);
      !current = current + 1;
    };
  }

  private fun getFixedFiles(current: mutable IntRef): mutable Iterator<File> {
    key = this.fixedData[current.value].key;
    while (
      current.value < this.fixedData.size() &&
      this.fixedData[current.value].key == key
    ) {
      if (this.compactor is None()) {
        for (elt in this.fixedData[current.value].value.i1) {
          yield elt;
        };
      };
      current.incr();
    };

    this.compactor match {
    | None() -> void
    | Some(compact) ->
      for (elt in compact.getArray(key)) {
        yield elt
      }
    }
  }

  fun unsafeGetFileIter(): mutable Iterator<
    (BaseName, mutable Iterator<File>),
  > {
    current = mutable IntRef(0);
    for (key => _ in this.data) {
      while (
        current.value < this.fixedData.size() &&
        this.fixedData[current.value].key < key
      ) {
        fixedKey = this.fixedData[current.value].key;
        fixedFiles = this.getFixedFiles(current);
        yield (fixedKey, fixedFiles);
      };
      while (
        current.value < this.fixedData.size() &&
        this.fixedData[current.value].key == key
      ) {
        current.incr();
      };
      yield (key, this.getIterRaw(key));
    };
    while (current.value < this.fixedData.size()) {
      fixedKey = this.fixedData[current.value].key;
      fixedFiles = this.getFixedFiles(current);
      yield (fixedKey, fixedFiles);
    };
  }

  fun onFiles(
    process: mutable Iterator<(BaseName, mutable Iterator<File>)> ~> void,
  ): void {
    process(this.unsafeGetFileIter())
  }

  fun keys(): Set<BaseName> {
    fixedData = this.fixedData;
    current = 0;
    keys = mutable Set[];
    for (newKey => newValues in this.data) {
      while (current < fixedData.size() && fixedData[current].key < newKey) {
        row = fixedData[current];
        if (row.value.i1.size() > 0) {
          keys.insert(row.key);
        };
        !current = current + 1;
      };
      if (newValues.size() > 0) {
        keys.insert(newKey);
      };
    };
    while (current < fixedData.size()) {
      row = fixedData[current];
      if (row.value.i1.size() > 0) {
        keys.insert(row.key);
      };
      !current = current + 1;
    };
    keys.chill()
  }

  fun getDirName(): DirName {
    this.dirName
  }

  static fun getOld(child: EagerDir, key: Source): MInfo {
    if (child.old.containsKey(key)) {
      child.old[key]
    } else {
      child.fixedOld.maybeGet(key) match {
      | None() -> MInfo::empty()
      | Some(v) -> v
      }
    }
  }

  fun updateNewDirs(
    context: mutable Context,
    source: Source,
    newDirs: SortedSet<DirName>,
  ): this {
    removed = mutable Vector[];
    minfo = static::getOld(this, source);
    if (minfo.newDirs.isEmpty()) return this;

    lastRoundDirs = minfo.newDirs;
    for (dirName in lastRoundDirs) {
      if (newDirs.contains(dirName)) continue;
      context.removeDir(dirName);
      removed.push(dirName)
    };
    !minfo.newDirs = newDirs.toArray();
    !this.old[source] = minfo;

    for (dirName in removed) {
      updateDirtyReaders(context, Path::create(dirName.tag(), DIR_TAG));
    };
    this
  }

  fun writeArray(
    context: mutable Context,
    key: BaseName,
    values: Array<File>,
  ): void {
    source = Path::create(this.dirName, key);
    !this = this.writeEntry(context, source, key, values);
    context.!toReset = context.toReset.set(this.dirName);
    context.setDir(this.dirName, this);
  }

  fun size(context: mutable Context): Int {
    context.addDep(Path::create(this.dirName.size(), SIZE_TAG));
    this.totalSize
  }

  fun write(context: mutable Context, baseName: BaseName, value: File): void {
    this.writeArray(context, baseName, Array[value]);
  }

  fun remove(context: mutable Context, baseName: BaseName): void {
    this.writeArray(context, baseName, Array[]);
  }

  fun isDeleted(): Bool {
    false
  }
}
