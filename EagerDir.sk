/*****************************************************************************/
/* Eager directories. */
/*****************************************************************************/
module SKFS;

/*****************************************************************************/
/* The signature of a function used by apply. */
/*****************************************************************************/

type MapFun = (mutable Context, mutable Writer, BaseName, Array<File>) ~> void;

/*****************************************************************************/
/* The result of a map. */
/*****************************************************************************/

value class RowMapped<T>(
  key: BaseName,
  reads: Vector<Path>,
  values: Array<FixedRow<T>>,
  newDirs: SortedSet<DirName>,
)

/*****************************************************************************/
/* The result of a map, after the sorting and grouping. */
/*****************************************************************************/

value class GroupedRows<T>(
  rows: Array<FixedRow<T>>,
  old: Array<FixedRow<BaseName>>,
  newDirs: SortedMap<BaseName, SortedSet<DirName>>,
)

/*****************************************************************************/
/* Intermediate representation needed to compute the product. */
/*****************************************************************************/

class ProductRow(
  key1: BaseName,
  key2: BaseName,
  values: Array<File>,
) extends File

/*****************************************************************************/
/* An Eager Directory. */
/*****************************************************************************/

class EagerDir{
  time: Int,
  dirName: DirName,
  input: Bool,
  fixedData: FixedData<Array<File>>,
  totalSize: Int,
  fixedOld: FixedData<BaseName> = FixedData{},
  data: DMap<BaseName, SortedMap<Path, Array<File>>> = Nil(),
  old: SortedMap<BaseName, Array<BaseName>> = SortedMap[],
  newDirs: SortedMap<BaseName, SortedSet<DirName>> = SortedMap[],
  mapFun: ?MapFun = None(),

  parent: ?DirName = None(),
  childDirs: SortedMap<Int, DirName> = SortedMap[],
} extends Dir {
  fun isInput(): Bool {
    this.input
  }
  fun getTime(): Int {
    this.time
  }

  private static fun mapData(
    context: mutable Context,
    parent: EagerDir,
    f: MapFun,
    acc: mutable Vector<RowMapped<Array<File>>>,
  ): void {
    current = 0;
    addFixed = () -> {
      key = parent.fixedData.data[current].key;
      valueAcc = mutable Vector<(Path, Array<File>)>[];
      while (
        current < parent.fixedData.data.size() &&
        parent.fixedData.data[current].key == key
      ) {
        valueAcc.push(parent.fixedData.data[current].value);
        !current = current + 1;
      };
      fixedFiles = valueAcc.map(x -> x.i1).flatten().toArray();
      acc.push(static::mapRow(context, parent.dirName, key, fixedFiles, f));
    };
    for (key => _ in parent.data) {
      while (
        current < parent.fixedData.data.size() &&
        parent.fixedData.data[current].key < key
      ) {
        addFixed();
      };
      while (
        current < parent.fixedData.data.size() &&
        parent.fixedData.data[current].key == key
      ) {
        !current = current + 1;
      };
      acc.push(
        static::mapRow(
          context,
          parent.dirName,
          key,
          parent.getArrayRaw(key),
          f,
        ),
      );
    };
    while (current < parent.fixedData.data.size()) {
      addFixed();
    };
  }

  private static fun mapRow(
    context: mutable Context,
    parentName: DirName,
    key: BaseName,
    values: Array<File>,
    f: MapFun,
  ): RowMapped<Array<File>> {
    if (context.debugMode) {
      print_string(`MAP_ROW: ${parentName} ${key} ${inspect(values)}`);
    };
    writer = mutable Writer{};
    newDirsCopy = context.newDirs;
    readsCopy = context.reads;
    context.!newDirs = SortedSet[];
    context.!reads = mutable Vector[];

    f(context, writer, key, values);
    newDirs = context.newDirs;
    reads = context.getReads();
    context.!newDirs = newDirsCopy;
    context.!reads = readsCopy;
    kvArray = writer.getWrites();
    rows = kvArray.map(kv2 -> {
      (k2, v2) = kv2;
      path = Path::create(parentName, key);
      FixedRow(k2, (path, v2))
    });
    RowMapped(key, reads, rows, newDirs)
  }

  private static fun regroupMap(
    parentName: DirName,
    mapped: Vector<RowMapped<Array<File>>>,
    rowVec: mutable Vector<FixedRow<Array<File>>>,
    oldVec: mutable Vector<FixedRow<SKFS.BaseName>>,
    newDirsRef: mutable Ref<SortedMap<BaseName, SortedSet<DirName>>>,
  ): void {
    for (rowMapped in mapped) {
      key = rowMapped.key;
      rows = rowMapped.values;
      for (row in rows) {
        oldVec.push(FixedRow(key, (Path::create(parentName, key), row.key)));
        rowVec.push(row);
      };
      if (!rowMapped.newDirs.isEmpty()) {
        newDirs = newDirsRef.get();
        !newDirs = newDirs.set(key, rowMapped.newDirs);
        newDirsRef.set(newDirs);
      }
    };
  }

  fun product(
    context: mutable Context,
    productDirName: DirName,
    dir2: EagerDir,
    f: (mutable Context, BaseName, Array<File>, BaseName, Array<File>) ~> Array<
      File,
    >,
  ): void {
    static::apply(
      context,
      this.dirName,
      productDirName,
      (context, writer, key1, values1) ~> {
        if (values1.size() == 0) return void;
        hash1 = key1.hash();
        hash2 = (23, key1).hash();
        name = hash1.toString() + hash2;
        subProductDirName = productDirName.sub(name);
        static::apply(
          context,
          dir2.dirName,
          subProductDirName,
          (context, writer, key2, values2) ~> {
            if (values2.size() == 0) return void;
            values = f(context, key1, values1, key2, values2);
            writer.write(IID(0), ProductRow(key1, key2, values));
          },
        );
        subDir = context.getDir(subProductDirName);
        values = subDir.getArray(context, IID(0));
        if (values.size() == 0) {
          return void;
        };
        for (file in values) {
          row = ProductRow::fromFile(file);
          key = PID::create(Array[row.key1, row.key2]);
          writer.writeArray(key, row.values);
        }
      },
    );
  }

  static fun isReusable(child: EagerDir, f: MapFun): Bool {
    child.parent is Some _ && inspect(child.mapFun.fromSome()) == inspect(f)
  }

  static fun reuseDir(context: mutable Context, childName: DirName): void {
    if (context.debugMode) {
      print_string(`REUSING: ${childName}`);
    };
    context.!newDirs = context.newDirs.add(childName);
  }

  static fun apply(
    context: mutable Context,
    parentName: DirName,
    childName: DirName,
    f: MapFun,
  ): void {
    if (context.newDirs.contains(childName)) {
      error(`Error: directory ${childName.toString()} already exists`);
    };
    context.unsafeMaybeGetEagerDir(childName) match {
    | Some(child) if (static::isReusable(child, f)) ->
      static::reuseDir(context, childName);
      return void
    | _ -> void
    };
    acc = mutable Vector[];
    parent = context.unsafeGetEagerDir(parentName);
    context.!newDirs = context.newDirs.add(childName);
    static::mapData(context, parent, f, acc);
    mapped = acc.chill();
    dataVec = mutable Vector[];
    oldVec = mutable Vector[];
    newDirs = mutable Ref(SortedMap[]);
    static::regroupMap(parent.dirName, mapped, dataVec, oldVec, newDirs);
    static::updateReaders(context, parentName, childName, mapped);
    dataVec.sort();
    oldVec.sort();
    fixedData = FixedData{data => dataVec.toArray()};
    time = context.timeStamp();
    totalSize = fixedData.data.size();
    dir = EagerDir{
      time,
      dirName => childName,
      input => false,
      parent => Some(parentName),
      fixedData,
      totalSize,
      fixedOld => FixedData{data => oldVec.toArray()},
      mapFun => Some(f),
      newDirs => newDirs.get(),
      childDirs => SortedMap[],
    };
    updateDirtyReaders(context, Path::create(childName.tag(), DIR_TAG));
    context.setDir(childName, dir);
    static::addChildToParent(context, time, parentName, childName);
    if (context.debugMode) {
      print_string(
        `CREATED:  ${childName} (time: ${time}, parent: ${parentName})`,
      );
    };
  }

  private static fun addChildToParent(
    context: mutable Context,
    time: Int,
    parentName: DirName,
    childName: DirName,
  ): void {
    parent = context.unsafeGetEagerDir(parentName);
    !parent.childDirs = parent.childDirs.add(time, childName);
    context.setDir(parent.dirName, parent);
  }

  fun getArrayRaw(key: BaseName): Array<File> {
    fixedIter = this.fixedData.getIter(key);
    this.data.maybeGet(key) match {
    | None() ->
      acc = mutable Vector[];
      for (rows in fixedIter) {
        for (row in rows.i1) {
          acc.push(row);
        }
      };
      acc.toArray()
    | Some(modified) ->
      fixed = FixedDataIterator::create(this.fixedData.getIter(key));
      result = mutable Vector<File>[];

      for (path => values in modified) {
        while (!fixed.isEnd() && fixed.current().i0 < path) {
          for (file in fixed.current().i1) {
            result.push(file);
          };
          fixed.next();
        };
        while (!fixed.isEnd() && fixed.current().i0 == path) {
          fixed.next();
        };
        for (file in values) {
          result.push(file);
        }
      };
      while (!fixed.isEnd()) {
        for (file in fixed.current().i1) {
          result.push(file);
        };
        fixed.next();
      };
      result.toArray()
    }
  }

  static fun update(
    context: mutable Context,
    parentName: DirName,
    child: EagerDir,
  ): void {
    parent = context.unsafeGetEagerDir(parentName);
    childName = child.dirName;

    dirty = mutable Set[];
    if (context.dirtyReaders.containsKey(parent.dirName)) {
      if (context.dirtyReaders[parent.dirName].containsKey(childName)) {
        for (elt in context.dirtyReaders[parent.dirName][childName]) {
          dirty.insert(elt)
        }
      };
    };
    if (context.dirty.containsKey(parent.dirName)) {
      for (key in context.dirty[parent.dirName]) {
        dirty.insert(key);
      };
    };

    mapFun = child.mapFun match {
    | None() -> invariant_violation("Cannot update an input Directory")
    | Some(f) -> f
    };

    for (key in dirty) {
      values = parent.getArrayRaw(key);
      oldKeys = Set::mcreateFromItems(static::getOld(child, key));
      writer = mutable Writer{};
      newDirsCopy = context.newDirs;
      readsCopy = context.reads;
      context.!newDirs = SortedSet[];
      context.!reads = mutable Vector[];

      mapFun(context, writer, key, values);

      newDirs = context.newDirs;
      reads = context.getReads();
      context.!newDirs = newDirsCopy;
      context.!reads = readsCopy;

      !child = child.updateNewDirs(context, key, newDirs);
      mapped = writer.getWrites();

      for (read in reads) {
        readSet = context.newDeps.maybeGet(read) match {
        | None() -> SortedSet[]
        | Some(x) -> x
        };
        !readSet = readSet.set(ArrowKey(parentName, child.dirName, key));
        context.!newDeps[read] = readSet;
      };

      keys = mutable Vector[];
      source = Path::create(parentName, key);

      for (kv in mapped) {
        (k, rvalues) = kv;

        keys.push(k);
        if (oldKeys.contains(k)) {
          oldKeys.remove(k);
        };
        !child = child.writeEntry(context, source, k, rvalues);
      };

      // Let's remove the keys that no longer exist.
      for (k in oldKeys) {
        !child = child.writeEntry(context, source, k, Array[]);
      };

      // We need to remember what keys we produced for the next
      // time around.
      !child.old[key] = keys.toArray();
    };
    context.setDir(child.dirName, child);
  }

  fun getArray(context: mutable Context, key: BaseName): Array<File> {
    path = Path::create(this.dirName, key);
    context.addDep(path);
    values = this.getArrayRaw(key);
    if (values.size() != 0) return values;
    values
  }

  fun writeEntry(
    context: mutable Context,
    source: Path,
    k: BaseName,
    rvalues: Array<File>,
  ): this {
    oldValues = this.getArrayRaw(k);
    if (native_eq(rvalues, oldValues) == 0) return this;

    totalSize = if (oldValues.size() == 0 && rvalues.size() > 0) {
      this.totalSize + 1
    } else if (oldValues.size() > 0 && rvalues.size() == 0) {
      this.totalSize - 1
    } else {
      this.totalSize
    };

    map = this.data.maybeGet(k) match {
    | None() -> SortedMap[]
    | Some(x) -> x
    };
    !map = map.set(source, rvalues);
    data = this.data.set(TimeTag::create(context.tick), k, map);
    if (!context.dirty.containsKey(this.dirName)) {
      context.dirty![this.dirName] = mutable Set[];
    };
    context.dirty[this.dirName].insert(k);

    path = Path::create(this.dirName, k);

    if (this.totalSize != totalSize) {
      sizePath = Path::create(this.dirName.size(), SIZE_TAG);
      updateDirtyReaders(context, sizePath);
    };

    !this = this with {data, totalSize};

    updateDirtyReaders(context, path);

    for (childName in this.childDirs) {
      context.unsafeGetDir(childName) match {
      | child @ EagerDir _ ->
        context.!toUpdate = context.toUpdate.set(
          child.time,
          Arrow(this.dirName, childName),
        )
      | DeletedDir _ -> void
      | LazyDir _ -> invariant_violation("Unexpected child type")
      }
    };
    if (context.debugMode) {
      name = "" + this.dirName + k;
      print_string(`WRITTEN:  ${name} => ${inspect(rvalues)} (${source})`);
    };

    this
  }

  fun unsafeIterKeys(f: (BaseName, Int) -> void): void {
    fixedData = this.fixedData.data;
    current = 0;
    this.data.eachWithTime((newKey, time) -> {
      while (current < fixedData.size() && fixedData[current].key < newKey) {
        row = fixedData[current];
        f(row.key, 0);
        !current = current + 1;
      };
      f(newKey, time);
    });
    while (current < fixedData.size()) {
      row = fixedData[current];
      f(row.key, 0);
      !current = current + 1;
    };
  }

  fun files(): Set<BaseName> {
    fixedData = this.fixedData.data;
    current = 0;
    keys = mutable Set[];
    for (newKey => newValues in this.data) {
      while (current < fixedData.size() && fixedData[current].key < newKey) {
        row = fixedData[current];
        if (row.value.i1.size() > 0) {
          keys.insert(row.key);
        };
        !current = current + 1;
      };
      if (newValues.size() > 0) {
        keys.insert(newKey);
      };
    };
    while (current < fixedData.size()) {
      row = fixedData[current];
      if (row.value.i1.size() > 0) {
        keys.insert(row.key);
      };
      !current = current + 1;
    };
    keys.chill()
  }

  fun getDirName(): DirName {
    this.dirName
  }

  static fun getOld(child: EagerDir, key: BaseName): Array<BaseName> {
    if (child.old.containsKey(key)) {
      child.old[key]
    } else {
      child.fixedOld.getArray(key).map(x -> x.i1)
    }
  }

  private static fun updateReaders(
    context: mutable Context,
    parentName: DirName,
    childName: DirName,
    mapped: readonly Vector<RowMapped<Array<File>>>,
  ): void {
    readDirs = mutable Map[];
    deps = mutable Vector[];
    for (row in mapped) {
      for (read in row.reads) {
        if (!readDirs.containsKey(read.dirName)) {
          readDirs![read.dirName] = mutable Vector[];
        };
        readDirs[read.dirName].push((read.baseName, row.key));
      }
    };
    for (readDirName => reads in readDirs) {
      reads.sort();
      uniqReads = reads.unique();
      for (row in uniqReads) {
        readerKey = row.i0;
        readKey = row.i1;
        readerPath = Path::create(readDirName, readerKey);
        deps.push((readerPath, ArrowKey(parentName, childName, readKey)));
      };
    };
    context.!deps = List.Cons(deps.toArray(), context.deps);
  }

  fun updateNewDirs(
    context: mutable Context,
    key: BaseName,
    newDirs: SortedSet<DirName>,
  ): this {
    removed = mutable Vector[];
    this.newDirs.maybeGet(key) match {
    | None() -> if (newDirs.isEmpty()) return this
    | Some(lastRoundDirs) ->
      for (dirName in lastRoundDirs) {
        if (newDirs.contains(dirName)) continue;
        context.removeDir(dirName);
        removed.push(dirName);
      }
    };
    !this.newDirs = this.newDirs.set(key, newDirs);
    for (dirName in removed) {
      updateDirtyReaders(context, Path::create(dirName.tag(), DIR_TAG));
    };
    this
  }

  fun writeArray(
    context: mutable Context,
    key: BaseName,
    values: Array<File>,
  ): void {
    source = Path::create(this.dirName, key);
    !this = this.writeEntry(context, source, key, values);
    context.!toReset = context.toReset.set(this.dirName);
    context.setDir(this.dirName, this);
  }

  fun size(context: mutable Context): Int {
    context.addDep(Path::create(this.dirName.size(), SIZE_TAG));
    this.totalSize
  }

  fun write(context: mutable Context, baseName: BaseName, value: File): void {
    this.writeArray(context, baseName, Array[value]);
  }

  fun remove(context: mutable Context, baseName: BaseName): void {
    this.writeArray(context, baseName, Array[]);
  }

  fun isDeleted(): Bool {
    false
  }
}
