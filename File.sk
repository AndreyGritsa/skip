module SKFS;

extension base class .Inspect {
  fun simplePrint(o: String -> void): void
  | .InspectSpecial(v) -> o("'" + v + "'")
  | .InspectString(v) -> o("\"" + v + "\"")
  | .InspectLiteral(v) -> o(v)
  | .InspectVector(name, values) ->
    o(name + "[");
    if (values.size() == 0) {
      o("]");
      return void;
    };
    for (i in Range(0, values.size() - 1)) {
      elt = values[i];
      elt.simplePrint(o);
      o(",");
    };
    values[values.size() - 1].simplePrint(o);
    o("]")
  | .InspectMap(name, values) ->
    o(name + "[");
    if (values.size() == 0) {
      o("]");
      return void;
    };
    for (i in Range(0, values.size() - 1)) {
      (elt, value) = values[i];
      elt.simplePrint(o);
      o("=>");
      value.simplePrint(o);
      o(",");
    };
    (elt, value) = values[values.size() - 1];
    elt.simplePrint(o);
    o("=>");
    value.simplePrint(o);
    o(",");
    o("]")
  | .InspectCall(name, values) ->
    o(name + "(");
    if (values.size() == 0) {
      o(")");
      return void;
    };
    for (i in Range(0, values.size() - 1)) {
      elt = values[i];
      elt.simplePrint(o);
      o(",");
    };
    values[values.size() - 1].simplePrint(o);
    o(")")
  | .InspectObject(name, values) ->
    o(name + "{");
    if (values.size() == 0) {
      o("}");
      return void;
    };
    for (i in Range(0, values.size() - 1)) {
      (key, value) = values[i];
      o(key);
      o("=>");
      value.simplePrint(o);
      o(",");
    };
    (key, value) = values[values.size() - 1];
    o(key);
    o("=>");
    value.simplePrint(o);
    o(",");
    o("}")

  fun toString(): String {
    buffer = mutable Vector[];
    o = (x) -> buffer.push(x);
    this.simplePrint(o);
    "".join(buffer);
  }
}

class ErrorTrace(origDir: String, key: String, msg: String)
class ErrorFile(trace: List<ErrorTrace>) extends File, Exception {
  fun toString(): String {
    result = mutable Vector[];
    for (elt in this.trace) {
      result.push(`${elt.origDir}${elt.key}: ${elt.msg}\n`)
    };
    "".join(result)
  }
}

class IntFile(value: Int) extends File

trait Cast {
  macro static fun fromFile(obj: File): this {
    obj match {
    | x @ #ThisClass _ -> x
    | exn @ ErrorFile _ -> throw (exn)
    | _ -> invariant_violation("Invalid cast")
    }
  }
}
base class File uses Cast

class GroupRequest{userID: IID, groupID: IID} extends File {
  fun getKey(): BaseName {
    this.userID
  }
}

class BlockRequest{userID: IID, groupID: IID} extends File {
  fun getKey(): BaseName {
    this.userID
  }
}

class User{
  id: BaseName,
  firstName: String,
  lastName: String,
  age: Int,
  groupIDs: Array<SKFS.BaseName>,
} extends SKFS.File

class Group{id: BaseName, name: String, description: String} extends SKFS.File {
  fun rules(): Array<Rule> {
    Array[AllowIf((vc) ~> vc.isMemberOfGroup(this.id)), AlwaysDeny()]
  }
}
class GroupPost{groupID: BaseName, data: String} extends SKFS.File

mutable class ViewerContext{
  context: mutable Context,
  isSuperUser: Bool = false,
  groupRequests: Dir,
  blockRequests: Dir,
} {
  readonly fun isMemberOfGroup(_gid: BaseName): Bool {
    if (this.isSuperUser) return true;
    false
  }
}

base class Rule {
  children =
  | AllowIf((mutable ViewerContext) ~> Bool)
  | DenyIf((mutable ViewerContext) ~> Bool)
  | AlwaysAllow()
  | AlwaysDeny()

  fun canSee(vc: mutable ViewerContext): Bool
  | AllowIf(f) -> f(vc)
  | DenyIf(f) -> !f(vc)
  | AlwaysAllow() -> true
  | AlwaysDeny() -> false
}

untracked fun loadData(fileName: String): Array<(BaseName, String)> {
  content = FileSystem.readTextFile(fileName);
  id = 0;
  result = mutable Vector[];
  content.split("\n").each(x -> {
    if (x == "") return void;
    result.push((IID(id), x));
    !id = id + 1;
  });
  result.toArray()
}

module end;
