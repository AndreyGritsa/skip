module SKFS;

@cpp_extern("SKIP_create_external_pointer")
native fun createExternalPointer(ExternalPointer): ExternalPointer;

class ExternalPointer private (
  value: Int,
  destructor: Int ~> void,
) extends File {
  static fun create(value: Int, destructor: Int ~> void): this {
    createExternalPointer(static(value, destructor));
  }

  static fun getExternalPointer(): ExternalPointer {
    ExternalPointer(0, _ ~> void)
  }
}

@cpp_export("sk_get_external_pointer")
fun getExternalPointer(): ExternalPointer {
  ExternalPointer::getExternalPointer()
}

@cpp_export("sk_get_external_pointer_value")
fun getValue(p: ExternalPointer): Int {
  p.value
}

@cpp_export("sk_get_external_pointer_destructor")
fun getDestructor(p: ExternalPointer): Int ~> void {
  p.destructor
}

@cpp_export("sk_call_external_pointer_descructor")
fun callDestructor(destructor: Int ~> void, value: Int): void {
  destructor(value)
}

extension base class .Inspect {
  fun simplePrint(o: String -> void): void
  | .InspectSpecial(v) -> o("'" + v + "'")
  | .InspectString(v) -> o("\"" + v + "\"")
  | .InspectLiteral(v) -> o(v)
  | .InspectVector(name, values) ->
    o(name + "[");
    if (values.size() == 0) {
      o("]");
      return void;
    };
    for (i in Range(0, values.size() - 1)) {
      elt = values[i];
      elt.simplePrint(o);
      o(",");
    };
    values[values.size() - 1].simplePrint(o);
    o("]")
  | .InspectMap(name, values) ->
    o(name + "[");
    if (values.size() == 0) {
      o("]");
      return void;
    };
    for (i in Range(0, values.size() - 1)) {
      (elt, value) = values[i];
      elt.simplePrint(o);
      o("=>");
      value.simplePrint(o);
      o(",");
    };
    (elt, value) = values[values.size() - 1];
    elt.simplePrint(o);
    o("=>");
    value.simplePrint(o);
    o(",");
    o("]")
  | .InspectCall(name, values) ->
    o(name + "(");
    if (values.size() == 0) {
      o(")");
      return void;
    };
    for (i in Range(0, values.size() - 1)) {
      elt = values[i];
      elt.simplePrint(o);
      o(",");
    };
    values[values.size() - 1].simplePrint(o);
    o(")")
  | .InspectObject(name, values) ->
    o(name + "{");
    if (values.size() == 0) {
      o("}");
      return void;
    };
    for (i in Range(0, values.size() - 1)) {
      (key, value) = values[i];
      o(key);
      o("=>");
      value.simplePrint(o);
      o(",");
    };
    (key, value) = values[values.size() - 1];
    o(key);
    o("=>");
    value.simplePrint(o);
    o(",");
    o("}")

  fun toString(): String {
    buffer = mutable Vector[];
    o = (x) -> buffer.push(x);
    this.simplePrint(o);
    "".join(buffer);
  }
}

class IntFile(value: Int) extends File uses Orderable, Show {
  fun +<T: Integral>(x: T): IntFile {
    !this.value = this.value + x;
    this
  }
  fun -<T: Integral>(x: T): IntFile {
    !this.value = this.value + x;
    this
  }
  fun toString(): String {
    this.value.toString()
  }
}

class StringFile(value: .String) extends File

base class File {
  deferred macro overridable static fun fromFile(obj: File): this {
    obj match {
    | x @ #ThisClass _ -> x
    }
  }
}

trait CGroup {
  fun zero(): inst;
  fun +(inst): inst;
  fun -(inst): inst;
}

base class CGroupFile extends File uses CGroup

extension class .Int uses CGroup {
  fun zero(): .Int {
    0
  }
}

module end;
