fun fixPointElt<T: Hashable & Orderable>(
  visited: SortedSet<T>,
  mem: mutable Map<T, Set<T>>,
  key: T,
  f: T -> Set<T>,
): Set<T> {
  if (visited.contains(key)) return Set[key];
  !visited = visited.add(key);
  if (mem.containsKey(key)) return mem[key];
  set = Set::mcreateFromItems(f(key));
  subs = mutable Vector[];
  for (elt in set) {
    subs.push(fixPointElt(visited, mem, elt, f));
  };
  set.extend(subs.flatten());
  freeze(set)
}

fun fixPoint<T: Hashable & Orderable>(
  roots: SortedSet<T>,
  f: T -> Set<T>,
): Set<T> {
  mem = mutable Map[];
  set = Set::mcreateFromItems(roots.values().collect(Set));
  subs = mutable Vector[];
  for (elt in set) {
    subs.push(fixPointElt(SortedSet[], mem, elt, f));
  };
  set.extend(subs.flatten());
  freeze(set)
}
