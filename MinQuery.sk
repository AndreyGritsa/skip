module SKFS;

class IntOptionFile(value: ?Int) extends File
class BaseNameOptionFile(value: ?BaseName) extends File
class DiffKeyFile(cmp: Int, key: BaseName) extends File

fun minDir<T: frozen>(
  context: mutable Context,
  dirHandle: Handle<T>,
  diffName: String,
  name: String,
): Handle<BaseNameOptionFile> {
  diffMinDirName = DirName::create(
    dirHandle.dirName.toString() + diffName + "/",
  );
  minDirName = DirName::create(dirHandle.dirName.toString() + name + "/");
  context
    .unsafeGetDir(dirHandle.dirName)
    .apply(context, diffMinDirName, (context, writer, key, newValues) ~> {
      preDiffOpt = Handle(dirHandle.conv, dirHandle.dirName).pre(context);
      oldValues = preDiffOpt match {
      | None() -> Array[]
      | Some(preDir) -> preDir.getArray(context, key)
      };
      oldMin = if (oldValues.size() == 0) 0 else 1;
      newMin = if (newValues.size() == 0) 0 else 1;
      cmp = newMin - oldMin;
      if (cmp != 0) {
        writer.write(IID(0), DiffKeyFile(cmp, key))
      }
    });
  minDir = Handle(BaseNameOptionFile::fromFile, minDirName);
  diffDir = context.unsafeGetDir(diffMinDirName);
  diffDir.apply(context, minDirName, (context, writer, _, diffs) ~> {
    acc: ?BaseName = minDir.pre(context) match {
    | None() -> None()
    | Some(preDir) -> preDir.getArray(context, IID(0))[0].value
    };
    for (diff in diffs) {
      debug(("DIFF", acc, diff));
      keyFile = DiffKeyFile::fromFile(diff);
      if (keyFile.cmp < 0) {
        if (acc is None _) continue;
        if (acc is Some _ && acc.fromSome() < keyFile.key) continue;
        dir = context.unsafeGetDir(dirHandle.dirName);
        minData = dir.data.minKey(kv ~> {
          (key, _) = kv;
          dir.getArrayRaw(key).size() > 0
        });
        current = 0;
        minFixedData = while (current < dir.fixedData.data.size()) {
          row = dir.fixedData.data[current];
          values = dir.getArrayRaw(row.key);
          if (values.size() != 0) {
            break (Some(row.key));
          };
          !current = current + 1;
        } else {
          None()
        };
        (minData, minFixedData) match {
        | (None(), None()) -> !acc = None()
        | (x @ Some _, None())
        | (None(), x @ Some _) ->
          !acc = x
        | (Some _, Some _) -> !acc = min(minData, minFixedData)
        }
      } else {
        invariant(keyFile.cmp == 1);
        !acc = acc match {
        | None() -> Some(keyFile.key)
        | Some(y) -> Some(min(y, keyFile.key))
        }
      };
    };
    writer.write(IID(0), BaseNameOptionFile(acc));
  });
  minDir
}

module end;

module SKFSTest;

fun testMin(): mutable SKFS.Context {
  context = SKFS.run(context ~> {
    inputFiles = mutable Map[
      SKFS.IID(23) => SKFS.StringFile("23"),
      SKFS.IID(35) => SKFS.StringFile("35"),
      SKFS.IID(37) => SKFS.StringFile("37"),
    ];

    sinput = SKFS.DirName::create("/sinput/");
    dirSInput = context.mkdir(
      SKFS.StringFile::fromFile,
      sinput,
      inputFiles.items().collect(Array),
    );

    _minDir = SKFS.minDir(context, dirSInput, "diffMin", "min");
  });

  testNbr = 0;
  _incrTestNbr = () -> {
    !testNbr = testNbr + 1;
    testNbr
  };

  _dirSInput = SKFS.Handle(
    SKFS.StringFile::fromFile,
    SKFS.DirName::create("/sinput/"),
  );

  _minDir = SKFS.Handle(
    SKFS.IntFile::fromFile,
    SKFS.DirName::create("/sinput/min/"),
  );
  context
}
